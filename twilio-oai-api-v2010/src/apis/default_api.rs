/*
 * Twilio - Api
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_account`
#[derive(Clone, Debug, Default)]
pub struct CreateAccountParams {
    /// A human readable description of the account to create, defaults to `SubAccount Created at {YYYY-MM-DD HH:MM meridian}`
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `create_address`
#[derive(Clone, Debug, Default)]
pub struct CreateAddressParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will be responsible for the new Address resource.
    pub account_sid: String,
    /// The city of the new address.
    pub city: String,
    /// The name to associate with the new address.
    pub customer_name: String,
    /// The ISO country code of the new address.
    pub iso_country: String,
    /// The postal code of the new address.
    pub postal_code: String,
    /// The state or region of the new address.
    pub region: String,
    /// The number and street address of the new address.
    pub street: String,
    /// Whether we should automatically correct the address. Can be: `true` or `false` and the default is `true`. If empty or `true`, we will correct the address you provide if necessary. If `false`, we won't alter the address you provide.
    pub auto_correct_address: Option<bool>,
    /// Whether to enable emergency calling on the new address. Can be: `true` or `false`.
    pub emergency_enabled: Option<bool>,
    /// A descriptive string that you create to describe the new address. It can be up to 64 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `create_application`
#[derive(Clone, Debug, Default)]
pub struct CreateApplicationParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The API version to use to start a new TwiML session. Can be: `2010-04-01` or `2008-08-01`. The default value is the account's default API version.
    pub api_version: Option<String>,
    /// A descriptive string that you create to describe the new application. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The URL we should call using a POST method to send message status information to your application.
    pub message_status_callback: Option<String>,
    /// The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`.
    pub sms_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while retrieving or executing the TwiML from `sms_url`.
    pub sms_fallback_url: Option<String>,
    /// The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`.
    pub sms_method: Option<String>,
    /// The URL we should call using a POST method to send status information about SMS messages sent by the application.
    pub sms_status_callback: Option<String>,
    /// The URL we should call when the phone number receives an incoming SMS message.
    pub sms_url: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`.
    pub status_callback_method: Option<String>,
    /// Whether we should look up the caller's caller-ID name from the CNAM database (additional charges apply). Can be: `true` or `false`.
    pub voice_caller_id_lookup: Option<bool>,
    /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`.
    pub voice_method: Option<String>,
    /// The URL we should call when the phone number assigned to this application receives a call.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `create_call`
#[derive(Clone, Debug, Default)]
pub struct CreateCallParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The phone number or client identifier to use as the caller id. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `From` must also be a phone number.
    pub from: String,
    /// The phone number, SIP address, or client identifier to call.
    pub to: String,
    /// The SID of the Application resource that will handle the call, if the call will be handled by an application.
    pub application_sid: Option<String>,
    /// Select whether to perform answering machine detection in the background. Default, blocks the execution of the call until Answering Machine Detection is completed. Can be: `true` or `false`.
    pub async_amd: Option<String>,
    /// The URL that we should call using the `async_amd_status_callback_method` to notify customer application whether the call was answered by human, machine or fax.
    pub async_amd_status_callback: Option<String>,
    /// The HTTP method we should use when calling the `async_amd_status_callback` URL. Can be: `GET` or `POST` and the default is `POST`.
    pub async_amd_status_callback_method: Option<String>,
    /// The SID of a BYOC (Bring Your Own Carrier) trunk to route this call with. Note that `byoc` is only meaningful when `to` is a phone number; it will otherwise be ignored. (Beta)
    pub byoc: Option<String>,
    /// The Reason for the outgoing call. Use it to specify the purpose of the call that is presented on the called party's phone. (Branded Calls Beta)
    pub call_reason: Option<String>,
    /// A token string needed to invoke a forwarded call. A call_token is generated when an incoming call is received on a Twilio number. this field should be populated by the incoming call's call_token to make this outgoing call as a forwarded call of incoming call. A forwarded call should bear the same caller-id of incoming call.
    pub call_token: Option<String>,
    /// The phone number, SIP address, or Client identifier that made this call. Phone numbers are in [E.164 format](https://wwnw.twilio.com/docs/glossary/what-e164) (e.g., +16175551212). SIP addresses are formatted as `name@company.com`.
    pub caller_id: Option<String>,
    /// The HTTP method that we should use to request the `fallback_url`. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
    pub fallback_method: Option<String>,
    /// The URL that we call using the `fallback_method` if an error occurs when requesting or executing the TwiML at `url`. If an `application_sid` parameter is present, this parameter is ignored.
    pub fallback_url: Option<String>,
    /// Whether to detect if a human, answering machine, or fax has picked up the call. Can be: `Enable` or `DetectMessageEnd`. Use `Enable` if you would like us to return `AnsweredBy` as soon as the called party is identified. Use `DetectMessageEnd`, if you would like to leave a message on an answering machine. If `send_digits` is provided, this parameter is ignored. For more information, see [Answering Machine Detection](https://www.twilio.com/docs/voice/answering-machine-detection).
    pub machine_detection: Option<String>,
    /// The number of milliseconds of initial silence after which an `unknown` AnsweredBy result will be returned. Possible Values: 2000-10000. Default: 5000.
    pub machine_detection_silence_timeout: Option<i32>,
    /// The number of milliseconds of silence after speech activity at which point the speech activity is considered complete. Possible Values: 500-5000. Default: 1200.
    pub machine_detection_speech_end_threshold: Option<i32>,
    /// The number of milliseconds that is used as the measuring stick for the length of the speech activity, where durations lower than this value will be interpreted as a human and longer than this value as a machine. Possible Values: 1000-6000. Default: 2400.
    pub machine_detection_speech_threshold: Option<i32>,
    /// The number of seconds that we should attempt to detect an answering machine before timing out and sending a voice request with `AnsweredBy` of `unknown`. The default timeout is 30 seconds.
    pub machine_detection_timeout: Option<i32>,
    /// The HTTP method we should use when calling the `url` parameter's value. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
    pub method: Option<String>,
    /// Whether to record the call. Can be `true` to record the phone call, or `false` to not. The default is `false`. The `recording_url` is sent to the `status_callback` URL.
    pub record: Option<bool>,
    /// The number of channels in the final recording. Can be: `mono` or `dual`. The default is `mono`. `mono` records both legs of the call in a single channel of the recording file. `dual` records each leg to a separate channel of the recording file. The first channel of a dual-channel recording contains the parent call and the second channel contains the child call.
    pub recording_channels: Option<String>,
    /// The URL that we call when the recording is available to be accessed.
    pub recording_status_callback: Option<String>,
    /// The recording status events that will trigger calls to the URL specified in `recording_status_callback`. Can be: `in-progress`, `completed` and `absent`. Defaults to `completed`. Separate  multiple values with a space.
    pub recording_status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use when calling the `recording_status_callback` URL. Can be: `GET` or `POST` and the default is `POST`.
    pub recording_status_callback_method: Option<String>,
    /// The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The default is `both`. `inbound` records the audio that is received by Twilio. `outbound` records the audio that is generated from Twilio. `both` records the audio that is received and generated by Twilio.
    pub recording_track: Option<String>,
    /// A string of keys to dial after connecting to the number, maximum of 32 digits. Valid digits in the string include: any digit (`0`-`9`), '`#`', '`*`' and '`w`', to insert a half second pause. For example, if you connected to a company phone number and wanted to pause for one second, and then dial extension 1234 followed by the pound key, the value of this parameter would be `ww1234#`. Remember to URL-encode this string, since the '`#`' character has special meaning in a URL. If both `SendDigits` and `MachineDetection` parameters are provided, then `MachineDetection` will be ignored.
    pub send_digits: Option<String>,
    /// The password required to authenticate the user account specified in `sip_auth_username`.
    pub sip_auth_password: Option<String>,
    /// The username used to authenticate the caller making a SIP call.
    pub sip_auth_username: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application. If no `status_callback_event` is specified, we will send the `completed` status. If an `application_sid` parameter is present, this parameter is ignored. URLs must contain a valid hostname (underscores are not permitted).
    pub status_callback: Option<String>,
    /// The call progress events that we will send to the `status_callback` URL. Can be: `initiated`, `ringing`, `answered`, and `completed`. If no event is specified, we send the `completed` status. If you want to receive multiple events, specify each one in a separate `status_callback_event` parameter. See the code sample for [monitoring call progress](https://www.twilio.com/docs/voice/api/call-resource?code-sample=code-create-a-call-resource-and-specify-a-statuscallbackevent&code-sdk-version=json). If an `application_sid` is present, this parameter is ignored.
    pub status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use when calling the `status_callback` URL. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
    pub status_callback_method: Option<String>,
    /// The maximum duration of the call in seconds. Constraints depend on account and configuration.
    pub time_limit: Option<i32>,
    /// The integer number of seconds that we should allow the phone to ring before assuming there is no answer. The default is `60` seconds and the maximum is `600` seconds. For some call flows, we will add a 5-second buffer to the timeout value you provide. For this reason, a timeout value of 10 seconds could result in an actual timeout closer to 15 seconds. You can set this to a short time, such as `15` seconds, to hang up before reaching an answering machine or voicemail.
    pub timeout: Option<i32>,
    /// Whether to trim any leading and trailing silence from the recording. Can be: `trim-silence` or `do-not-trim` and the default is `trim-silence`.
    pub trim: Option<String>,
    /// TwiML instructions for the call Twilio will use without fetching Twiml from url parameter. If both `twiml` and `url` are provided then `twiml` parameter will be ignored.
    pub twiml: Option<String>,
    /// The absolute URL that returns the TwiML instructions for the call. We will call this URL using the `method` when the call connects. For more information, see the [Url Parameter](https://www.twilio.com/docs/voice/make-calls#specify-a-url-parameter) section in [Making Calls](https://www.twilio.com/docs/voice/make-calls).
    pub url: Option<String>
}

/// struct for passing parameters to the method `create_call_feedback_summary`
#[derive(Clone, Debug, Default)]
pub struct CreateCallFeedbackSummaryParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// Only include feedback given on or before this date. Format is `YYYY-MM-DD` and specified in UTC.
    pub end_date: String,
    /// Only include feedback given on or after this date. Format is `YYYY-MM-DD` and specified in UTC.
    pub start_date: String,
    /// Whether to also include Feedback resources from all subaccounts. `true` includes feedback from all subaccounts and `false`, the default, includes feedback from only the specified account.
    pub include_subaccounts: Option<bool>,
    /// The URL that we will request when the feedback summary is complete.
    pub status_callback: Option<String>,
    /// The HTTP method (`GET` or `POST`) we use to make the request to the `StatusCallback` URL.
    pub status_callback_method: Option<String>
}

/// struct for passing parameters to the method `create_call_recording`
#[derive(Clone, Debug, Default)]
pub struct CreateCallRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the [Call](https://www.twilio.com/docs/voice/api/call-resource) to associate the resource with.
    pub call_sid: String,
    /// The number of channels used in the recording. Can be: `mono` or `dual` and the default is `mono`. `mono` records all parties of the call into one channel. `dual` records each party of a 2-party call into separate channels.
    pub recording_channels: Option<String>,
    /// The URL we should call using the `recording_status_callback_method` on each recording event specified in  `recording_status_callback_event`. For more information, see [RecordingStatusCallback parameters](https://www.twilio.com/docs/voice/api/recording#recordingstatuscallback).
    pub recording_status_callback: Option<String>,
    /// The recording status events on which we should call the `recording_status_callback` URL. Can be: `in-progress`, `completed` and `absent` and the default is `completed`. Separate multiple event values with a space.
    pub recording_status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use to call `recording_status_callback`. Can be: `GET` or `POST` and the default is `POST`.
    pub recording_status_callback_method: Option<String>,
    /// The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The default is `both`. `inbound` records the audio that is received by Twilio. `outbound` records the audio that is generated from Twilio. `both` records the audio that is received and generated by Twilio.
    pub recording_track: Option<String>,
    /// Whether to trim any leading and trailing silence in the recording. Can be: `trim-silence` or `do-not-trim` and the default is `do-not-trim`. `trim-silence` trims the silence from the beginning and end of the recording and `do-not-trim` does not.
    pub trim: Option<String>
}

/// struct for passing parameters to the method `create_incoming_phone_number`
#[derive(Clone, Debug, Default)]
pub struct CreateIncomingPhoneNumberParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
    pub address_sid: Option<String>,
    /// The API version to use for incoming calls made to the new phone number. The default is `2010-04-01`.
    pub api_version: Option<String>,
    /// The desired area code for your new incoming phone number. Can be any three-digit, US or Canada area code. We will provision an available phone number within this area code for you. **You must provide an `area_code` or a `phone_number`.** (US and Canada only).
    pub area_code: Option<String>,
    /// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
    pub bundle_sid: Option<String>,
    /// The SID of the emergency address configuration to use for emergency calling from the new phone number.
    pub emergency_address_sid: Option<String>,
    /// The configuration status parameter that determines whether the new phone number is enabled for emergency calling.
    pub emergency_status: Option<String>,
    /// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, this is a formatted version of the new phone number.
    pub friendly_name: Option<String>,
    /// The SID of the Identity resource that we should associate with the new phone number. Some regions require an identity to meet local regulations.
    pub identity_sid: Option<String>,
    /// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
    pub phone_number: Option<String>,
    /// The SID of the application that should handle SMS messages sent to the new phone number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` urls and use those set on the application.
    pub sms_application_sid: Option<String>,
    /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub sms_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while requesting or executing the TwiML defined by `sms_url`.
    pub sms_fallback_url: Option<String>,
    /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub sms_method: Option<String>,
    /// The URL we should call when the new phone number receives an incoming SMS message.
    pub sms_url: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub status_callback_method: Option<String>,
    /// The SID of the Trunk we should use to handle calls to the new phone number. If a `trunk_sid` is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
    pub trunk_sid: Option<String>,
    /// The SID of the application we should use to handle calls to the new phone number. If a `voice_application_sid` is present, we ignore all of the voice urls and use only those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
    pub voice_application_sid: Option<String>,
    /// Whether to lookup the caller's name from the CNAM database and post it to your app. Can be: `true` or `false` and defaults to `false`.
    pub voice_caller_id_lookup: Option<bool>,
    /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub voice_method: Option<String>,
    /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
    pub voice_receive_mode: Option<String>,
    /// The URL that we should call to answer a call to the new phone number. The `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `create_incoming_phone_number_assigned_add_on`
#[derive(Clone, Debug, Default)]
pub struct CreateIncomingPhoneNumberAssignedAddOnParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the Phone Number to assign the Add-on.
    pub resource_sid: String,
    /// The SID that identifies the Add-on installation.
    pub installed_add_on_sid: String
}

/// struct for passing parameters to the method `create_incoming_phone_number_local`
#[derive(Clone, Debug, Default)]
pub struct CreateIncomingPhoneNumberLocalParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
    pub phone_number: String,
    /// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
    pub address_sid: Option<String>,
    /// The API version to use for incoming calls made to the new phone number. The default is `2010-04-01`.
    pub api_version: Option<String>,
    /// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
    pub bundle_sid: Option<String>,
    /// The SID of the emergency address configuration to use for emergency calling from the new phone number.
    pub emergency_address_sid: Option<String>,
    /// The configuration status parameter that determines whether the new phone number is enabled for emergency calling.
    pub emergency_status: Option<String>,
    /// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, this is a formatted version of the phone number.
    pub friendly_name: Option<String>,
    /// The SID of the Identity resource that we should associate with the new phone number. Some regions require an identity to meet local regulations.
    pub identity_sid: Option<String>,
    /// The SID of the application that should handle SMS messages sent to the new phone number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` urls and use those set on the application.
    pub sms_application_sid: Option<String>,
    /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub sms_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while requesting or executing the TwiML defined by `sms_url`.
    pub sms_fallback_url: Option<String>,
    /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub sms_method: Option<String>,
    /// The URL we should call when the new phone number receives an incoming SMS message.
    pub sms_url: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub status_callback_method: Option<String>,
    /// The SID of the Trunk we should use to handle calls to the new phone number. If a `trunk_sid` is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
    pub trunk_sid: Option<String>,
    /// The SID of the application we should use to handle calls to the new phone number. If a `voice_application_sid` is present, we ignore all of the voice urls and use only those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
    pub voice_application_sid: Option<String>,
    /// Whether to lookup the caller's name from the CNAM database and post it to your app. Can be: `true` or `false` and defaults to `false`.
    pub voice_caller_id_lookup: Option<bool>,
    /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub voice_method: Option<String>,
    /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
    pub voice_receive_mode: Option<String>,
    /// The URL that we should call to answer a call to the new phone number. The `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `create_incoming_phone_number_mobile`
#[derive(Clone, Debug, Default)]
pub struct CreateIncomingPhoneNumberMobileParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
    pub phone_number: String,
    /// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
    pub address_sid: Option<String>,
    /// The API version to use for incoming calls made to the new phone number. The default is `2010-04-01`.
    pub api_version: Option<String>,
    /// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
    pub bundle_sid: Option<String>,
    /// The SID of the emergency address configuration to use for emergency calling from the new phone number.
    pub emergency_address_sid: Option<String>,
    /// The configuration status parameter that determines whether the new phone number is enabled for emergency calling.
    pub emergency_status: Option<String>,
    /// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, the is a formatted version of the phone number.
    pub friendly_name: Option<String>,
    /// The SID of the Identity resource that we should associate with the new phone number. Some regions require an identity to meet local regulations.
    pub identity_sid: Option<String>,
    /// The SID of the application that should handle SMS messages sent to the new phone number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` urls and use those of the application.
    pub sms_application_sid: Option<String>,
    /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub sms_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while requesting or executing the TwiML defined by `sms_url`.
    pub sms_fallback_url: Option<String>,
    /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub sms_method: Option<String>,
    /// The URL we should call when the new phone number receives an incoming SMS message.
    pub sms_url: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub status_callback_method: Option<String>,
    /// The SID of the Trunk we should use to handle calls to the new phone number. If a `trunk_sid` is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
    pub trunk_sid: Option<String>,
    /// The SID of the application we should use to handle calls to the new phone number. If a `voice_application_sid` is present, we ignore all of the voice urls and use only those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
    pub voice_application_sid: Option<String>,
    /// Whether to lookup the caller's name from the CNAM database and post it to your app. Can be: `true` or `false` and defaults to `false`.
    pub voice_caller_id_lookup: Option<bool>,
    /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub voice_method: Option<String>,
    /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
    pub voice_receive_mode: Option<String>,
    /// The URL that we should call to answer a call to the new phone number. The `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `create_incoming_phone_number_toll_free`
#[derive(Clone, Debug, Default)]
pub struct CreateIncomingPhoneNumberTollFreeParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The phone number to purchase specified in [E.164](https://www.twilio.com/docs/glossary/what-e164) format.  E.164 phone numbers consist of a + followed by the country code and subscriber number without punctuation characters. For example, +14155551234.
    pub phone_number: String,
    /// The SID of the Address resource we should associate with the new phone number. Some regions require addresses to meet local regulations.
    pub address_sid: Option<String>,
    /// The API version to use for incoming calls made to the new phone number. The default is `2010-04-01`.
    pub api_version: Option<String>,
    /// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
    pub bundle_sid: Option<String>,
    /// The SID of the emergency address configuration to use for emergency calling from the new phone number.
    pub emergency_address_sid: Option<String>,
    /// The configuration status parameter that determines whether the new phone number is enabled for emergency calling.
    pub emergency_status: Option<String>,
    /// A descriptive string that you created to describe the new phone number. It can be up to 64 characters long. By default, this is a formatted version of the phone number.
    pub friendly_name: Option<String>,
    /// The SID of the Identity resource that we should associate with the new phone number. Some regions require an Identity to meet local regulations.
    pub identity_sid: Option<String>,
    /// The SID of the application that should handle SMS messages sent to the new phone number. If an `sms_application_sid` is present, we ignore all `sms_*_url` values and use those of the application.
    pub sms_application_sid: Option<String>,
    /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub sms_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while requesting or executing the TwiML defined by `sms_url`.
    pub sms_fallback_url: Option<String>,
    /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub sms_method: Option<String>,
    /// The URL we should call when the new phone number receives an incoming SMS message.
    pub sms_url: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub status_callback_method: Option<String>,
    /// The SID of the Trunk we should use to handle calls to the new phone number. If a `trunk_sid` is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
    pub trunk_sid: Option<String>,
    /// The SID of the application we should use to handle calls to the new phone number. If a `voice_application_sid` is present, we ignore all of the voice urls and use those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
    pub voice_application_sid: Option<String>,
    /// Whether to lookup the caller's name from the CNAM database and post it to your app. Can be: `true` or `false` and defaults to `false`.
    pub voice_caller_id_lookup: Option<bool>,
    /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub voice_method: Option<String>,
    /// The configuration parameter for the new phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
    pub voice_receive_mode: Option<String>,
    /// The URL that we should call to answer a call to the new phone number. The `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `create_message`
#[derive(Clone, Debug, Default)]
pub struct CreateMessageParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The destination phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format for SMS/MMS or [Channel user address](https://www.twilio.com/docs/sms/channels#channel-addresses) for other 3rd-party channels.
    pub to: String,
    /// Determines if the address can be stored or obfuscated based on privacy settings
    pub address_retention: Option<String>,
    /// The SID of the application that should receive message status. We POST a `message_sid` parameter and a `message_status` parameter with a value of `sent` or `failed` to the [application](https://www.twilio.com/docs/usage/api/applications)'s `message_status_callback`. If a `status_callback` parameter is also passed, it will be ignored and the application's `message_status_callback` parameter will be used.
    pub application_sid: Option<String>,
    /// Total number of attempts made ( including this ) to send out the message regardless of the provider used
    pub attempt: Option<i32>,
    /// The text of the message you want to send. Can be up to 1,600 characters in length.
    pub body: Option<String>,
    /// Determines if the message content can be stored or redacted based on privacy settings
    pub content_retention: Option<String>,
    /// Reserved
    pub force_delivery: Option<bool>,
    /// A Twilio phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, an [alphanumeric sender ID](https://www.twilio.com/docs/sms/send-messages#use-an-alphanumeric-sender-id), or a [Channel Endpoint address](https://www.twilio.com/docs/sms/channels#channel-addresses) that is enabled for the type of message you want to send. Phone numbers or [short codes](https://www.twilio.com/docs/sms/api/short-code) purchased from Twilio also work here. You cannot, for example, spoof messages from a private cell phone number. If you are using `messaging_service_sid`, this parameter must be empty.
    pub from: Option<String>,
    /// The maximum total price in US dollars that you will pay for the message to be delivered. Can be a decimal value that has up to 4 decimal places. All messages are queued for delivery and the message cost is checked before the message is sent. If the cost exceeds `max_price`, the message will fail and a status of `Failed` is sent to the status callback. If `MaxPrice` is not set, the message cost is not checked.
    pub max_price: Option<f32>,
    /// The URL of the media to send with the message. The media can be of type `gif`, `png`, and `jpeg` and will be formatted correctly on the recipient's device. The media size limit is 5MB for supported file types (JPEG, PNG, GIF) and 500KB for [other types](https://www.twilio.com/docs/sms/accepted-mime-types) of accepted media. To send more than one image in the message body, provide multiple `media_url` parameters in the POST request. You can include up to 10 `media_url` parameters per message. You can send images in an SMS message in only the US and Canada.
    pub media_url: Option<Vec<String>>,
    /// The SID of the [Messaging Service](https://www.twilio.com/docs/sms/services#send-a-message-with-copilot) you want to associate with the Message. Set this parameter to use the [Messaging Service Settings and Copilot Features](https://www.twilio.com/console/sms/services) you have configured and leave the `from` parameter empty. When only this parameter is set, Twilio will use your enabled Copilot Features to select the `from` phone number for delivery.
    pub messaging_service_sid: Option<String>,
    /// Rich actions for Channels Messages.
    pub persistent_action: Option<Vec<String>>,
    /// Whether to confirm delivery of the message. Set this value to `true` if you are sending messages that have a trackable user action and you intend to confirm delivery of the message using the [Message Feedback API](https://www.twilio.com/docs/sms/api/message-feedback-resource). This parameter is `false` by default.
    pub provide_feedback: Option<bool>,
    /// Whether to detect Unicode characters that have a similar GSM-7 character and replace them. Can be: `true` or `false`.
    pub smart_encoded: Option<bool>,
    /// The URL we should call using the `status_callback_method` to send status information to your application. If specified, we POST these message status changes to the URL: `queued`, `failed`, `sent`, `delivered`, or `undelivered`. Twilio will POST its [standard request parameters](https://www.twilio.com/docs/sms/twiml#request-parameters) as well as some additional parameters including `MessageSid`, `MessageStatus`, and `ErrorCode`. If you include this parameter with the `messaging_service_sid`, we use this URL instead of the Status Callback URL of the [Messaging Service](https://www.twilio.com/docs/sms/services/api). URLs must contain a valid hostname and underscores are not allowed.
    pub status_callback: Option<String>,
    /// How long in seconds the message can remain in our outgoing message queue. After this period elapses, the message fails and we call your status callback. Can be between 1 and the default value of 14,400 seconds. After a message has been accepted by a carrier, however, we cannot guarantee that the message will not be queued after this period. We recommend that this value be at least 5 seconds.
    pub validity_period: Option<i32>
}

/// struct for passing parameters to the method `create_message_feedback`
#[derive(Clone, Debug, Default)]
pub struct CreateMessageFeedbackParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the Message resource for which the feedback was provided.
    pub message_sid: String,
    /// Whether the feedback has arrived. Can be: `unconfirmed` or `confirmed`. If `provide_feedback`=`true` in [the initial HTTP POST](https://www.twilio.com/docs/sms/api/message-resource#create-a-message-resource), the initial value of this property is `unconfirmed`. After the message arrives, update the value to `confirmed`.
    pub outcome: Option<String>
}

/// struct for passing parameters to the method `create_new_key`
#[derive(Clone, Debug, Default)]
pub struct CreateNewKeyParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will be responsible for the new Key resource.
    pub account_sid: String,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `create_new_signing_key`
#[derive(Clone, Debug, Default)]
pub struct CreateNewSigningKeyParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will be responsible for the new Key resource.
    pub account_sid: String,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `create_participant`
#[derive(Clone, Debug, Default)]
pub struct CreateParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the participant's conference.
    pub conference_sid: String,
    /// The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted `client:name`. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `from` must also be a phone number. If `to` is sip address, this value of `from` should be a username portion to be used to populate the P-Asserted-Identity header that is passed to the SIP endpoint.
    pub from: String,
    /// The phone number, SIP address, or Client identifier that received this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). SIP addresses are formatted as `sip:name@company.com`. Client identifiers are formatted `client:name`. [Custom parameters](https://www.twilio.com/docs/voice/api/conference-participant-resource#custom-parameters) may also be specified.
    pub to: String,
    /// Whether to play a notification beep to the conference when the participant joins. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
    pub beep: Option<String>,
    /// The SID of a BYOC (Bring Your Own Carrier) trunk to route this call with. Note that `byoc` is only meaningful when `to` is a phone number; it will otherwise be ignored. (Beta)
    pub byoc: Option<String>,
    /// The Reason for the outgoing call. Use it to specify the purpose of the call that is presented on the called party's phone. (Branded Calls Beta)
    pub call_reason: Option<String>,
    /// The SID of the participant who is being `coached`. The participant being coached is the only participant who can hear the participant who is `coaching`.
    pub call_sid_to_coach: Option<String>,
    /// The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted `client:name`. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `callerId` must also be a phone number. If `to` is sip address, this value of `callerId` should be a username portion to be used to populate the From header that is passed to the SIP endpoint.
    pub caller_id: Option<String>,
    /// Whether the participant is coaching another call. Can be: `true` or `false`. If not present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, `call_sid_to_coach` must be defined.
    pub coaching: Option<bool>,
    /// Whether to record the conference the participant is joining. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
    pub conference_record: Option<String>,
    /// The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
    pub conference_recording_status_callback: Option<String>,
    /// The conference recording state changes that generate a call to `conference_recording_status_callback`. Can be: `in-progress`, `completed`, `failed`, and `absent`. Separate multiple values with a space, ex: `'in-progress completed failed'`
    pub conference_recording_status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub conference_recording_status_callback_method: Option<String>,
    /// The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
    pub conference_status_callback: Option<String>,
    /// The conference state changes that should generate a call to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `modify`, `speaker`, and `announcement`. Separate multiple values with a space. Defaults to `start end`.
    pub conference_status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub conference_status_callback_method: Option<String>,
    /// Whether to trim leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
    pub conference_trim: Option<String>,
    /// Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. Can be: `true` or `false` and defaults to `true`.
    pub early_media: Option<bool>,
    /// Whether to end the conference when the participant leaves. Can be: `true` or `false` and defaults to `false`.
    pub end_conference_on_exit: Option<bool>,
    /// Jitter buffer size for the connecting participant. Twilio will use this setting to apply Jitter Buffer before participant's audio is mixed into the conference. Can be: `off`, `small`, `medium`, and `large`. Default to `large`.
    pub jitter_buffer_size: Option<String>,
    /// A label for this participant. If one is supplied, it may subsequently be used to fetch, update or delete the participant.
    pub label: Option<String>,
    /// The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
    pub max_participants: Option<i32>,
    /// Whether the agent is muted in the conference. Can be `true` or `false` and the default is `false`.
    pub muted: Option<bool>,
    /// Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.
    pub record: Option<bool>,
    /// The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
    pub recording_channels: Option<String>,
    /// The URL that we should call using the `recording_status_callback_method` when the recording status changes.
    pub recording_status_callback: Option<String>,
    /// The recording state changes that should generate a call to `recording_status_callback`. Can be: `started`, `in-progress`, `paused`, `resumed`, `stopped`, `completed`, `failed`, and `absent`. Separate multiple values with a space, ex: `'in-progress completed failed'`.
    pub recording_status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub recording_status_callback_method: Option<String>,
    /// The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The default is `both`. `inbound` records the audio that is received by Twilio. `outbound` records the audio that is sent from Twilio. `both` records the audio that is received and sent by Twilio.
    pub recording_track: Option<String>,
    /// The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
    pub region: Option<String>,
    /// The SIP password for authentication.
    pub sip_auth_password: Option<String>,
    /// The SIP username used for authentication.
    pub sip_auth_username: Option<String>,
    /// Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
    pub start_conference_on_enter: Option<bool>,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The conference state changes that should generate a call to `status_callback`. Can be: `initiated`, `ringing`, `answered`, and `completed`. Separate multiple values with a space. The default value is `completed`.
    pub status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` and `POST` and defaults to `POST`.
    pub status_callback_method: Option<String>,
    /// The maximum duration of the call in seconds. Constraints depend on account and configuration.
    pub time_limit: Option<i32>,
    /// The number of seconds that we should allow the phone to ring before assuming there is no answer. Can be an integer between `5` and `600`, inclusive. The default value is `60`. We always add a 5-second timeout buffer to outgoing calls, so  value of 10 would result in an actual timeout that was closer to 15 seconds.
    pub timeout: Option<i32>,
    /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
    pub wait_method: Option<String>,
    /// The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
    pub wait_url: Option<String>
}

/// struct for passing parameters to the method `create_payments`
#[derive(Clone, Debug, Default)]
pub struct CreatePaymentsParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the call that will create the resource. Call leg associated with this sid is expected to provide payment information thru DTMF.
    pub call_sid: String,
    /// A unique token that will be used to ensure that multiple API calls with the same information do not result in multiple transactions. This should be a unique string value per API call and can be a randomly generated.
    pub idempotency_key: String,
    /// Provide an absolute or relative URL to receive status updates regarding your Pay session. Read more about the [expected StatusCallback values](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback)
    pub status_callback: String,
    /// Type of bank account if payment source is ACH. One of `consumer-checking`, `consumer-savings`, or `commercial-checking`. The default value is `consumer-checking`.
    pub bank_account_type: Option<String>,
    /// A positive decimal value less than 1,000,000 to charge against the credit card or bank account. Default currency can be overwritten with `currency` field. Leave blank or set to 0 to tokenize.
    pub charge_amount: Option<f32>,
    /// The currency of the `charge_amount`, formatted as [ISO 4127](http://www.iso.org/iso/home/standards/currency_codes.htm) format. The default value is `USD` and all values allowed from the <Pay> Connector are accepted.
    pub currency: Option<String>,
    /// The description can be used to provide more details regarding the transaction. This information is submitted along with the payment details to the Payment Connector which are then posted on the transactions.
    pub description: Option<String>,
    /// A list of inputs that should be accepted. Currently only `dtmf` is supported. All digits captured during a pay session are redacted from the logs.
    pub input: Option<String>,
    /// A positive integer that is used to validate the length of the `PostalCode` inputted by the user. User must enter this many digits.
    pub min_postal_code_length: Option<i32>,
    /// A single level JSON string that is required when accepting certain information specific only to ACH payments. The information that has to be included here depends on the <Pay> Connector. [Read more](https://www.twilio.com/console/voice/pay-connectors).
    pub parameter: Option<serde_json::Value>,
    /// This is the unique name corresponding to the Payment Gateway Connector installed in the Twilio Add-ons. Learn more about [<Pay> Connectors](https://www.twilio.com/console/voice/pay-connectors). The default value is `Default`.
    pub payment_connector: Option<String>,
    /// Type of payment being captured. One of `credit-card` or `ach-debit`. The default value is `credit-card`.
    pub payment_method: Option<String>,
    /// Indicates whether the credit card postal code (zip code) is a required piece of payment information that must be provided by the caller. The default is `true`.
    pub postal_code: Option<bool>,
    /// Indicates whether the credit card security code is a required piece of payment information that must be provided by the caller. The default is `true`.
    pub security_code: Option<bool>,
    /// The number of seconds that <Pay> should wait for the caller to press a digit between each subsequent digit, after the first one, before moving on to validate the digits captured. The default is `5`, maximum is `600`.
    pub timeout: Option<i32>,
    /// Indicates whether the payment method should be tokenized as a `one-time` or `reusable` token. The default value is `reusable`. Do not enter a charge amount when tokenizing. If a charge amount is entered, the payment method will be charged and not tokenized.
    pub token_type: Option<String>,
    /// Credit card types separated by space that Pay should accept. The default value is `visa mastercard amex`
    pub valid_card_types: Option<String>
}

/// struct for passing parameters to the method `create_queue`
#[derive(Clone, Debug, Default)]
pub struct CreateQueueParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// A descriptive string that you created to describe this resource. It can be up to 64 characters long.
    pub friendly_name: String,
    /// The maximum number of calls allowed to be in the queue. The default is 100. The maximum is 5000.
    pub max_size: Option<i32>
}

/// struct for passing parameters to the method `create_sip_auth_calls_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct CreateSipAuthCallsCredentialListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the SIP domain that will contain the new resource.
    pub domain_sid: String,
    /// The SID of the CredentialList resource to map to the SIP domain.
    pub credential_list_sid: String
}

/// struct for passing parameters to the method `create_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct CreateSipAuthCallsIpAccessControlListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the SIP domain that will contain the new resource.
    pub domain_sid: String,
    /// The SID of the IpAccessControlList resource to map to the SIP domain.
    pub ip_access_control_list_sid: String
}

/// struct for passing parameters to the method `create_sip_auth_registrations_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct CreateSipAuthRegistrationsCredentialListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the SIP domain that will contain the new resource.
    pub domain_sid: String,
    /// The SID of the CredentialList resource to map to the SIP domain.
    pub credential_list_sid: String
}

/// struct for passing parameters to the method `create_sip_credential`
#[derive(Clone, Debug, Default)]
pub struct CreateSipCredentialParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The unique id that identifies the credential list to include the created credential.
    pub credential_list_sid: String,
    /// The password that the username will use when authenticating SIP requests. The password must be a minimum of 12 characters, contain at least 1 digit, and have mixed case. (eg `IWasAtSignal2018`)
    pub password: String,
    /// The username that will be passed when authenticating SIP requests. The username should be sent in response to Twilio's challenge of the initial INVITE. It can be up to 32 characters long.
    pub username: String
}

/// struct for passing parameters to the method `create_sip_credential_list`
#[derive(Clone, Debug, Default)]
pub struct CreateSipCredentialListParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// A human readable descriptive text that describes the CredentialList, up to 64 characters long.
    pub friendly_name: String
}

/// struct for passing parameters to the method `create_sip_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct CreateSipCredentialListMappingParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the SIP Domain for which the CredentialList resource will be mapped.
    pub domain_sid: String,
    /// A 34 character string that uniquely identifies the CredentialList resource to map to the SIP domain.
    pub credential_list_sid: String
}

/// struct for passing parameters to the method `create_sip_domain`
#[derive(Clone, Debug, Default)]
pub struct CreateSipDomainParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The unique address you reserve on Twilio to which you route your SIP traffic. Domain names can contain letters, digits, and \\\"-\\\" and must end with `sip.twilio.com`.
    pub domain_name: String,
    /// The SID of the BYOC Trunk(Bring Your Own Carrier) resource that the Sip Domain will be associated with.
    pub byoc_trunk_sid: Option<String>,
    /// Whether an emergency caller sid is configured for the domain. If present, this phone number will be used as the callback for the emergency call.
    pub emergency_caller_sid: Option<String>,
    /// Whether emergency calling is enabled for the domain. If enabled, allows emergency calls on the domain from phone numbers with validated addresses.
    pub emergency_calling_enabled: Option<bool>,
    /// A descriptive string that you created to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// Whether secure SIP is enabled for the domain. If enabled, TLS will be enforced and SRTP will be negotiated on all incoming calls to this sip domain.
    pub secure: Option<bool>,
    /// Whether to allow SIP Endpoints to register with the domain to receive calls. Can be `true` or `false`. `true` allows SIP Endpoints to register with the domain to receive calls, `false` does not.
    pub sip_registration: Option<bool>,
    /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while retrieving or executing the TwiML from `voice_url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`.
    pub voice_method: Option<String>,
    /// The HTTP method we should use to call `voice_status_callback_url`. Can be: `GET` or `POST`.
    pub voice_status_callback_method: Option<String>,
    /// The URL that we should call to pass status parameters (such as call ended) to your application.
    pub voice_status_callback_url: Option<String>,
    /// The URL we should when the domain receives a call.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `create_sip_ip_access_control_list`
#[derive(Clone, Debug, Default)]
pub struct CreateSipIpAccessControlListParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// A human readable descriptive text that describes the IpAccessControlList, up to 64 characters long.
    pub friendly_name: String
}

/// struct for passing parameters to the method `create_sip_ip_access_control_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct CreateSipIpAccessControlListMappingParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the SIP domain.
    pub domain_sid: String,
    /// The unique id of the IP access control list to map to the SIP domain.
    pub ip_access_control_list_sid: String
}

/// struct for passing parameters to the method `create_sip_ip_address`
#[derive(Clone, Debug, Default)]
pub struct CreateSipIpAddressParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// The IpAccessControlList Sid with which to associate the created IpAddress resource.
    pub ip_access_control_list_sid: String,
    /// A human readable descriptive text for this resource, up to 64 characters long.
    pub friendly_name: String,
    /// An IP address in dotted decimal notation from which you want to accept traffic. Any SIP requests from this IP address will be allowed by Twilio. IPv4 only supported today.
    pub ip_address: String,
    /// An integer representing the length of the CIDR prefix to use with this IP address when accepting traffic. By default the entire IP address is used.
    pub cidr_prefix_length: Option<i32>
}

/// struct for passing parameters to the method `create_token`
#[derive(Clone, Debug, Default)]
pub struct CreateTokenParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The duration in seconds for which the generated credentials are valid. The default value is 86400 (24 hours).
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method `create_usage_trigger`
#[derive(Clone, Debug, Default)]
pub struct CreateUsageTriggerParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The URL we should call using `callback_method` when the trigger fires.
    pub callback_url: String,
    /// The usage value at which the trigger should fire.  For convenience, you can use an offset value such as `+30` to specify a trigger_value that is 30 units more than the current usage value. Be sure to urlencode a `+` as `%2B`.
    pub trigger_value: String,
    /// The usage category that the trigger should watch.  Use one of the supported [usage categories](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) for this value.
    pub usage_category: String,
    /// The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the default is `POST`.
    pub callback_method: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The frequency of a recurring UsageTrigger.  Can be: `daily`, `monthly`, or `yearly` for recurring triggers or empty for non-recurring triggers. A trigger will only fire once during each period. Recurring times are in GMT.
    pub recurring: Option<String>,
    /// The field in the [UsageRecord](https://www.twilio.com/docs/usage/api/usage-record) resource that should fire the trigger.  Can be: `count`, `usage`, or `price` as described in the [UsageRecords documentation](https://www.twilio.com/docs/usage/api/usage-record#usage-count-price).  The default is `usage`.
    pub trigger_by: Option<String>
}

/// struct for passing parameters to the method `create_validation_request`
#[derive(Clone, Debug, Default)]
pub struct CreateValidationRequestParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for the new caller ID resource.
    pub account_sid: String,
    /// The phone number to verify in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, which consists of a + followed by the country code and subscriber number.
    pub phone_number: String,
    /// The number of seconds to delay before initiating the verification call. Can be an integer between `0` and `60`, inclusive. The default is `0`.
    pub call_delay: Option<i32>,
    /// The digits to dial after connecting the verification call.
    pub extension: Option<String>,
    /// A descriptive string that you create to describe the new caller ID resource. It can be up to 64 characters long. The default value is a formatted version of the phone number.
    pub friendly_name: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information about the verification process to your application.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`, and the default is `POST`.
    pub status_callback_method: Option<String>
}

/// struct for passing parameters to the method `delete_address`
#[derive(Clone, Debug, Default)]
pub struct DeleteAddressParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Address resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_application`
#[derive(Clone, Debug, Default)]
pub struct DeleteApplicationParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Application resources to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Application resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_call`
#[derive(Clone, Debug, Default)]
pub struct DeleteCallParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call resource(s) to delete.
    pub account_sid: String,
    /// The Twilio-provided Call SID that uniquely identifies the Call resource to delete
    pub sid: String
}

/// struct for passing parameters to the method `delete_call_feedback_summary`
#[derive(Clone, Debug, Default)]
pub struct DeleteCallFeedbackSummaryParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method `delete_call_recording`
#[derive(Clone, Debug, Default)]
pub struct DeleteCallRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resources to delete.
    pub account_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resources to delete.
    pub call_sid: String,
    /// The Twilio-provided string that uniquely identifies the Recording resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_conference_recording`
#[derive(Clone, Debug, Default)]
pub struct DeleteConferenceRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference Recording resources to delete.
    pub account_sid: String,
    /// The Conference SID that identifies the conference associated with the recording to delete.
    pub conference_sid: String,
    /// The Twilio-provided string that uniquely identifies the Conference Recording resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_connect_app`
#[derive(Clone, Debug, Default)]
pub struct DeleteConnectAppParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ConnectApp resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the ConnectApp resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `delete_incoming_phone_number`
#[derive(Clone, Debug, Default)]
pub struct DeleteIncomingPhoneNumberParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resources to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the IncomingPhoneNumber resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_incoming_phone_number_assigned_add_on`
#[derive(Clone, Debug, Default)]
pub struct DeleteIncomingPhoneNumberAssignedAddOnParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to delete.
    pub account_sid: String,
    /// The SID of the Phone Number to which the Add-on is assigned.
    pub resource_sid: String,
    /// The Twilio-provided string that uniquely identifies the resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_key`
#[derive(Clone, Debug, Default)]
pub struct DeleteKeyParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Key resources to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Key resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_media`
#[derive(Clone, Debug, Default)]
pub struct DeleteMediaParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Media resource(s) to delete.
    pub account_sid: String,
    /// The SID of the Message resource that this Media resource belongs to.
    pub message_sid: String,
    /// The Twilio-provided string that uniquely identifies the Media resource to delete
    pub sid: String
}

/// struct for passing parameters to the method `delete_message`
#[derive(Clone, Debug, Default)]
pub struct DeleteMessageParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Message resources to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Message resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_outgoing_caller_id`
#[derive(Clone, Debug, Default)]
pub struct DeleteOutgoingCallerIdParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the OutgoingCallerId resources to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the OutgoingCallerId resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_participant`
#[derive(Clone, Debug, Default)]
pub struct DeleteParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to delete.
    pub account_sid: String,
    /// The SID of the conference with the participants to delete.
    pub conference_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to delete. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
    pub call_sid: String
}

/// struct for passing parameters to the method `delete_queue`
#[derive(Clone, Debug, Default)]
pub struct DeleteQueueParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Queue resource to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Queue resource to delete
    pub sid: String
}

/// struct for passing parameters to the method `delete_recording`
#[derive(Clone, Debug, Default)]
pub struct DeleteRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resources to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Recording resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_recording_add_on_result`
#[derive(Clone, Debug, Default)]
pub struct DeleteRecordingAddOnResultParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult resources to delete.
    pub account_sid: String,
    /// The SID of the recording to which the result to delete belongs.
    pub reference_sid: String,
    /// The Twilio-provided string that uniquely identifies the Recording AddOnResult resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_recording_add_on_result_payload`
#[derive(Clone, Debug, Default)]
pub struct DeleteRecordingAddOnResultPayloadParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult Payload resources to delete.
    pub account_sid: String,
    /// The SID of the recording to which the AddOnResult resource that contains the payloads to delete belongs.
    pub reference_sid: String,
    /// The SID of the AddOnResult to which the payloads to delete belongs.
    pub add_on_result_sid: String,
    /// The Twilio-provided string that uniquely identifies the Recording AddOnResult Payload resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_recording_transcription`
#[derive(Clone, Debug, Default)]
pub struct DeleteRecordingTranscriptionParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resources to delete.
    pub account_sid: String,
    /// The SID of the [Recording](https://www.twilio.com/docs/voice/api/recording) that created the transcription to delete.
    pub recording_sid: String,
    /// The Twilio-provided string that uniquely identifies the Transcription resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_signing_key`
#[derive(Clone, Debug, Default)]
pub struct DeleteSigningKeyParams {
    pub account_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `delete_sip_auth_calls_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct DeleteSipAuthCallsCredentialListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resources to delete.
    pub account_sid: String,
    /// The SID of the SIP domain that contains the resource to delete.
    pub domain_sid: String,
    /// The Twilio-provided string that uniquely identifies the CredentialListMapping resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct DeleteSipAuthCallsIpAccessControlListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IpAccessControlListMapping resources to delete.
    pub account_sid: String,
    /// The SID of the SIP domain that contains the resources to delete.
    pub domain_sid: String,
    /// The Twilio-provided string that uniquely identifies the IpAccessControlListMapping resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sip_auth_registrations_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct DeleteSipAuthRegistrationsCredentialListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resources to delete.
    pub account_sid: String,
    /// The SID of the SIP domain that contains the resources to delete.
    pub domain_sid: String,
    /// The Twilio-provided string that uniquely identifies the CredentialListMapping resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sip_credential`
#[derive(Clone, Debug, Default)]
pub struct DeleteSipCredentialParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The unique id that identifies the credential list that contains the desired credentials.
    pub credential_list_sid: String,
    /// The unique id that identifies the resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sip_credential_list`
#[derive(Clone, Debug, Default)]
pub struct DeleteSipCredentialListParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The credential list Sid that uniquely identifies this resource
    pub sid: String
}

/// struct for passing parameters to the method `delete_sip_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct DeleteSipCredentialListMappingParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the SIP Domain that includes the resource to delete.
    pub domain_sid: String,
    /// A 34 character string that uniquely identifies the resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sip_domain`
#[derive(Clone, Debug, Default)]
pub struct DeleteSipDomainParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the SipDomain resources to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the SipDomain resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sip_ip_access_control_list`
#[derive(Clone, Debug, Default)]
pub struct DeleteSipIpAccessControlListParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sip_ip_access_control_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct DeleteSipIpAccessControlListMappingParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the SIP domain.
    pub domain_sid: String,
    /// A 34 character string that uniquely identifies the resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sip_ip_address`
#[derive(Clone, Debug, Default)]
pub struct DeleteSipIpAddressParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// The IpAccessControlList Sid that identifies the IpAddress resources to delete.
    pub ip_access_control_list_sid: String,
    /// A 34 character string that uniquely identifies the resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_transcription`
#[derive(Clone, Debug, Default)]
pub struct DeleteTranscriptionParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resources to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Transcription resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_usage_trigger`
#[derive(Clone, Debug, Default)]
pub struct DeleteUsageTriggerParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageTrigger resources to delete.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the UsageTrigger resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_account`
#[derive(Clone, Debug, Default)]
pub struct FetchAccountParams {
    /// The Account Sid that uniquely identifies the account to fetch
    pub sid: String
}

/// struct for passing parameters to the method `fetch_address`
#[derive(Clone, Debug, Default)]
pub struct FetchAddressParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Address resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_application`
#[derive(Clone, Debug, Default)]
pub struct FetchApplicationParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Application resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Application resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_authorized_connect_app`
#[derive(Clone, Debug, Default)]
pub struct FetchAuthorizedConnectAppParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the AuthorizedConnectApp resource to fetch.
    pub account_sid: String,
    /// The SID of the Connect App to fetch.
    pub connect_app_sid: String
}

/// struct for passing parameters to the method `fetch_available_phone_number_country`
#[derive(Clone, Debug, Default)]
pub struct FetchAvailablePhoneNumberCountryParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the available phone number Country resource.
    pub account_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country to fetch available phone number information about.
    pub country_code: String
}

/// struct for passing parameters to the method `fetch_balance`
#[derive(Clone, Debug, Default)]
pub struct FetchBalanceParams {
    /// The unique SID identifier of the Account.
    pub account_sid: String
}

/// struct for passing parameters to the method `fetch_call`
#[derive(Clone, Debug, Default)]
pub struct FetchCallParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call resource(s) to fetch.
    pub account_sid: String,
    /// The SID of the Call resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_call_feedback`
#[derive(Clone, Debug, Default)]
pub struct FetchCallFeedbackParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// The call sid that uniquely identifies the call
    pub call_sid: String
}

/// struct for passing parameters to the method `fetch_call_feedback_summary`
#[derive(Clone, Debug, Default)]
pub struct FetchCallFeedbackSummaryParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_call_notification`
#[derive(Clone, Debug, Default)]
pub struct FetchCallNotificationParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call Notification resource to fetch.
    pub account_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the Call Notification resource to fetch.
    pub call_sid: String,
    /// The Twilio-provided string that uniquely identifies the Call Notification resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_call_recording`
#[derive(Clone, Debug, Default)]
pub struct FetchCallRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resource to fetch.
    pub account_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resource to fetch.
    pub call_sid: String,
    /// The Twilio-provided string that uniquely identifies the Recording resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_conference`
#[derive(Clone, Debug, Default)]
pub struct FetchConferenceParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference resource(s) to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Conference resource to fetch
    pub sid: String
}

/// struct for passing parameters to the method `fetch_conference_recording`
#[derive(Clone, Debug, Default)]
pub struct FetchConferenceRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference Recording resource to fetch.
    pub account_sid: String,
    /// The Conference SID that identifies the conference associated with the recording to fetch.
    pub conference_sid: String,
    /// The Twilio-provided string that uniquely identifies the Conference Recording resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_connect_app`
#[derive(Clone, Debug, Default)]
pub struct FetchConnectAppParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ConnectApp resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the ConnectApp resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_incoming_phone_number`
#[derive(Clone, Debug, Default)]
pub struct FetchIncomingPhoneNumberParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the IncomingPhoneNumber resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_incoming_phone_number_assigned_add_on`
#[derive(Clone, Debug, Default)]
pub struct FetchIncomingPhoneNumberAssignedAddOnParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resource to fetch.
    pub account_sid: String,
    /// The SID of the Phone Number to which the Add-on is assigned.
    pub resource_sid: String,
    /// The Twilio-provided string that uniquely identifies the resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_incoming_phone_number_assigned_add_on_extension`
#[derive(Clone, Debug, Default)]
pub struct FetchIncomingPhoneNumberAssignedAddOnExtensionParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resource to fetch.
    pub account_sid: String,
    /// The SID of the Phone Number to which the Add-on is assigned.
    pub resource_sid: String,
    /// The SID that uniquely identifies the assigned Add-on installation.
    pub assigned_add_on_sid: String,
    /// The Twilio-provided string that uniquely identifies the resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_key`
#[derive(Clone, Debug, Default)]
pub struct FetchKeyParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Key resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Key resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_media`
#[derive(Clone, Debug, Default)]
pub struct FetchMediaParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Media resource(s) to fetch.
    pub account_sid: String,
    /// The SID of the Message resource that this Media resource belongs to.
    pub message_sid: String,
    /// The Twilio-provided string that uniquely identifies the Media resource to fetch
    pub sid: String
}

/// struct for passing parameters to the method `fetch_member`
#[derive(Clone, Debug, Default)]
pub struct FetchMemberParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Member resource(s) to fetch.
    pub account_sid: String,
    /// The SID of the Queue in which to find the members to fetch.
    pub queue_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resource(s) to fetch.
    pub call_sid: String
}

/// struct for passing parameters to the method `fetch_message`
#[derive(Clone, Debug, Default)]
pub struct FetchMessageParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Message resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Message resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_notification`
#[derive(Clone, Debug, Default)]
pub struct FetchNotificationParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Notification resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Notification resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_outgoing_caller_id`
#[derive(Clone, Debug, Default)]
pub struct FetchOutgoingCallerIdParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the OutgoingCallerId resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the OutgoingCallerId resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_participant`
#[derive(Clone, Debug, Default)]
pub struct FetchParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resource to fetch.
    pub account_sid: String,
    /// The SID of the conference with the participant to fetch.
    pub conference_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to fetch. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
    pub call_sid: String
}

/// struct for passing parameters to the method `fetch_queue`
#[derive(Clone, Debug, Default)]
pub struct FetchQueueParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Queue resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Queue resource to fetch
    pub sid: String
}

/// struct for passing parameters to the method `fetch_recording`
#[derive(Clone, Debug, Default)]
pub struct FetchRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Recording resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_recording_add_on_result`
#[derive(Clone, Debug, Default)]
pub struct FetchRecordingAddOnResultParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult resource to fetch.
    pub account_sid: String,
    /// The SID of the recording to which the result to fetch belongs.
    pub reference_sid: String,
    /// The Twilio-provided string that uniquely identifies the Recording AddOnResult resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_recording_add_on_result_payload`
#[derive(Clone, Debug, Default)]
pub struct FetchRecordingAddOnResultPayloadParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult Payload resource to fetch.
    pub account_sid: String,
    /// The SID of the recording to which the AddOnResult resource that contains the payload to fetch belongs.
    pub reference_sid: String,
    /// The SID of the AddOnResult to which the payload to fetch belongs.
    pub add_on_result_sid: String,
    /// The Twilio-provided string that uniquely identifies the Recording AddOnResult Payload resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_recording_transcription`
#[derive(Clone, Debug, Default)]
pub struct FetchRecordingTranscriptionParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resource to fetch.
    pub account_sid: String,
    /// The SID of the [Recording](https://www.twilio.com/docs/voice/api/recording) that created the transcription to fetch.
    pub recording_sid: String,
    /// The Twilio-provided string that uniquely identifies the Transcription resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_short_code`
#[derive(Clone, Debug, Default)]
pub struct FetchShortCodeParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ShortCode resource(s) to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the ShortCode resource to fetch
    pub sid: String
}

/// struct for passing parameters to the method `fetch_signing_key`
#[derive(Clone, Debug, Default)]
pub struct FetchSigningKeyParams {
    pub account_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sip_auth_calls_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct FetchSipAuthCallsCredentialListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resource to fetch.
    pub account_sid: String,
    /// The SID of the SIP domain that contains the resource to fetch.
    pub domain_sid: String,
    /// The Twilio-provided string that uniquely identifies the CredentialListMapping resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct FetchSipAuthCallsIpAccessControlListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IpAccessControlListMapping resource to fetch.
    pub account_sid: String,
    /// The SID of the SIP domain that contains the resource to fetch.
    pub domain_sid: String,
    /// The Twilio-provided string that uniquely identifies the IpAccessControlListMapping resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sip_auth_registrations_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct FetchSipAuthRegistrationsCredentialListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resource to fetch.
    pub account_sid: String,
    /// The SID of the SIP domain that contains the resource to fetch.
    pub domain_sid: String,
    /// The Twilio-provided string that uniquely identifies the CredentialListMapping resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sip_credential`
#[derive(Clone, Debug, Default)]
pub struct FetchSipCredentialParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The unique id that identifies the credential list that contains the desired credential.
    pub credential_list_sid: String,
    /// The unique id that identifies the resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sip_credential_list`
#[derive(Clone, Debug, Default)]
pub struct FetchSipCredentialListParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The credential list Sid that uniquely identifies this resource
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sip_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct FetchSipCredentialListMappingParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the SIP Domain that includes the resource to fetch.
    pub domain_sid: String,
    /// A 34 character string that uniquely identifies the resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sip_domain`
#[derive(Clone, Debug, Default)]
pub struct FetchSipDomainParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the SipDomain resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the SipDomain resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sip_ip_access_control_list`
#[derive(Clone, Debug, Default)]
pub struct FetchSipIpAccessControlListParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sip_ip_access_control_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct FetchSipIpAccessControlListMappingParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the SIP domain.
    pub domain_sid: String,
    /// A 34 character string that uniquely identifies the resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sip_ip_address`
#[derive(Clone, Debug, Default)]
pub struct FetchSipIpAddressParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// The IpAccessControlList Sid that identifies the IpAddress resources to fetch.
    pub ip_access_control_list_sid: String,
    /// A 34 character string that uniquely identifies the IpAddress resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_transcription`
#[derive(Clone, Debug, Default)]
pub struct FetchTranscriptionParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Transcription resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_usage_trigger`
#[derive(Clone, Debug, Default)]
pub struct FetchUsageTriggerParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageTrigger resource to fetch.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the UsageTrigger resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `list_account`
#[derive(Clone, Debug, Default)]
pub struct ListAccountParams {
    /// Only return the Account resources with friendly names that exactly match this name.
    pub friendly_name: Option<String>,
    /// Only return Account resources with the given status. Can be `closed`, `suspended` or `active`.
    pub status: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_address`
#[derive(Clone, Debug, Default)]
pub struct ListAddressParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to read.
    pub account_sid: String,
    /// The `customer_name` of the Address resources to read.
    pub customer_name: Option<String>,
    /// The string that identifies the Address resources to read.
    pub friendly_name: Option<String>,
    /// The ISO country code of the Address resources to read.
    pub iso_country: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_application`
#[derive(Clone, Debug, Default)]
pub struct ListApplicationParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Application resources to read.
    pub account_sid: String,
    /// The string that identifies the Application resources to read.
    pub friendly_name: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_authorized_connect_app`
#[derive(Clone, Debug, Default)]
pub struct ListAuthorizedConnectAppParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the AuthorizedConnectApp resources to read.
    pub account_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_available_phone_number_country`
#[derive(Clone, Debug, Default)]
pub struct ListAvailablePhoneNumberCountryParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the available phone number Country resources.
    pub account_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_available_phone_number_local`
#[derive(Clone, Debug, Default)]
pub struct ListAvailablePhoneNumberLocalParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
    pub account_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
    pub country_code: String,
    /// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
    pub area_code: Option<i32>,
    /// The pattern on which to match phone numbers. Valid characters are `*`, `0-9`, `a-z`, and `A-Z`. The `*` character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumberlocal-resource?code-sample=code-find-phone-numbers-by-number-pattern) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumberlocal-resource?code-sample=code-find-phone-numbers-by-character-pattern). If specified, this value must have at least two characters.
    pub contains: Option<String>,
    /// Whether the phone numbers can receive text messages. Can be: `true` or `false`.
    pub sms_enabled: Option<bool>,
    /// Whether the phone numbers can receive MMS messages. Can be: `true` or `false`.
    pub mms_enabled: Option<bool>,
    /// Whether the phone numbers can receive calls. Can be: `true` or `false`.
    pub voice_enabled: Option<bool>,
    /// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_all_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_local_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_foreign_address_required: Option<bool>,
    /// Whether to read phone numbers that are new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// Given a phone number, find a geographically close number within `distance` miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
    pub near_number: Option<String>,
    /// Given a latitude/longitude pair `lat,long` find geographically close numbers within `distance` miles. Applies to only phone numbers in the US and Canada.
    pub near_lat_long: Option<String>,
    /// The search radius, in miles, for a `near_` query.  Can be up to `500` and the default is `25`. Applies to only phone numbers in the US and Canada.
    pub distance: Option<i32>,
    /// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
    pub in_postal_code: Option<String>,
    /// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
    pub in_region: Option<String>,
    /// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires `in_lata` to be set as well. Applies to only phone numbers in the US and Canada.
    pub in_rate_center: Option<String>,
    /// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
    pub in_lata: Option<String>,
    /// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
    pub in_locality: Option<String>,
    /// Whether the phone numbers can receive faxes. Can be: `true` or `false`.
    pub fax_enabled: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_available_phone_number_machine_to_machine`
#[derive(Clone, Debug, Default)]
pub struct ListAvailablePhoneNumberMachineToMachineParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
    pub account_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
    pub country_code: String,
    /// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
    pub area_code: Option<i32>,
    /// The pattern on which to match phone numbers. Valid characters are `*`, `0-9`, `a-z`, and `A-Z`. The `*` character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
    pub contains: Option<String>,
    /// Whether the phone numbers can receive text messages. Can be: `true` or `false`.
    pub sms_enabled: Option<bool>,
    /// Whether the phone numbers can receive MMS messages. Can be: `true` or `false`.
    pub mms_enabled: Option<bool>,
    /// Whether the phone numbers can receive calls. Can be: `true` or `false`.
    pub voice_enabled: Option<bool>,
    /// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_all_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_local_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_foreign_address_required: Option<bool>,
    /// Whether to read phone numbers that are new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// Given a phone number, find a geographically close number within `distance` miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
    pub near_number: Option<String>,
    /// Given a latitude/longitude pair `lat,long` find geographically close numbers within `distance` miles. Applies to only phone numbers in the US and Canada.
    pub near_lat_long: Option<String>,
    /// The search radius, in miles, for a `near_` query.  Can be up to `500` and the default is `25`. Applies to only phone numbers in the US and Canada.
    pub distance: Option<i32>,
    /// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
    pub in_postal_code: Option<String>,
    /// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
    pub in_region: Option<String>,
    /// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires `in_lata` to be set as well. Applies to only phone numbers in the US and Canada.
    pub in_rate_center: Option<String>,
    /// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
    pub in_lata: Option<String>,
    /// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
    pub in_locality: Option<String>,
    /// Whether the phone numbers can receive faxes. Can be: `true` or `false`.
    pub fax_enabled: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_available_phone_number_mobile`
#[derive(Clone, Debug, Default)]
pub struct ListAvailablePhoneNumberMobileParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
    pub account_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
    pub country_code: String,
    /// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
    pub area_code: Option<i32>,
    /// The pattern on which to match phone numbers. Valid characters are `*`, `0-9`, `a-z`, and `A-Z`. The `*` character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
    pub contains: Option<String>,
    /// Whether the phone numbers can receive text messages. Can be: `true` or `false`.
    pub sms_enabled: Option<bool>,
    /// Whether the phone numbers can receive MMS messages. Can be: `true` or `false`.
    pub mms_enabled: Option<bool>,
    /// Whether the phone numbers can receive calls. Can be: `true` or `false`.
    pub voice_enabled: Option<bool>,
    /// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_all_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_local_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_foreign_address_required: Option<bool>,
    /// Whether to read phone numbers that are new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// Given a phone number, find a geographically close number within `distance` miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
    pub near_number: Option<String>,
    /// Given a latitude/longitude pair `lat,long` find geographically close numbers within `distance` miles. Applies to only phone numbers in the US and Canada.
    pub near_lat_long: Option<String>,
    /// The search radius, in miles, for a `near_` query.  Can be up to `500` and the default is `25`. Applies to only phone numbers in the US and Canada.
    pub distance: Option<i32>,
    /// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
    pub in_postal_code: Option<String>,
    /// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
    pub in_region: Option<String>,
    /// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires `in_lata` to be set as well. Applies to only phone numbers in the US and Canada.
    pub in_rate_center: Option<String>,
    /// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
    pub in_lata: Option<String>,
    /// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
    pub in_locality: Option<String>,
    /// Whether the phone numbers can receive faxes. Can be: `true` or `false`.
    pub fax_enabled: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_available_phone_number_national`
#[derive(Clone, Debug, Default)]
pub struct ListAvailablePhoneNumberNationalParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
    pub account_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
    pub country_code: String,
    /// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
    pub area_code: Option<i32>,
    /// The pattern on which to match phone numbers. Valid characters are `*`, `0-9`, `a-z`, and `A-Z`. The `*` character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
    pub contains: Option<String>,
    /// Whether the phone numbers can receive text messages. Can be: `true` or `false`.
    pub sms_enabled: Option<bool>,
    /// Whether the phone numbers can receive MMS messages. Can be: `true` or `false`.
    pub mms_enabled: Option<bool>,
    /// Whether the phone numbers can receive calls. Can be: `true` or `false`.
    pub voice_enabled: Option<bool>,
    /// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_all_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_local_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_foreign_address_required: Option<bool>,
    /// Whether to read phone numbers that are new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// Given a phone number, find a geographically close number within `distance` miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
    pub near_number: Option<String>,
    /// Given a latitude/longitude pair `lat,long` find geographically close numbers within `distance` miles. Applies to only phone numbers in the US and Canada.
    pub near_lat_long: Option<String>,
    /// The search radius, in miles, for a `near_` query.  Can be up to `500` and the default is `25`. Applies to only phone numbers in the US and Canada.
    pub distance: Option<i32>,
    /// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
    pub in_postal_code: Option<String>,
    /// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
    pub in_region: Option<String>,
    /// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires `in_lata` to be set as well. Applies to only phone numbers in the US and Canada.
    pub in_rate_center: Option<String>,
    /// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
    pub in_lata: Option<String>,
    /// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
    pub in_locality: Option<String>,
    /// Whether the phone numbers can receive faxes. Can be: `true` or `false`.
    pub fax_enabled: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_available_phone_number_shared_cost`
#[derive(Clone, Debug, Default)]
pub struct ListAvailablePhoneNumberSharedCostParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
    pub account_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
    pub country_code: String,
    /// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
    pub area_code: Option<i32>,
    /// The pattern on which to match phone numbers. Valid characters are `*`, `0-9`, `a-z`, and `A-Z`. The `*` character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
    pub contains: Option<String>,
    /// Whether the phone numbers can receive text messages. Can be: `true` or `false`.
    pub sms_enabled: Option<bool>,
    /// Whether the phone numbers can receive MMS messages. Can be: `true` or `false`.
    pub mms_enabled: Option<bool>,
    /// Whether the phone numbers can receive calls. Can be: `true` or `false`.
    pub voice_enabled: Option<bool>,
    /// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_all_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_local_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_foreign_address_required: Option<bool>,
    /// Whether to read phone numbers that are new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// Given a phone number, find a geographically close number within `distance` miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
    pub near_number: Option<String>,
    /// Given a latitude/longitude pair `lat,long` find geographically close numbers within `distance` miles. Applies to only phone numbers in the US and Canada.
    pub near_lat_long: Option<String>,
    /// The search radius, in miles, for a `near_` query.  Can be up to `500` and the default is `25`. Applies to only phone numbers in the US and Canada.
    pub distance: Option<i32>,
    /// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
    pub in_postal_code: Option<String>,
    /// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
    pub in_region: Option<String>,
    /// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires `in_lata` to be set as well. Applies to only phone numbers in the US and Canada.
    pub in_rate_center: Option<String>,
    /// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
    pub in_lata: Option<String>,
    /// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
    pub in_locality: Option<String>,
    /// Whether the phone numbers can receive faxes. Can be: `true` or `false`.
    pub fax_enabled: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_available_phone_number_toll_free`
#[derive(Clone, Debug, Default)]
pub struct ListAvailablePhoneNumberTollFreeParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
    pub account_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
    pub country_code: String,
    /// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
    pub area_code: Option<i32>,
    /// The pattern on which to match phone numbers. Valid characters are `*`, `0-9`, `a-z`, and `A-Z`. The `*` character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
    pub contains: Option<String>,
    /// Whether the phone numbers can receive text messages. Can be: `true` or `false`.
    pub sms_enabled: Option<bool>,
    /// Whether the phone numbers can receive MMS messages. Can be: `true` or `false`.
    pub mms_enabled: Option<bool>,
    /// Whether the phone numbers can receive calls. Can be: `true` or `false`.
    pub voice_enabled: Option<bool>,
    /// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_all_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_local_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_foreign_address_required: Option<bool>,
    /// Whether to read phone numbers that are new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// Given a phone number, find a geographically close number within `distance` miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
    pub near_number: Option<String>,
    /// Given a latitude/longitude pair `lat,long` find geographically close numbers within `distance` miles. Applies to only phone numbers in the US and Canada.
    pub near_lat_long: Option<String>,
    /// The search radius, in miles, for a `near_` query.  Can be up to `500` and the default is `25`. Applies to only phone numbers in the US and Canada.
    pub distance: Option<i32>,
    /// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
    pub in_postal_code: Option<String>,
    /// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
    pub in_region: Option<String>,
    /// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires `in_lata` to be set as well. Applies to only phone numbers in the US and Canada.
    pub in_rate_center: Option<String>,
    /// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
    pub in_lata: Option<String>,
    /// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
    pub in_locality: Option<String>,
    /// Whether the phone numbers can receive faxes. Can be: `true` or `false`.
    pub fax_enabled: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_available_phone_number_voip`
#[derive(Clone, Debug, Default)]
pub struct ListAvailablePhoneNumberVoipParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) requesting the AvailablePhoneNumber resources.
    pub account_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country from which to read phone numbers.
    pub country_code: String,
    /// The area code of the phone numbers to read. Applies to only phone numbers in the US and Canada.
    pub area_code: Option<i32>,
    /// The pattern on which to match phone numbers. Valid characters are `*`, `0-9`, `a-z`, and `A-Z`. The `*` character matches any single digit. For examples, see [Example 2](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-2) and [Example 3](https://www.twilio.com/docs/phone-numbers/api/availablephonenumber-resource#local-get-basic-example-3). If specified, this value must have at least two characters.
    pub contains: Option<String>,
    /// Whether the phone numbers can receive text messages. Can be: `true` or `false`.
    pub sms_enabled: Option<bool>,
    /// Whether the phone numbers can receive MMS messages. Can be: `true` or `false`.
    pub mms_enabled: Option<bool>,
    /// Whether the phone numbers can receive calls. Can be: `true` or `false`.
    pub voice_enabled: Option<bool>,
    /// Whether to exclude phone numbers that require an [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_all_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a local [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_local_address_required: Option<bool>,
    /// Whether to exclude phone numbers that require a foreign [Address](https://www.twilio.com/docs/usage/api/address). Can be: `true` or `false` and the default is `false`.
    pub exclude_foreign_address_required: Option<bool>,
    /// Whether to read phone numbers that are new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// Given a phone number, find a geographically close number within `distance` miles. Distance defaults to 25 miles. Applies to only phone numbers in the US and Canada.
    pub near_number: Option<String>,
    /// Given a latitude/longitude pair `lat,long` find geographically close numbers within `distance` miles. Applies to only phone numbers in the US and Canada.
    pub near_lat_long: Option<String>,
    /// The search radius, in miles, for a `near_` query.  Can be up to `500` and the default is `25`. Applies to only phone numbers in the US and Canada.
    pub distance: Option<i32>,
    /// Limit results to a particular postal code. Given a phone number, search within the same postal code as that number. Applies to only phone numbers in the US and Canada.
    pub in_postal_code: Option<String>,
    /// Limit results to a particular region, state, or province. Given a phone number, search within the same region as that number. Applies to only phone numbers in the US and Canada.
    pub in_region: Option<String>,
    /// Limit results to a specific rate center, or given a phone number search within the same rate center as that number. Requires `in_lata` to be set as well. Applies to only phone numbers in the US and Canada.
    pub in_rate_center: Option<String>,
    /// Limit results to a specific local access and transport area ([LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area)). Given a phone number, search within the same [LATA](https://en.wikipedia.org/wiki/Local_access_and_transport_area) as that number. Applies to only phone numbers in the US and Canada.
    pub in_lata: Option<String>,
    /// Limit results to a particular locality or city. Given a phone number, search within the same Locality as that number.
    pub in_locality: Option<String>,
    /// Whether the phone numbers can receive faxes. Can be: `true` or `false`.
    pub fax_enabled: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_call`
#[derive(Clone, Debug, Default)]
pub struct ListCallParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call resource(s) to read.
    pub account_sid: String,
    /// Only show calls made to this phone number, SIP address, Client identifier or SIM SID.
    pub to: Option<String>,
    /// Only include calls from this phone number, SIP address, Client identifier or SIM SID.
    pub from: Option<String>,
    /// Only include calls spawned by calls with this SID.
    pub parent_call_sid: Option<String>,
    /// The status of the calls to include. Can be: `queued`, `ringing`, `in-progress`, `canceled`, `completed`, `failed`, `busy`, or `no-answer`.
    pub status: Option<String>,
    /// Only include calls that started on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read only calls that started on this date. You can also specify an inequality, such as `StartTime<=YYYY-MM-DD`, to read calls that started on or before midnight of this date, and `StartTime>=YYYY-MM-DD` to read calls that started on or after midnight of this date.
    pub start_time: Option<String>,
    /// Only include calls that started on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read only calls that started on this date. You can also specify an inequality, such as `StartTime<=YYYY-MM-DD`, to read calls that started on or before midnight of this date, and `StartTime>=YYYY-MM-DD` to read calls that started on or after midnight of this date.
    pub start_time2: Option<String>,
    /// Only include calls that started on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read only calls that started on this date. You can also specify an inequality, such as `StartTime<=YYYY-MM-DD`, to read calls that started on or before midnight of this date, and `StartTime>=YYYY-MM-DD` to read calls that started on or after midnight of this date.
    pub start_time3: Option<String>,
    /// Only include calls that ended on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read only calls that ended on this date. You can also specify an inequality, such as `EndTime<=YYYY-MM-DD`, to read calls that ended on or before midnight of this date, and `EndTime>=YYYY-MM-DD` to read calls that ended on or after midnight of this date.
    pub end_time: Option<String>,
    /// Only include calls that ended on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read only calls that ended on this date. You can also specify an inequality, such as `EndTime<=YYYY-MM-DD`, to read calls that ended on or before midnight of this date, and `EndTime>=YYYY-MM-DD` to read calls that ended on or after midnight of this date.
    pub end_time2: Option<String>,
    /// Only include calls that ended on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read only calls that ended on this date. You can also specify an inequality, such as `EndTime<=YYYY-MM-DD`, to read calls that ended on or before midnight of this date, and `EndTime>=YYYY-MM-DD` to read calls that ended on or after midnight of this date.
    pub end_time3: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_call_event`
#[derive(Clone, Debug, Default)]
pub struct ListCallEventParams {
    /// The unique SID identifier of the Account.
    pub account_sid: String,
    /// The unique SID identifier of the Call.
    pub call_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_call_notification`
#[derive(Clone, Debug, Default)]
pub struct ListCallNotificationParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call Notification resources to read.
    pub account_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the Call Notification resources to read.
    pub call_sid: String,
    /// Only read notifications of the specified log level. Can be:  `0` to read only ERROR notifications or `1` to read only WARNING notifications. By default, all notifications are read.
    pub log: Option<i32>,
    /// Only show notifications for the specified date, formatted as `YYYY-MM-DD`. You can also specify an inequality, such as `<=YYYY-MM-DD` for messages logged at or before midnight on a date, or `>=YYYY-MM-DD` for messages logged at or after midnight on a date.
    pub message_date: Option<String>,
    /// Only show notifications for the specified date, formatted as `YYYY-MM-DD`. You can also specify an inequality, such as `<=YYYY-MM-DD` for messages logged at or before midnight on a date, or `>=YYYY-MM-DD` for messages logged at or after midnight on a date.
    pub message_date2: Option<String>,
    /// Only show notifications for the specified date, formatted as `YYYY-MM-DD`. You can also specify an inequality, such as `<=YYYY-MM-DD` for messages logged at or before midnight on a date, or `>=YYYY-MM-DD` for messages logged at or after midnight on a date.
    pub message_date3: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_call_recording`
#[derive(Clone, Debug, Default)]
pub struct ListCallRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resources to read.
    pub account_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resources to read.
    pub call_sid: String,
    /// The `date_created` value, specified as `YYYY-MM-DD`, of the resources to read. You can also specify inequality: `DateCreated<=YYYY-MM-DD` will return recordings generated at or before midnight on a given date, and `DateCreated>=YYYY-MM-DD` returns recordings generated at or after midnight on a date.
    pub date_created: Option<String>,
    /// The `date_created` value, specified as `YYYY-MM-DD`, of the resources to read. You can also specify inequality: `DateCreated<=YYYY-MM-DD` will return recordings generated at or before midnight on a given date, and `DateCreated>=YYYY-MM-DD` returns recordings generated at or after midnight on a date.
    pub date_created2: Option<String>,
    /// The `date_created` value, specified as `YYYY-MM-DD`, of the resources to read. You can also specify inequality: `DateCreated<=YYYY-MM-DD` will return recordings generated at or before midnight on a given date, and `DateCreated>=YYYY-MM-DD` returns recordings generated at or after midnight on a date.
    pub date_created3: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_conference`
#[derive(Clone, Debug, Default)]
pub struct ListConferenceParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference resource(s) to read.
    pub account_sid: String,
    /// The `date_created` value, specified as `YYYY-MM-DD`, of the resources to read. To read conferences that started on or before midnight on a date, use `<=YYYY-MM-DD`, and to specify  conferences that started on or after midnight on a date, use `>=YYYY-MM-DD`.
    pub date_created: Option<String>,
    /// The `date_created` value, specified as `YYYY-MM-DD`, of the resources to read. To read conferences that started on or before midnight on a date, use `<=YYYY-MM-DD`, and to specify  conferences that started on or after midnight on a date, use `>=YYYY-MM-DD`.
    pub date_created2: Option<String>,
    /// The `date_created` value, specified as `YYYY-MM-DD`, of the resources to read. To read conferences that started on or before midnight on a date, use `<=YYYY-MM-DD`, and to specify  conferences that started on or after midnight on a date, use `>=YYYY-MM-DD`.
    pub date_created3: Option<String>,
    /// The `date_updated` value, specified as `YYYY-MM-DD`, of the resources to read. To read conferences that were last updated on or before midnight on a date, use `<=YYYY-MM-DD`, and to specify conferences that were last updated on or after midnight on a given date, use  `>=YYYY-MM-DD`.
    pub date_updated: Option<String>,
    /// The `date_updated` value, specified as `YYYY-MM-DD`, of the resources to read. To read conferences that were last updated on or before midnight on a date, use `<=YYYY-MM-DD`, and to specify conferences that were last updated on or after midnight on a given date, use  `>=YYYY-MM-DD`.
    pub date_updated2: Option<String>,
    /// The `date_updated` value, specified as `YYYY-MM-DD`, of the resources to read. To read conferences that were last updated on or before midnight on a date, use `<=YYYY-MM-DD`, and to specify conferences that were last updated on or after midnight on a given date, use  `>=YYYY-MM-DD`.
    pub date_updated3: Option<String>,
    /// The string that identifies the Conference resources to read.
    pub friendly_name: Option<String>,
    /// The status of the resources to read. Can be: `init`, `in-progress`, or `completed`.
    pub status: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_conference_recording`
#[derive(Clone, Debug, Default)]
pub struct ListConferenceRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference Recording resources to read.
    pub account_sid: String,
    /// The Conference SID that identifies the conference associated with the recording to read.
    pub conference_sid: String,
    /// The `date_created` value, specified as `YYYY-MM-DD`, of the resources to read. You can also specify inequality: `DateCreated<=YYYY-MM-DD` will return recordings generated at or before midnight on a given date, and `DateCreated>=YYYY-MM-DD` returns recordings generated at or after midnight on a date.
    pub date_created: Option<String>,
    /// The `date_created` value, specified as `YYYY-MM-DD`, of the resources to read. You can also specify inequality: `DateCreated<=YYYY-MM-DD` will return recordings generated at or before midnight on a given date, and `DateCreated>=YYYY-MM-DD` returns recordings generated at or after midnight on a date.
    pub date_created2: Option<String>,
    /// The `date_created` value, specified as `YYYY-MM-DD`, of the resources to read. You can also specify inequality: `DateCreated<=YYYY-MM-DD` will return recordings generated at or before midnight on a given date, and `DateCreated>=YYYY-MM-DD` returns recordings generated at or after midnight on a date.
    pub date_created3: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_connect_app`
#[derive(Clone, Debug, Default)]
pub struct ListConnectAppParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ConnectApp resources to read.
    pub account_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_dependent_phone_number`
#[derive(Clone, Debug, Default)]
pub struct ListDependentPhoneNumberParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the DependentPhoneNumber resources to read.
    pub account_sid: String,
    /// The SID of the Address resource associated with the phone number.
    pub address_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_incoming_phone_number`
#[derive(Clone, Debug, Default)]
pub struct ListIncomingPhoneNumberParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resources to read.
    pub account_sid: String,
    /// Whether to include phone numbers new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// A string that identifies the IncomingPhoneNumber resources to read.
    pub friendly_name: Option<String>,
    /// The phone numbers of the IncomingPhoneNumber resources to read. You can specify partial numbers and use '*' as a wildcard for any digit.
    pub phone_number: Option<String>,
    /// Whether to include phone numbers based on their origin. Can be: `twilio` or `hosted`. By default, phone numbers of all origin are included.
    pub origin: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_incoming_phone_number_assigned_add_on`
#[derive(Clone, Debug, Default)]
pub struct ListIncomingPhoneNumberAssignedAddOnParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to read.
    pub account_sid: String,
    /// The SID of the Phone Number to which the Add-on is assigned.
    pub resource_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_incoming_phone_number_assigned_add_on_extension`
#[derive(Clone, Debug, Default)]
pub struct ListIncomingPhoneNumberAssignedAddOnExtensionParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to read.
    pub account_sid: String,
    /// The SID of the Phone Number to which the Add-on is assigned.
    pub resource_sid: String,
    /// The SID that uniquely identifies the assigned Add-on installation.
    pub assigned_add_on_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_incoming_phone_number_local`
#[derive(Clone, Debug, Default)]
pub struct ListIncomingPhoneNumberLocalParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to read.
    pub account_sid: String,
    /// Whether to include phone numbers new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// A string that identifies the resources to read.
    pub friendly_name: Option<String>,
    /// The phone numbers of the IncomingPhoneNumber resources to read. You can specify partial numbers and use '*' as a wildcard for any digit.
    pub phone_number: Option<String>,
    /// Whether to include phone numbers based on their origin. Can be: `twilio` or `hosted`. By default, phone numbers of all origin are included.
    pub origin: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_incoming_phone_number_mobile`
#[derive(Clone, Debug, Default)]
pub struct ListIncomingPhoneNumberMobileParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to read.
    pub account_sid: String,
    /// Whether to include phone numbers new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// A string that identifies the resources to read.
    pub friendly_name: Option<String>,
    /// The phone numbers of the IncomingPhoneNumber resources to read. You can specify partial numbers and use '*' as a wildcard for any digit.
    pub phone_number: Option<String>,
    /// Whether to include phone numbers based on their origin. Can be: `twilio` or `hosted`. By default, phone numbers of all origin are included.
    pub origin: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_incoming_phone_number_toll_free`
#[derive(Clone, Debug, Default)]
pub struct ListIncomingPhoneNumberTollFreeParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the resources to read.
    pub account_sid: String,
    /// Whether to include phone numbers new to the Twilio platform. Can be: `true` or `false` and the default is `true`.
    pub beta: Option<bool>,
    /// A string that identifies the resources to read.
    pub friendly_name: Option<String>,
    /// The phone numbers of the IncomingPhoneNumber resources to read. You can specify partial numbers and use '*' as a wildcard for any digit.
    pub phone_number: Option<String>,
    /// Whether to include phone numbers based on their origin. Can be: `twilio` or `hosted`. By default, phone numbers of all origin are included.
    pub origin: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_key`
#[derive(Clone, Debug, Default)]
pub struct ListKeyParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Key resources to read.
    pub account_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_media`
#[derive(Clone, Debug, Default)]
pub struct ListMediaParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Media resource(s) to read.
    pub account_sid: String,
    /// The SID of the Message resource that this Media resource belongs to.
    pub message_sid: String,
    /// Only include media that was created on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read media that was created on this date. You can also specify an inequality, such as `StartTime<=YYYY-MM-DD`, to read media that was created on or before midnight of this date, and `StartTime>=YYYY-MM-DD` to read media that was created on or after midnight of this date.
    pub date_created: Option<String>,
    /// Only include media that was created on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read media that was created on this date. You can also specify an inequality, such as `StartTime<=YYYY-MM-DD`, to read media that was created on or before midnight of this date, and `StartTime>=YYYY-MM-DD` to read media that was created on or after midnight of this date.
    pub date_created2: Option<String>,
    /// Only include media that was created on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read media that was created on this date. You can also specify an inequality, such as `StartTime<=YYYY-MM-DD`, to read media that was created on or before midnight of this date, and `StartTime>=YYYY-MM-DD` to read media that was created on or after midnight of this date.
    pub date_created3: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_member`
#[derive(Clone, Debug, Default)]
pub struct ListMemberParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Member resource(s) to read.
    pub account_sid: String,
    /// The SID of the Queue in which to find the members
    pub queue_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_message`
#[derive(Clone, Debug, Default)]
pub struct ListMessageParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Message resources to read.
    pub account_sid: String,
    /// Read messages sent to only this phone number.
    pub to: Option<String>,
    /// Read messages sent from only this phone number or alphanumeric sender ID.
    pub from: Option<String>,
    /// The date of the messages to show. Specify a date as `YYYY-MM-DD` in GMT to read only messages sent on this date. For example: `2009-07-06`. You can also specify an inequality, such as `DateSent<=YYYY-MM-DD`, to read messages sent on or before midnight on a date, and `DateSent>=YYYY-MM-DD` to read messages sent on or after midnight on a date.
    pub date_sent: Option<String>,
    /// The date of the messages to show. Specify a date as `YYYY-MM-DD` in GMT to read only messages sent on this date. For example: `2009-07-06`. You can also specify an inequality, such as `DateSent<=YYYY-MM-DD`, to read messages sent on or before midnight on a date, and `DateSent>=YYYY-MM-DD` to read messages sent on or after midnight on a date.
    pub date_sent2: Option<String>,
    /// The date of the messages to show. Specify a date as `YYYY-MM-DD` in GMT to read only messages sent on this date. For example: `2009-07-06`. You can also specify an inequality, such as `DateSent<=YYYY-MM-DD`, to read messages sent on or before midnight on a date, and `DateSent>=YYYY-MM-DD` to read messages sent on or after midnight on a date.
    pub date_sent3: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_notification`
#[derive(Clone, Debug, Default)]
pub struct ListNotificationParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Notification resources to read.
    pub account_sid: String,
    /// Only read notifications of the specified log level. Can be:  `0` to read only ERROR notifications or `1` to read only WARNING notifications. By default, all notifications are read.
    pub log: Option<i32>,
    /// Only show notifications for the specified date, formatted as `YYYY-MM-DD`. You can also specify an inequality, such as `<=YYYY-MM-DD` for messages logged at or before midnight on a date, or `>=YYYY-MM-DD` for messages logged at or after midnight on a date.
    pub message_date: Option<String>,
    /// Only show notifications for the specified date, formatted as `YYYY-MM-DD`. You can also specify an inequality, such as `<=YYYY-MM-DD` for messages logged at or before midnight on a date, or `>=YYYY-MM-DD` for messages logged at or after midnight on a date.
    pub message_date2: Option<String>,
    /// Only show notifications for the specified date, formatted as `YYYY-MM-DD`. You can also specify an inequality, such as `<=YYYY-MM-DD` for messages logged at or before midnight on a date, or `>=YYYY-MM-DD` for messages logged at or after midnight on a date.
    pub message_date3: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_outgoing_caller_id`
#[derive(Clone, Debug, Default)]
pub struct ListOutgoingCallerIdParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the OutgoingCallerId resources to read.
    pub account_sid: String,
    /// The phone number of the OutgoingCallerId resources to read.
    pub phone_number: Option<String>,
    /// The string that identifies the OutgoingCallerId resources to read.
    pub friendly_name: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_participant`
#[derive(Clone, Debug, Default)]
pub struct ListParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to read.
    pub account_sid: String,
    /// The SID of the conference with the participants to read.
    pub conference_sid: String,
    /// Whether to return only participants that are muted. Can be: `true` or `false`.
    pub muted: Option<bool>,
    /// Whether to return only participants that are on hold. Can be: `true` or `false`.
    pub hold: Option<bool>,
    /// Whether to return only participants who are coaching another call. Can be: `true` or `false`.
    pub coaching: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_queue`
#[derive(Clone, Debug, Default)]
pub struct ListQueueParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Queue resources to read.
    pub account_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_recording`
#[derive(Clone, Debug, Default)]
pub struct ListRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resources to read.
    pub account_sid: String,
    /// Only include recordings that were created on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read recordings that were created on this date. You can also specify an inequality, such as `DateCreated<=YYYY-MM-DD`, to read recordings that were created on or before midnight of this date, and `DateCreated>=YYYY-MM-DD` to read recordings that were created on or after midnight of this date.
    pub date_created: Option<String>,
    /// Only include recordings that were created on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read recordings that were created on this date. You can also specify an inequality, such as `DateCreated<=YYYY-MM-DD`, to read recordings that were created on or before midnight of this date, and `DateCreated>=YYYY-MM-DD` to read recordings that were created on or after midnight of this date.
    pub date_created2: Option<String>,
    /// Only include recordings that were created on this date. Specify a date as `YYYY-MM-DD` in GMT, for example: `2009-07-06`, to read recordings that were created on this date. You can also specify an inequality, such as `DateCreated<=YYYY-MM-DD`, to read recordings that were created on or before midnight of this date, and `DateCreated>=YYYY-MM-DD` to read recordings that were created on or after midnight of this date.
    pub date_created3: Option<String>,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resources to read.
    pub call_sid: Option<String>,
    /// The Conference SID that identifies the conference associated with the recording to read.
    pub conference_sid: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_recording_add_on_result`
#[derive(Clone, Debug, Default)]
pub struct ListRecordingAddOnResultParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult resources to read.
    pub account_sid: String,
    /// The SID of the recording to which the result to read belongs.
    pub reference_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_recording_add_on_result_payload`
#[derive(Clone, Debug, Default)]
pub struct ListRecordingAddOnResultPayloadParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording AddOnResult Payload resources to read.
    pub account_sid: String,
    /// The SID of the recording to which the AddOnResult resource that contains the payloads to read belongs.
    pub reference_sid: String,
    /// The SID of the AddOnResult to which the payloads to read belongs.
    pub add_on_result_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_recording_transcription`
#[derive(Clone, Debug, Default)]
pub struct ListRecordingTranscriptionParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resources to read.
    pub account_sid: String,
    /// The SID of the [Recording](https://www.twilio.com/docs/voice/api/recording) that created the transcriptions to read.
    pub recording_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_short_code`
#[derive(Clone, Debug, Default)]
pub struct ListShortCodeParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ShortCode resource(s) to read.
    pub account_sid: String,
    /// The string that identifies the ShortCode resources to read.
    pub friendly_name: Option<String>,
    /// Only show the ShortCode resources that match this pattern. You can specify partial numbers and use '*' as a wildcard for any digit.
    pub short_code: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_signing_key`
#[derive(Clone, Debug, Default)]
pub struct ListSigningKeyParams {
    pub account_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sip_auth_calls_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct ListSipAuthCallsCredentialListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resources to read.
    pub account_sid: String,
    /// The SID of the SIP domain that contains the resources to read.
    pub domain_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct ListSipAuthCallsIpAccessControlListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IpAccessControlListMapping resources to read.
    pub account_sid: String,
    /// The SID of the SIP domain that contains the resources to read.
    pub domain_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sip_auth_registrations_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct ListSipAuthRegistrationsCredentialListMappingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialListMapping resources to read.
    pub account_sid: String,
    /// The SID of the SIP domain that contains the resources to read.
    pub domain_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sip_credential`
#[derive(Clone, Debug, Default)]
pub struct ListSipCredentialParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The unique id that identifies the credential list that contains the desired credentials.
    pub credential_list_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sip_credential_list`
#[derive(Clone, Debug, Default)]
pub struct ListSipCredentialListParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sip_credential_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct ListSipCredentialListMappingParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the SIP Domain that includes the resource to read.
    pub domain_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sip_domain`
#[derive(Clone, Debug, Default)]
pub struct ListSipDomainParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the SipDomain resources to read.
    pub account_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sip_ip_access_control_list`
#[derive(Clone, Debug, Default)]
pub struct ListSipIpAccessControlListParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sip_ip_access_control_list_mapping`
#[derive(Clone, Debug, Default)]
pub struct ListSipIpAccessControlListMappingParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the SIP domain.
    pub domain_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sip_ip_address`
#[derive(Clone, Debug, Default)]
pub struct ListSipIpAddressParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// The IpAccessControlList Sid that identifies the IpAddress resources to read.
    pub ip_access_control_list_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_transcription`
#[derive(Clone, Debug, Default)]
pub struct ListTranscriptionParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Transcription resources to read.
    pub account_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_record`
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
    pub account_sid: String,
    /// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
    pub category: Option<String>,
    /// Only include usage that has occurred on or after this date. Specify the date in GMT and format as `YYYY-MM-DD`. You can also specify offsets from the current date, such as: `-30days`, which will set the start date to be 30 days before the current date.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date. Specify the date in GMT and format as `YYYY-MM-DD`.  You can also specify offsets from the current date, such as: `+30days`, which will set the end date to 30 days from the current date.
    pub end_date: Option<String>,
    /// Whether to include usage from the master account and all its subaccounts. Can be: `true` (the default) to include usage from the master account and all subaccounts or `false` to retrieve usage from only the specified account.
    pub include_subaccounts: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_record_all_time`
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordAllTimeParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
    pub account_sid: String,
    /// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
    pub category: Option<String>,
    /// Only include usage that has occurred on or after this date. Specify the date in GMT and format as `YYYY-MM-DD`. You can also specify offsets from the current date, such as: `-30days`, which will set the start date to be 30 days before the current date.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date. Specify the date in GMT and format as `YYYY-MM-DD`.  You can also specify offsets from the current date, such as: `+30days`, which will set the end date to 30 days from the current date.
    pub end_date: Option<String>,
    /// Whether to include usage from the master account and all its subaccounts. Can be: `true` (the default) to include usage from the master account and all subaccounts or `false` to retrieve usage from only the specified account.
    pub include_subaccounts: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_record_daily`
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordDailyParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
    pub account_sid: String,
    /// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
    pub category: Option<String>,
    /// Only include usage that has occurred on or after this date. Specify the date in GMT and format as `YYYY-MM-DD`. You can also specify offsets from the current date, such as: `-30days`, which will set the start date to be 30 days before the current date.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date. Specify the date in GMT and format as `YYYY-MM-DD`.  You can also specify offsets from the current date, such as: `+30days`, which will set the end date to 30 days from the current date.
    pub end_date: Option<String>,
    /// Whether to include usage from the master account and all its subaccounts. Can be: `true` (the default) to include usage from the master account and all subaccounts or `false` to retrieve usage from only the specified account.
    pub include_subaccounts: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_record_last_month`
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordLastMonthParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
    pub account_sid: String,
    /// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
    pub category: Option<String>,
    /// Only include usage that has occurred on or after this date. Specify the date in GMT and format as `YYYY-MM-DD`. You can also specify offsets from the current date, such as: `-30days`, which will set the start date to be 30 days before the current date.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date. Specify the date in GMT and format as `YYYY-MM-DD`.  You can also specify offsets from the current date, such as: `+30days`, which will set the end date to 30 days from the current date.
    pub end_date: Option<String>,
    /// Whether to include usage from the master account and all its subaccounts. Can be: `true` (the default) to include usage from the master account and all subaccounts or `false` to retrieve usage from only the specified account.
    pub include_subaccounts: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_record_monthly`
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordMonthlyParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
    pub account_sid: String,
    /// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
    pub category: Option<String>,
    /// Only include usage that has occurred on or after this date. Specify the date in GMT and format as `YYYY-MM-DD`. You can also specify offsets from the current date, such as: `-30days`, which will set the start date to be 30 days before the current date.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date. Specify the date in GMT and format as `YYYY-MM-DD`.  You can also specify offsets from the current date, such as: `+30days`, which will set the end date to 30 days from the current date.
    pub end_date: Option<String>,
    /// Whether to include usage from the master account and all its subaccounts. Can be: `true` (the default) to include usage from the master account and all subaccounts or `false` to retrieve usage from only the specified account.
    pub include_subaccounts: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_record_this_month`
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordThisMonthParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
    pub account_sid: String,
    /// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
    pub category: Option<String>,
    /// Only include usage that has occurred on or after this date. Specify the date in GMT and format as `YYYY-MM-DD`. You can also specify offsets from the current date, such as: `-30days`, which will set the start date to be 30 days before the current date.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date. Specify the date in GMT and format as `YYYY-MM-DD`.  You can also specify offsets from the current date, such as: `+30days`, which will set the end date to 30 days from the current date.
    pub end_date: Option<String>,
    /// Whether to include usage from the master account and all its subaccounts. Can be: `true` (the default) to include usage from the master account and all subaccounts or `false` to retrieve usage from only the specified account.
    pub include_subaccounts: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_record_today`
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordTodayParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
    pub account_sid: String,
    /// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
    pub category: Option<String>,
    /// Only include usage that has occurred on or after this date. Specify the date in GMT and format as `YYYY-MM-DD`. You can also specify offsets from the current date, such as: `-30days`, which will set the start date to be 30 days before the current date.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date. Specify the date in GMT and format as `YYYY-MM-DD`.  You can also specify offsets from the current date, such as: `+30days`, which will set the end date to 30 days from the current date.
    pub end_date: Option<String>,
    /// Whether to include usage from the master account and all its subaccounts. Can be: `true` (the default) to include usage from the master account and all subaccounts or `false` to retrieve usage from only the specified account.
    pub include_subaccounts: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_record_yearly`
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordYearlyParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
    pub account_sid: String,
    /// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
    pub category: Option<String>,
    /// Only include usage that has occurred on or after this date. Specify the date in GMT and format as `YYYY-MM-DD`. You can also specify offsets from the current date, such as: `-30days`, which will set the start date to be 30 days before the current date.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date. Specify the date in GMT and format as `YYYY-MM-DD`.  You can also specify offsets from the current date, such as: `+30days`, which will set the end date to 30 days from the current date.
    pub end_date: Option<String>,
    /// Whether to include usage from the master account and all its subaccounts. Can be: `true` (the default) to include usage from the master account and all subaccounts or `false` to retrieve usage from only the specified account.
    pub include_subaccounts: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_record_yesterday`
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordYesterdayParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageRecord resources to read.
    pub account_sid: String,
    /// The [usage category](https://www.twilio.com/docs/usage/api/usage-record#usage-categories) of the UsageRecord resources to read. Only UsageRecord resources in the specified category are retrieved.
    pub category: Option<String>,
    /// Only include usage that has occurred on or after this date. Specify the date in GMT and format as `YYYY-MM-DD`. You can also specify offsets from the current date, such as: `-30days`, which will set the start date to be 30 days before the current date.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date. Specify the date in GMT and format as `YYYY-MM-DD`.  You can also specify offsets from the current date, such as: `+30days`, which will set the end date to 30 days from the current date.
    pub end_date: Option<String>,
    /// Whether to include usage from the master account and all its subaccounts. Can be: `true` (the default) to include usage from the master account and all subaccounts or `false` to retrieve usage from only the specified account.
    pub include_subaccounts: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_trigger`
#[derive(Clone, Debug, Default)]
pub struct ListUsageTriggerParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageTrigger resources to read.
    pub account_sid: String,
    /// The frequency of recurring UsageTriggers to read. Can be: `daily`, `monthly`, or `yearly` to read recurring UsageTriggers. An empty value or a value of `alltime` reads non-recurring UsageTriggers.
    pub recurring: Option<String>,
    /// The trigger field of the UsageTriggers to read.  Can be: `count`, `usage`, or `price` as described in the [UsageRecords documentation](https://www.twilio.com/docs/usage/api/usage-record#usage-count-price).
    pub trigger_by: Option<String>,
    /// The usage category of the UsageTriggers to read. Must be a supported [usage categories](https://www.twilio.com/docs/usage/api/usage-record#usage-categories).
    pub usage_category: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_account`
#[derive(Clone, Debug, Default)]
pub struct UpdateAccountParams {
    /// The Account Sid that uniquely identifies the account to update
    pub sid: String,
    /// Update the human-readable description of this Account
    pub friendly_name: Option<String>,
    /// Alter the status of this account: use `closed` to irreversibly close this account, `suspended` to temporarily suspend it, or `active` to reactivate it.
    pub status: Option<String>
}

/// struct for passing parameters to the method `update_address`
#[derive(Clone, Debug, Default)]
pub struct UpdateAddressParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that is responsible for the Address resource to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Address resource to update.
    pub sid: String,
    /// Whether we should automatically correct the address. Can be: `true` or `false` and the default is `true`. If empty or `true`, we will correct the address you provide if necessary. If `false`, we won't alter the address you provide.
    pub auto_correct_address: Option<bool>,
    /// The city of the address.
    pub city: Option<String>,
    /// The name to associate with the address.
    pub customer_name: Option<String>,
    /// Whether to enable emergency calling on the address. Can be: `true` or `false`.
    pub emergency_enabled: Option<bool>,
    /// A descriptive string that you create to describe the address. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The postal code of the address.
    pub postal_code: Option<String>,
    /// The state or region of the address.
    pub region: Option<String>,
    /// The number and street address of the address.
    pub street: Option<String>
}

/// struct for passing parameters to the method `update_application`
#[derive(Clone, Debug, Default)]
pub struct UpdateApplicationParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Application resources to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Application resource to update.
    pub sid: String,
    /// The API version to use to start a new TwiML session. Can be: `2010-04-01` or `2008-08-01`. The default value is your account's default API version.
    pub api_version: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The URL we should call using a POST method to send message status information to your application.
    pub message_status_callback: Option<String>,
    /// The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`.
    pub sms_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while retrieving or executing the TwiML from `sms_url`.
    pub sms_fallback_url: Option<String>,
    /// The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`.
    pub sms_method: Option<String>,
    /// Same as message_status_callback: The URL we should call using a POST method to send status information about SMS messages sent by the application. Deprecated, included for backwards compatibility.
    pub sms_status_callback: Option<String>,
    /// The URL we should call when the phone number receives an incoming SMS message.
    pub sms_url: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST`.
    pub status_callback_method: Option<String>,
    /// Whether we should look up the caller's caller-ID name from the CNAM database (additional charges apply). Can be: `true` or `false`.
    pub voice_caller_id_lookup: Option<bool>,
    /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`.
    pub voice_method: Option<String>,
    /// The URL we should call when the phone number assigned to this application receives a call.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `update_call`
#[derive(Clone, Debug, Default)]
pub struct UpdateCallParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Call resource(s) to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Call resource to update
    pub sid: String,
    /// The HTTP method that we should use to request the `fallback_url`. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
    pub fallback_method: Option<String>,
    /// The URL that we call using the `fallback_method` if an error occurs when requesting or executing the TwiML at `url`. If an `application_sid` parameter is present, this parameter is ignored.
    pub fallback_url: Option<String>,
    /// The HTTP method we should use when calling the `url`. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
    pub method: Option<String>,
    /// The new status of the resource. Can be: `canceled` or `completed`. Specifying `canceled` will attempt to hang up calls that are queued or ringing; however, it will not affect calls already in progress. Specifying `completed` will attempt to hang up a call even if it's already in progress.
    pub status: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application. If no `status_callback_event` is specified, we will send the `completed` status. If an `application_sid` parameter is present, this parameter is ignored. URLs must contain a valid hostname (underscores are not permitted).
    pub status_callback: Option<String>,
    /// The HTTP method we should use when requesting the `status_callback` URL. Can be: `GET` or `POST` and the default is `POST`. If an `application_sid` parameter is present, this parameter is ignored.
    pub status_callback_method: Option<String>,
    /// The maximum duration of the call in seconds. Constraints depend on account and configuration.
    pub time_limit: Option<i32>,
    /// TwiML instructions for the call Twilio will use without fetching Twiml from url. Twiml and url parameters are mutually exclusive
    pub twiml: Option<String>,
    /// The absolute URL that returns the TwiML instructions for the call. We will call this URL using the `method` when the call connects. For more information, see the [Url Parameter](https://www.twilio.com/docs/voice/make-calls#specify-a-url-parameter) section in [Making Calls](https://www.twilio.com/docs/voice/make-calls).
    pub url: Option<String>
}

/// struct for passing parameters to the method `update_call_feedback`
#[derive(Clone, Debug, Default)]
pub struct UpdateCallFeedbackParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// The call sid that uniquely identifies the call
    pub call_sid: String,
    /// One or more issues experienced during the call. The issues can be: `imperfect-audio`, `dropped-call`, `incorrect-caller-id`, `post-dial-delay`, `digits-not-captured`, `audio-latency`, `unsolicited-call`, or `one-way-audio`.
    pub issue: Option<Vec<String>>,
    /// The call quality expressed as an integer from `1` to `5` where `1` represents very poor call quality and `5` represents a perfect call.
    pub quality_score: Option<i32>
}

/// struct for passing parameters to the method `update_call_recording`
#[derive(Clone, Debug, Default)]
pub struct UpdateCallRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Recording resource to update.
    pub account_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resource to update.
    pub call_sid: String,
    /// The Twilio-provided string that uniquely identifies the Recording resource to update.
    pub sid: String,
    /// The new status of the recording. Can be: `stopped`, `paused`, `in-progress`.
    pub status: String,
    /// Whether to record during a pause. Can be: `skip` or `silence` and the default is `silence`. `skip` does not record during the pause period, while `silence` will replace the actual audio of the call with silence during the pause period. This parameter only applies when setting `status` is set to `paused`.
    pub pause_behavior: Option<String>
}

/// struct for passing parameters to the method `update_conference`
#[derive(Clone, Debug, Default)]
pub struct UpdateConferenceParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference resource(s) to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Conference resource to update
    pub sid: String,
    /// The HTTP method used to call `announce_url`. Can be: `GET` or `POST` and the default is `POST`
    pub announce_method: Option<String>,
    /// The URL we should call to announce something into the conference. The URL can return an MP3, a WAV, or a TwiML document with `<Play>` or `<Say>`.
    pub announce_url: Option<String>,
    /// The new status of the resource. Can be:  Can be: `init`, `in-progress`, or `completed`. Specifying `completed` will end the conference and hang up all participants
    pub status: Option<String>
}

/// struct for passing parameters to the method `update_conference_recording`
#[derive(Clone, Debug, Default)]
pub struct UpdateConferenceRecordingParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Conference Recording resource to update.
    pub account_sid: String,
    /// The Conference SID that identifies the conference associated with the recording to update.
    pub conference_sid: String,
    /// The Twilio-provided string that uniquely identifies the Conference Recording resource to update. Use `Twilio.CURRENT` to reference the current active recording.
    pub sid: String,
    /// The new status of the recording. Can be: `stopped`, `paused`, `in-progress`.
    pub status: String,
    /// Whether to record during a pause. Can be: `skip` or `silence` and the default is `silence`. `skip` does not record during the pause period, while `silence` will replace the actual audio of the call with silence during the pause period. This parameter only applies when setting `status` is set to `paused`.
    pub pause_behavior: Option<String>
}

/// struct for passing parameters to the method `update_connect_app`
#[derive(Clone, Debug, Default)]
pub struct UpdateConnectAppParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ConnectApp resources to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the ConnectApp resource to update.
    pub sid: String,
    /// The URL to redirect the user to after we authenticate the user and obtain authorization to access the Connect App.
    pub authorize_redirect_url: Option<String>,
    /// The company name to set for the Connect App.
    pub company_name: Option<String>,
    /// The HTTP method to use when calling `deauthorize_callback_url`.
    pub deauthorize_callback_method: Option<String>,
    /// The URL to call using the `deauthorize_callback_method` to de-authorize the Connect App.
    pub deauthorize_callback_url: Option<String>,
    /// A description of the Connect App.
    pub description: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// A public URL where users can obtain more information about this Connect App.
    pub homepage_url: Option<String>,
    /// A comma-separated list of the permissions you will request from the users of this ConnectApp.  Can include: `get-all` and `post-all`.
    pub permissions: Option<Vec<String>>
}

/// struct for passing parameters to the method `update_incoming_phone_number`
#[derive(Clone, Debug, Default)]
pub struct UpdateIncomingPhoneNumberParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resource to update.  For more information, see [Exchanging Numbers Between Subaccounts](https://www.twilio.com/docs/iam/api/subaccounts#exchanging-numbers).
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the IncomingPhoneNumber resource to update.
    pub sid: String,
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IncomingPhoneNumber resource to update.  For more information, see [Exchanging Numbers Between Subaccounts](https://www.twilio.com/docs/iam/api/subaccounts#exchanging-numbers).
    pub account_sid2: Option<String>,
    /// The SID of the Address resource we should associate with the phone number. Some regions require addresses to meet local regulations.
    pub address_sid: Option<String>,
    /// The API version to use for incoming calls made to the phone number. The default is `2010-04-01`.
    pub api_version: Option<String>,
    /// The SID of the Bundle resource that you associate with the phone number. Some regions require a Bundle to meet local Regulations.
    pub bundle_sid: Option<String>,
    /// The SID of the emergency address configuration to use for emergency calling from this phone number.
    pub emergency_address_sid: Option<String>,
    /// The configuration status parameter that determines whether the phone number is enabled for emergency calling.
    pub emergency_status: Option<String>,
    /// A descriptive string that you created to describe this phone number. It can be up to 64 characters long. By default, this is a formatted version of the phone number.
    pub friendly_name: Option<String>,
    /// The SID of the Identity resource that we should associate with the phone number. Some regions require an identity to meet local regulations.
    pub identity_sid: Option<String>,
    /// The SID of the application that should handle SMS messages sent to the number. If an `sms_application_sid` is present, we ignore all of the `sms_*_url` urls and use those set on the application.
    pub sms_application_sid: Option<String>,
    /// The HTTP method that we should use to call `sms_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub sms_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while requesting or executing the TwiML defined by `sms_url`.
    pub sms_fallback_url: Option<String>,
    /// The HTTP method that we should use to call `sms_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub sms_method: Option<String>,
    /// The URL we should call when the phone number receives an incoming SMS message.
    pub sms_url: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub status_callback_method: Option<String>,
    /// The SID of the Trunk we should use to handle phone calls to the phone number. If a `trunk_sid` is present, we ignore all of the voice urls and voice applications and use only those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
    pub trunk_sid: Option<String>,
    /// The SID of the application we should use to handle phone calls to the phone number. If a `voice_application_sid` is present, we ignore all of the voice urls and use only those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
    pub voice_application_sid: Option<String>,
    /// Whether to lookup the caller's name from the CNAM database and post it to your app. Can be: `true` or `false` and defaults to `false`.
    pub voice_caller_id_lookup: Option<bool>,
    /// The HTTP method that we should use to call `voice_fallback_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs retrieving or executing the TwiML requested by `url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method that we should use to call `voice_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub voice_method: Option<String>,
    /// The configuration parameter for the phone number to receive incoming voice calls or faxes. Can be: `fax` or `voice` and defaults to `voice`.
    pub voice_receive_mode: Option<String>,
    /// The URL that we should call to answer a call to the phone number. The `voice_url` will not be called if a `voice_application_sid` or a `trunk_sid` is set.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `update_key`
#[derive(Clone, Debug, Default)]
pub struct UpdateKeyParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Key resources to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Key resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `update_member`
#[derive(Clone, Debug, Default)]
pub struct UpdateMemberParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Member resource(s) to update.
    pub account_sid: String,
    /// The SID of the Queue in which to find the members to update.
    pub queue_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID of the resource(s) to update.
    pub call_sid: String,
    /// The absolute URL of the Queue resource.
    pub url: String,
    /// How to pass the update request data. Can be `GET` or `POST` and the default is `POST`. `POST` sends the data as encoded form data and `GET` sends the data as query parameters.
    pub method: Option<String>
}

/// struct for passing parameters to the method `update_message`
#[derive(Clone, Debug, Default)]
pub struct UpdateMessageParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Message resources to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Message resource to update.
    pub sid: String,
    /// The text of the message you want to send. Can be up to 1,600 characters long.
    pub body: Option<String>
}

/// struct for passing parameters to the method `update_outgoing_caller_id`
#[derive(Clone, Debug, Default)]
pub struct UpdateOutgoingCallerIdParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the OutgoingCallerId resources to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the OutgoingCallerId resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `update_participant`
#[derive(Clone, Debug, Default)]
pub struct UpdateParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to update.
    pub account_sid: String,
    /// The SID of the conference with the participant to update.
    pub conference_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to update. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
    pub call_sid: String,
    /// The HTTP method we should use to call `announce_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub announce_method: Option<String>,
    /// The URL we call using the `announce_method` for an announcement to the participant. The URL must return an MP3 file, a WAV file, or a TwiML document that contains `<Play>` or `<Say>` commands.
    pub announce_url: Option<String>,
    /// Whether to play a notification beep to the conference when the participant exits. Can be: `true` or `false`.
    pub beep_on_exit: Option<bool>,
    /// The SID of the participant who is being `coached`. The participant being coached is the only participant who can hear the participant who is `coaching`.
    pub call_sid_to_coach: Option<String>,
    /// Whether the participant is coaching another call. Can be: `true` or `false`. If not present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, `call_sid_to_coach` must be defined.
    pub coaching: Option<bool>,
    /// Whether to end the conference when the participant leaves. Can be: `true` or `false` and defaults to `false`.
    pub end_conference_on_exit: Option<bool>,
    /// Whether the participant should be on hold. Can be: `true` or `false`. `true` puts the participant on hold, and `false` lets them rejoin the conference.
    pub hold: Option<bool>,
    /// The HTTP method we should use to call `hold_url`. Can be: `GET` or `POST` and the default is `GET`.
    pub hold_method: Option<String>,
    /// The URL we call using the `hold_method` for  music that plays when the participant is on hold. The URL may return an MP3 file, a WAV file, or a TwiML document that contains the `<Play>`, `<Say>` or `<Redirect>` commands.
    pub hold_url: Option<String>,
    /// Whether the participant should be muted. Can be `true` or `false`. `true` will mute the participant, and `false` will un-mute them. Anything value other than `true` or `false` is interpreted as `false`.
    pub muted: Option<bool>,
    /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
    pub wait_method: Option<String>,
    /// The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
    pub wait_url: Option<String>
}

/// struct for passing parameters to the method `update_payments`
#[derive(Clone, Debug, Default)]
pub struct UpdatePaymentsParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will update the resource.
    pub account_sid: String,
    /// The SID of the call that will update the resource. This should be the same call sid that was used to create payments resource.
    pub call_sid: String,
    /// The SID of Payments session that needs to be updated.
    pub sid: String,
    /// A unique token that will be used to ensure that multiple API calls with the same information do not result in multiple transactions. This should be a unique string value per API call and can be a randomly generated.
    pub idempotency_key: String,
    /// Provide an absolute or relative URL to receive status updates regarding your Pay session. Read more about the [Update](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback-update) and [Complete/Cancel](https://www.twilio.com/docs/voice/api/payment-resource#statuscallback-cancelcomplete) POST requests.
    pub status_callback: String,
    /// The piece of payment information that you wish the caller to enter. Must be one of `payment-card-number`, `expiration-date`, `security-code`, `postal-code`, `bank-routing-number`, or `bank-account-number`.
    pub capture: Option<String>,
    /// Indicates whether the current payment session should be cancelled or completed. When `cancel` the payment session is cancelled. When `complete`, Twilio sends the payment information to the selected <Pay> connector for processing.
    pub status: Option<String>
}

/// struct for passing parameters to the method `update_queue`
#[derive(Clone, Debug, Default)]
pub struct UpdateQueueParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Queue resource to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the Queue resource to update
    pub sid: String,
    /// A descriptive string that you created to describe this resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The maximum number of calls allowed to be in the queue. The default is 100. The maximum is 5000.
    pub max_size: Option<i32>
}

/// struct for passing parameters to the method `update_short_code`
#[derive(Clone, Debug, Default)]
pub struct UpdateShortCodeParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the ShortCode resource(s) to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the ShortCode resource to update
    pub sid: String,
    /// The API version to use to start a new TwiML session. Can be: `2010-04-01` or `2008-08-01`.
    pub api_version: Option<String>,
    /// A descriptive string that you created to describe this resource. It can be up to 64 characters long. By default, the `FriendlyName` is the short code.
    pub friendly_name: Option<String>,
    /// The HTTP method that we should use to call the `sms_fallback_url`. Can be: `GET` or `POST`.
    pub sms_fallback_method: Option<String>,
    /// The URL that we should call if an error occurs while retrieving or executing the TwiML from `sms_url`.
    pub sms_fallback_url: Option<String>,
    /// The HTTP method we should use when calling the `sms_url`. Can be: `GET` or `POST`.
    pub sms_method: Option<String>,
    /// The URL we should call when receiving an incoming SMS message to this short code.
    pub sms_url: Option<String>
}

/// struct for passing parameters to the method `update_signing_key`
#[derive(Clone, Debug, Default)]
pub struct UpdateSigningKeyParams {
    pub account_sid: String,
    pub sid: String,
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `update_sip_credential`
#[derive(Clone, Debug, Default)]
pub struct UpdateSipCredentialParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The unique id that identifies the credential list that includes this credential.
    pub credential_list_sid: String,
    /// The unique id that identifies the resource to update.
    pub sid: String,
    /// The password that the username will use when authenticating SIP requests. The password must be a minimum of 12 characters, contain at least 1 digit, and have mixed case. (eg `IWasAtSignal2018`)
    pub password: Option<String>
}

/// struct for passing parameters to the method `update_sip_credential_list`
#[derive(Clone, Debug, Default)]
pub struct UpdateSipCredentialListParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The credential list Sid that uniquely identifies this resource
    pub sid: String,
    /// A human readable descriptive text for a CredentialList, up to 64 characters long.
    pub friendly_name: String
}

/// struct for passing parameters to the method `update_sip_domain`
#[derive(Clone, Debug, Default)]
pub struct UpdateSipDomainParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the SipDomain resource to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the SipDomain resource to update.
    pub sid: String,
    /// The SID of the BYOC Trunk(Bring Your Own Carrier) resource that the Sip Domain will be associated with.
    pub byoc_trunk_sid: Option<String>,
    /// The unique address you reserve on Twilio to which you route your SIP traffic. Domain names can contain letters, digits, and \\\"-\\\" and must end with `sip.twilio.com`.
    pub domain_name: Option<String>,
    /// Whether an emergency caller sid is configured for the domain. If present, this phone number will be used as the callback for the emergency call.
    pub emergency_caller_sid: Option<String>,
    /// Whether emergency calling is enabled for the domain. If enabled, allows emergency calls on the domain from phone numbers with validated addresses.
    pub emergency_calling_enabled: Option<bool>,
    /// A descriptive string that you created to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// Whether secure SIP is enabled for the domain. If enabled, TLS will be enforced and SRTP will be negotiated on all incoming calls to this sip domain.
    pub secure: Option<bool>,
    /// Whether to allow SIP Endpoints to register with the domain to receive calls. Can be `true` or `false`. `true` allows SIP Endpoints to register with the domain to receive calls, `false` does not.
    pub sip_registration: Option<bool>,
    /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while retrieving or executing the TwiML requested by `voice_url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method we should use to call `voice_url`
    pub voice_method: Option<String>,
    /// The HTTP method we should use to call `voice_status_callback_url`. Can be: `GET` or `POST`.
    pub voice_status_callback_method: Option<String>,
    /// The URL that we should call to pass status parameters (such as call ended) to your application.
    pub voice_status_callback_url: Option<String>,
    /// The URL we should call when the domain receives a call.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `update_sip_ip_access_control_list`
#[derive(Clone, Debug, Default)]
pub struct UpdateSipIpAccessControlListParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// A 34 character string that uniquely identifies the resource to udpate.
    pub sid: String,
    /// A human readable descriptive text, up to 64 characters long.
    pub friendly_name: String
}

/// struct for passing parameters to the method `update_sip_ip_address`
#[derive(Clone, Debug, Default)]
pub struct UpdateSipIpAddressParams {
    /// The unique id of the [Account](https://www.twilio.com/docs/iam/api/account) responsible for this resource.
    pub account_sid: String,
    /// The IpAccessControlList Sid that identifies the IpAddress resources to update.
    pub ip_access_control_list_sid: String,
    /// A 34 character string that identifies the IpAddress resource to update.
    pub sid: String,
    /// An integer representing the length of the CIDR prefix to use with this IP address when accepting traffic. By default the entire IP address is used.
    pub cidr_prefix_length: Option<i32>,
    /// A human readable descriptive text for this resource, up to 64 characters long.
    pub friendly_name: Option<String>,
    /// An IP address in dotted decimal notation from which you want to accept traffic. Any SIP requests from this IP address will be allowed by Twilio. IPv4 only supported today.
    pub ip_address: Option<String>
}

/// struct for passing parameters to the method `update_usage_trigger`
#[derive(Clone, Debug, Default)]
pub struct UpdateUsageTriggerParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the UsageTrigger resources to update.
    pub account_sid: String,
    /// The Twilio-provided string that uniquely identifies the UsageTrigger resource to update.
    pub sid: String,
    /// The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the default is `POST`.
    pub callback_method: Option<String>,
    /// The URL we should call using `callback_method` when the trigger fires.
    pub callback_url: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>
}


/// struct for typed successes of method `create_account`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAccountSuccess {
    Status201(crate::models::ApiV2010Account),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAddressSuccess {
    Status201(crate::models::ApiV2010AccountAddress),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_application`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApplicationSuccess {
    Status201(crate::models::ApiV2010AccountApplication),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCallSuccess {
    Status201(crate::models::ApiV2010AccountCall),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_call_feedback_summary`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCallFeedbackSummarySuccess {
    Status201(crate::models::ApiV2010AccountCallCallFeedbackSummary),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_call_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCallRecordingSuccess {
    Status201(crate::models::ApiV2010AccountCallCallRecording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_incoming_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIncomingPhoneNumberSuccess {
    Status201(crate::models::ApiV2010AccountIncomingPhoneNumber),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_incoming_phone_number_assigned_add_on`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIncomingPhoneNumberAssignedAddOnSuccess {
    Status201(crate::models::ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_incoming_phone_number_local`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIncomingPhoneNumberLocalSuccess {
    Status201(crate::models::ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_incoming_phone_number_mobile`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIncomingPhoneNumberMobileSuccess {
    Status201(crate::models::ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_incoming_phone_number_toll_free`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIncomingPhoneNumberTollFreeSuccess {
    Status201(crate::models::ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageSuccess {
    Status201(crate::models::ApiV2010AccountMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_message_feedback`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageFeedbackSuccess {
    Status201(crate::models::ApiV2010AccountMessageMessageFeedback),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_new_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNewKeySuccess {
    Status201(crate::models::ApiV2010AccountNewKey),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_new_signing_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNewSigningKeySuccess {
    Status201(crate::models::ApiV2010AccountNewSigningKey),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_participant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateParticipantSuccess {
    Status201(crate::models::ApiV2010AccountConferenceParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_payments`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePaymentsSuccess {
    Status201(crate::models::ApiV2010AccountCallPayments),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateQueueSuccess {
    Status201(crate::models::ApiV2010AccountQueue),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sip_auth_calls_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipAuthCallsCredentialListMappingSuccess {
    Status201(crate::models::ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipAuthCallsIpAccessControlListMappingSuccess {
    Status201(crate::models::ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sip_auth_registrations_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipAuthRegistrationsCredentialListMappingSuccess {
    Status201(crate::models::ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sip_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipCredentialSuccess {
    Status201(crate::models::ApiV2010AccountSipSipCredentialListSipCredential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sip_credential_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipCredentialListSuccess {
    Status201(crate::models::ApiV2010AccountSipSipCredentialList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sip_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipCredentialListMappingSuccess {
    Status201(crate::models::ApiV2010AccountSipSipDomainSipCredentialListMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sip_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipDomainSuccess {
    Status201(crate::models::ApiV2010AccountSipSipDomain),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sip_ip_access_control_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipIpAccessControlListSuccess {
    Status201(crate::models::ApiV2010AccountSipSipIpAccessControlList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sip_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipIpAccessControlListMappingSuccess {
    Status201(crate::models::ApiV2010AccountSipSipDomainSipIpAccessControlListMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sip_ip_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipIpAddressSuccess {
    Status201(crate::models::ApiV2010AccountSipSipIpAccessControlListSipIpAddress),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_token`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTokenSuccess {
    Status201(crate::models::ApiV2010AccountToken),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_usage_trigger`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUsageTriggerSuccess {
    Status201(crate::models::ApiV2010AccountUsageUsageTrigger),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_validation_request`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateValidationRequestSuccess {
    Status201(crate::models::ApiV2010AccountValidationRequest),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAddressSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_application`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApplicationSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCallSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_call_feedback_summary`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCallFeedbackSummarySuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_call_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCallRecordingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_conference_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConferenceRecordingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConnectAppSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_incoming_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIncomingPhoneNumberSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_incoming_phone_number_assigned_add_on`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIncomingPhoneNumberAssignedAddOnSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteKeySuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_media`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMediaSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_outgoing_caller_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOutgoingCallerIdSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_participant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteParticipantSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteQueueSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_recording_add_on_result`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingAddOnResultSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_recording_add_on_result_payload`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingAddOnResultPayloadSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_recording_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingTranscriptionSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_signing_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSigningKeySuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sip_auth_calls_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipAuthCallsCredentialListMappingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipAuthCallsIpAccessControlListMappingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sip_auth_registrations_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipAuthRegistrationsCredentialListMappingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sip_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipCredentialSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sip_credential_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipCredentialListSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sip_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipCredentialListMappingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sip_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipDomainSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sip_ip_access_control_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipIpAccessControlListSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sip_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipIpAccessControlListMappingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sip_ip_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipIpAddressSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTranscriptionSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_usage_trigger`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUsageTriggerSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_account`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAccountSuccess {
    Status200(crate::models::ApiV2010Account),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAddressSuccess {
    Status200(crate::models::ApiV2010AccountAddress),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_application`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchApplicationSuccess {
    Status200(crate::models::ApiV2010AccountApplication),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_authorized_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAuthorizedConnectAppSuccess {
    Status200(crate::models::ApiV2010AccountAuthorizedConnectApp),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_available_phone_number_country`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAvailablePhoneNumberCountrySuccess {
    Status200(crate::models::ApiV2010AccountAvailablePhoneNumberCountry),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_balance`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBalanceSuccess {
    Status200(crate::models::ApiV2010AccountBalance),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCallSuccess {
    Status200(crate::models::ApiV2010AccountCall),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_call_feedback`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCallFeedbackSuccess {
    Status200(crate::models::ApiV2010AccountCallCallFeedback),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_call_feedback_summary`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCallFeedbackSummarySuccess {
    Status200(crate::models::ApiV2010AccountCallCallFeedbackSummary),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_call_notification`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCallNotificationSuccess {
    Status200(crate::models::ApiV2010AccountCallCallNotificationInstance),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_call_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCallRecordingSuccess {
    Status200(crate::models::ApiV2010AccountCallCallRecording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_conference`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConferenceSuccess {
    Status200(crate::models::ApiV2010AccountConference),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_conference_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConferenceRecordingSuccess {
    Status200(crate::models::ApiV2010AccountConferenceConferenceRecording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConnectAppSuccess {
    Status200(crate::models::ApiV2010AccountConnectApp),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_incoming_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchIncomingPhoneNumberSuccess {
    Status200(crate::models::ApiV2010AccountIncomingPhoneNumber),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_incoming_phone_number_assigned_add_on`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchIncomingPhoneNumberAssignedAddOnSuccess {
    Status200(crate::models::ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_incoming_phone_number_assigned_add_on_extension`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchIncomingPhoneNumberAssignedAddOnExtensionSuccess {
    Status200(crate::models::ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchKeySuccess {
    Status200(crate::models::ApiV2010AccountKey),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_media`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMediaSuccess {
    Status200(crate::models::ApiV2010AccountMessageMedia),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMemberSuccess {
    Status200(crate::models::ApiV2010AccountQueueMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessageSuccess {
    Status200(crate::models::ApiV2010AccountMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_notification`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchNotificationSuccess {
    Status200(crate::models::ApiV2010AccountNotificationInstance),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_outgoing_caller_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchOutgoingCallerIdSuccess {
    Status200(crate::models::ApiV2010AccountOutgoingCallerId),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_participant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchParticipantSuccess {
    Status200(crate::models::ApiV2010AccountConferenceParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchQueueSuccess {
    Status200(crate::models::ApiV2010AccountQueue),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingSuccess {
    Status200(crate::models::ApiV2010AccountRecording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_recording_add_on_result`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingAddOnResultSuccess {
    Status200(crate::models::ApiV2010AccountRecordingRecordingAddOnResult),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_recording_add_on_result_payload`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingAddOnResultPayloadSuccess {
    Status200(crate::models::ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_recording_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingTranscriptionSuccess {
    Status200(crate::models::ApiV2010AccountRecordingRecordingTranscription),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_short_code`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchShortCodeSuccess {
    Status200(crate::models::ApiV2010AccountShortCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_signing_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSigningKeySuccess {
    Status200(crate::models::ApiV2010AccountSigningKey),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sip_auth_calls_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipAuthCallsCredentialListMappingSuccess {
    Status200(crate::models::ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipAuthCallsIpAccessControlListMappingSuccess {
    Status200(crate::models::ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sip_auth_registrations_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipAuthRegistrationsCredentialListMappingSuccess {
    Status200(crate::models::ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sip_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipCredentialSuccess {
    Status200(crate::models::ApiV2010AccountSipSipCredentialListSipCredential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sip_credential_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipCredentialListSuccess {
    Status200(crate::models::ApiV2010AccountSipSipCredentialList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sip_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipCredentialListMappingSuccess {
    Status200(crate::models::ApiV2010AccountSipSipDomainSipCredentialListMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sip_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipDomainSuccess {
    Status200(crate::models::ApiV2010AccountSipSipDomain),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sip_ip_access_control_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipIpAccessControlListSuccess {
    Status200(crate::models::ApiV2010AccountSipSipIpAccessControlList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sip_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipIpAccessControlListMappingSuccess {
    Status200(crate::models::ApiV2010AccountSipSipDomainSipIpAccessControlListMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sip_ip_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipIpAddressSuccess {
    Status200(crate::models::ApiV2010AccountSipSipIpAccessControlListSipIpAddress),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTranscriptionSuccess {
    Status200(crate::models::ApiV2010AccountTranscription),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_usage_trigger`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUsageTriggerSuccess {
    Status200(crate::models::ApiV2010AccountUsageUsageTrigger),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_account`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAccountSuccess {
    Status200(crate::models::ListAccountResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAddressSuccess {
    Status200(crate::models::ListAddressResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_application`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListApplicationSuccess {
    Status200(crate::models::ListApplicationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_authorized_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAuthorizedConnectAppSuccess {
    Status200(crate::models::ListAuthorizedConnectAppResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_available_phone_number_country`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberCountrySuccess {
    Status200(crate::models::ListAvailablePhoneNumberCountryResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_available_phone_number_local`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberLocalSuccess {
    Status200(crate::models::ListAvailablePhoneNumberLocalResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_available_phone_number_machine_to_machine`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberMachineToMachineSuccess {
    Status200(crate::models::ListAvailablePhoneNumberMachineToMachineResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_available_phone_number_mobile`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberMobileSuccess {
    Status200(crate::models::ListAvailablePhoneNumberMobileResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_available_phone_number_national`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberNationalSuccess {
    Status200(crate::models::ListAvailablePhoneNumberNationalResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_available_phone_number_shared_cost`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberSharedCostSuccess {
    Status200(crate::models::ListAvailablePhoneNumberSharedCostResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_available_phone_number_toll_free`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberTollFreeSuccess {
    Status200(crate::models::ListAvailablePhoneNumberTollFreeResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_available_phone_number_voip`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberVoipSuccess {
    Status200(crate::models::ListAvailablePhoneNumberVoipResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCallSuccess {
    Status200(crate::models::ListCallResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_call_event`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCallEventSuccess {
    Status200(crate::models::ListCallEventResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_call_notification`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCallNotificationSuccess {
    Status200(crate::models::ListCallNotificationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_call_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCallRecordingSuccess {
    Status200(crate::models::ListCallRecordingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_conference`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConferenceSuccess {
    Status200(crate::models::ListConferenceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_conference_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConferenceRecordingSuccess {
    Status200(crate::models::ListConferenceRecordingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConnectAppSuccess {
    Status200(crate::models::ListConnectAppResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_dependent_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDependentPhoneNumberSuccess {
    Status200(crate::models::ListDependentPhoneNumberResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_incoming_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberSuccess {
    Status200(crate::models::ListIncomingPhoneNumberResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_incoming_phone_number_assigned_add_on`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberAssignedAddOnSuccess {
    Status200(crate::models::ListIncomingPhoneNumberAssignedAddOnResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_incoming_phone_number_assigned_add_on_extension`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberAssignedAddOnExtensionSuccess {
    Status200(crate::models::ListIncomingPhoneNumberAssignedAddOnExtensionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_incoming_phone_number_local`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberLocalSuccess {
    Status200(crate::models::ListIncomingPhoneNumberLocalResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_incoming_phone_number_mobile`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberMobileSuccess {
    Status200(crate::models::ListIncomingPhoneNumberMobileResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_incoming_phone_number_toll_free`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberTollFreeSuccess {
    Status200(crate::models::ListIncomingPhoneNumberTollFreeResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListKeySuccess {
    Status200(crate::models::ListKeyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_media`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMediaSuccess {
    Status200(crate::models::ListMediaResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMemberSuccess {
    Status200(crate::models::ListMemberResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessageSuccess {
    Status200(crate::models::ListMessageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_notification`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListNotificationSuccess {
    Status200(crate::models::ListNotificationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_outgoing_caller_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOutgoingCallerIdSuccess {
    Status200(crate::models::ListOutgoingCallerIdResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_participant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListParticipantSuccess {
    Status200(crate::models::ListParticipantResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListQueueSuccess {
    Status200(crate::models::ListQueueResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingSuccess {
    Status200(crate::models::ListRecordingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_recording_add_on_result`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingAddOnResultSuccess {
    Status200(crate::models::ListRecordingAddOnResultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_recording_add_on_result_payload`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingAddOnResultPayloadSuccess {
    Status200(crate::models::ListRecordingAddOnResultPayloadResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_recording_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingTranscriptionSuccess {
    Status200(crate::models::ListRecordingTranscriptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_short_code`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListShortCodeSuccess {
    Status200(crate::models::ListShortCodeResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_signing_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSigningKeySuccess {
    Status200(crate::models::ListSigningKeyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sip_auth_calls_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipAuthCallsCredentialListMappingSuccess {
    Status200(crate::models::ListSipAuthCallsCredentialListMappingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipAuthCallsIpAccessControlListMappingSuccess {
    Status200(crate::models::ListSipAuthCallsIpAccessControlListMappingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sip_auth_registrations_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipAuthRegistrationsCredentialListMappingSuccess {
    Status200(crate::models::ListSipAuthRegistrationsCredentialListMappingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sip_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipCredentialSuccess {
    Status200(crate::models::ListSipCredentialResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sip_credential_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipCredentialListSuccess {
    Status200(crate::models::ListSipCredentialListResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sip_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipCredentialListMappingSuccess {
    Status200(crate::models::ListSipCredentialListMappingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sip_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipDomainSuccess {
    Status200(crate::models::ListSipDomainResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sip_ip_access_control_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipIpAccessControlListSuccess {
    Status200(crate::models::ListSipIpAccessControlListResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sip_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipIpAccessControlListMappingSuccess {
    Status200(crate::models::ListSipIpAccessControlListMappingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sip_ip_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipIpAddressSuccess {
    Status200(crate::models::ListSipIpAddressResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTranscriptionSuccess {
    Status200(crate::models::ListTranscriptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordSuccess {
    Status200(crate::models::ListUsageRecordResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_record_all_time`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordAllTimeSuccess {
    Status200(crate::models::ListUsageRecordAllTimeResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_record_daily`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordDailySuccess {
    Status200(crate::models::ListUsageRecordDailyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_record_last_month`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordLastMonthSuccess {
    Status200(crate::models::ListUsageRecordLastMonthResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_record_monthly`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordMonthlySuccess {
    Status200(crate::models::ListUsageRecordMonthlyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_record_this_month`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordThisMonthSuccess {
    Status200(crate::models::ListUsageRecordThisMonthResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_record_today`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordTodaySuccess {
    Status200(crate::models::ListUsageRecordTodayResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_record_yearly`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordYearlySuccess {
    Status200(crate::models::ListUsageRecordYearlyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_record_yesterday`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordYesterdaySuccess {
    Status200(crate::models::ListUsageRecordYesterdayResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_trigger`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageTriggerSuccess {
    Status200(crate::models::ListUsageTriggerResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_account`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAccountSuccess {
    Status200(crate::models::ApiV2010Account),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAddressSuccess {
    Status200(crate::models::ApiV2010AccountAddress),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_application`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApplicationSuccess {
    Status200(crate::models::ApiV2010AccountApplication),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCallSuccess {
    Status200(crate::models::ApiV2010AccountCall),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_call_feedback`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCallFeedbackSuccess {
    Status200(crate::models::ApiV2010AccountCallCallFeedback),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_call_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCallRecordingSuccess {
    Status200(crate::models::ApiV2010AccountCallCallRecording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_conference`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConferenceSuccess {
    Status200(crate::models::ApiV2010AccountConference),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_conference_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConferenceRecordingSuccess {
    Status200(crate::models::ApiV2010AccountConferenceConferenceRecording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConnectAppSuccess {
    Status200(crate::models::ApiV2010AccountConnectApp),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_incoming_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateIncomingPhoneNumberSuccess {
    Status200(crate::models::ApiV2010AccountIncomingPhoneNumber),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateKeySuccess {
    Status200(crate::models::ApiV2010AccountKey),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMemberSuccess {
    Status200(crate::models::ApiV2010AccountQueueMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageSuccess {
    Status200(crate::models::ApiV2010AccountMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_outgoing_caller_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOutgoingCallerIdSuccess {
    Status200(crate::models::ApiV2010AccountOutgoingCallerId),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_participant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateParticipantSuccess {
    Status200(crate::models::ApiV2010AccountConferenceParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_payments`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePaymentsSuccess {
    Status202(crate::models::ApiV2010AccountCallPayments),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateQueueSuccess {
    Status200(crate::models::ApiV2010AccountQueue),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_short_code`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateShortCodeSuccess {
    Status200(crate::models::ApiV2010AccountShortCode),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_signing_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSigningKeySuccess {
    Status200(crate::models::ApiV2010AccountSigningKey),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sip_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipCredentialSuccess {
    Status200(crate::models::ApiV2010AccountSipSipCredentialListSipCredential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sip_credential_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipCredentialListSuccess {
    Status200(crate::models::ApiV2010AccountSipSipCredentialList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sip_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipDomainSuccess {
    Status200(crate::models::ApiV2010AccountSipSipDomain),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sip_ip_access_control_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipIpAccessControlListSuccess {
    Status200(crate::models::ApiV2010AccountSipSipIpAccessControlList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sip_ip_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipIpAddressSuccess {
    Status200(crate::models::ApiV2010AccountSipSipIpAccessControlListSipIpAddress),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_usage_trigger`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUsageTriggerSuccess {
    Status200(crate::models::ApiV2010AccountUsageUsageTrigger),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_account`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_application`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApplicationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCallError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_call_feedback_summary`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCallFeedbackSummaryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_call_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCallRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_incoming_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIncomingPhoneNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_incoming_phone_number_assigned_add_on`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIncomingPhoneNumberAssignedAddOnError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_incoming_phone_number_local`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIncomingPhoneNumberLocalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_incoming_phone_number_mobile`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIncomingPhoneNumberMobileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_incoming_phone_number_toll_free`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIncomingPhoneNumberTollFreeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_message_feedback`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageFeedbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_new_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNewKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_new_signing_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNewSigningKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_participant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_payments`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePaymentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sip_auth_calls_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipAuthCallsCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipAuthCallsIpAccessControlListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sip_auth_registrations_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipAuthRegistrationsCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sip_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sip_credential_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipCredentialListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sip_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sip_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipDomainError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sip_ip_access_control_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipIpAccessControlListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sip_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipIpAccessControlListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sip_ip_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipIpAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_token`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_usage_trigger`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUsageTriggerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_validation_request`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateValidationRequestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_application`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApplicationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCallError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_call_feedback_summary`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCallFeedbackSummaryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_call_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCallRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_conference_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConferenceRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConnectAppError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_incoming_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIncomingPhoneNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_incoming_phone_number_assigned_add_on`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIncomingPhoneNumberAssignedAddOnError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_media`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMediaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_outgoing_caller_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOutgoingCallerIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_participant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_recording_add_on_result`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingAddOnResultError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_recording_add_on_result_payload`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingAddOnResultPayloadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_recording_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingTranscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_signing_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSigningKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sip_auth_calls_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipAuthCallsCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipAuthCallsIpAccessControlListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sip_auth_registrations_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipAuthRegistrationsCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sip_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sip_credential_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipCredentialListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sip_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sip_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipDomainError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sip_ip_access_control_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipIpAccessControlListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sip_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipIpAccessControlListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sip_ip_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipIpAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTranscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_usage_trigger`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUsageTriggerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_account`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_application`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchApplicationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_authorized_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAuthorizedConnectAppError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_available_phone_number_country`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAvailablePhoneNumberCountryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_balance`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBalanceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCallError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_call_feedback`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCallFeedbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_call_feedback_summary`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCallFeedbackSummaryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_call_notification`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCallNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_call_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCallRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_conference`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConferenceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_conference_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConferenceRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConnectAppError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_incoming_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchIncomingPhoneNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_incoming_phone_number_assigned_add_on`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchIncomingPhoneNumberAssignedAddOnError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_incoming_phone_number_assigned_add_on_extension`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchIncomingPhoneNumberAssignedAddOnExtensionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_media`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMediaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_notification`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_outgoing_caller_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchOutgoingCallerIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_participant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_recording_add_on_result`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingAddOnResultError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_recording_add_on_result_payload`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingAddOnResultPayloadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_recording_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingTranscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_short_code`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchShortCodeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_signing_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSigningKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sip_auth_calls_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipAuthCallsCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipAuthCallsIpAccessControlListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sip_auth_registrations_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipAuthRegistrationsCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sip_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sip_credential_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipCredentialListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sip_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sip_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipDomainError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sip_ip_access_control_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipIpAccessControlListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sip_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipIpAccessControlListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sip_ip_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipIpAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTranscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_usage_trigger`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUsageTriggerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_account`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_application`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListApplicationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_authorized_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAuthorizedConnectAppError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_available_phone_number_country`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberCountryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_available_phone_number_local`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberLocalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_available_phone_number_machine_to_machine`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberMachineToMachineError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_available_phone_number_mobile`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberMobileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_available_phone_number_national`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberNationalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_available_phone_number_shared_cost`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberSharedCostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_available_phone_number_toll_free`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberTollFreeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_available_phone_number_voip`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAvailablePhoneNumberVoipError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCallError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_call_event`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCallEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_call_notification`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCallNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_call_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCallRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_conference`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConferenceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_conference_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConferenceRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConnectAppError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_dependent_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDependentPhoneNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_incoming_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_incoming_phone_number_assigned_add_on`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberAssignedAddOnError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_incoming_phone_number_assigned_add_on_extension`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberAssignedAddOnExtensionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_incoming_phone_number_local`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberLocalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_incoming_phone_number_mobile`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberMobileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_incoming_phone_number_toll_free`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIncomingPhoneNumberTollFreeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_media`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMediaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_notification`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_outgoing_caller_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOutgoingCallerIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_participant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_recording_add_on_result`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingAddOnResultError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_recording_add_on_result_payload`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingAddOnResultPayloadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_recording_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingTranscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_short_code`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListShortCodeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_signing_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSigningKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sip_auth_calls_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipAuthCallsCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sip_auth_calls_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipAuthCallsIpAccessControlListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sip_auth_registrations_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipAuthRegistrationsCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sip_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sip_credential_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipCredentialListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sip_credential_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipCredentialListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sip_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipDomainError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sip_ip_access_control_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipIpAccessControlListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sip_ip_access_control_list_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipIpAccessControlListMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sip_ip_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipIpAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_transcription`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTranscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_record_all_time`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordAllTimeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_record_daily`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordDailyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_record_last_month`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordLastMonthError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_record_monthly`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordMonthlyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_record_this_month`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordThisMonthError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_record_today`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordTodayError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_record_yearly`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordYearlyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_record_yesterday`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordYesterdayError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_trigger`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageTriggerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_account`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAccountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_application`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApplicationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_call`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCallError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_call_feedback`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCallFeedbackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_call_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCallRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_conference`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConferenceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_conference_recording`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConferenceRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_connect_app`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConnectAppError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_incoming_phone_number`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateIncomingPhoneNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_outgoing_caller_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOutgoingCallerIdError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_participant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_payments`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePaymentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_short_code`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateShortCodeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_signing_key`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSigningKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sip_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sip_credential_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipCredentialListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sip_domain`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipDomainError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sip_ip_access_control_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipIpAccessControlListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sip_ip_address`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipIpAddressError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_usage_trigger`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUsageTriggerError {
    UnknownValue(serde_json::Value),
}


/// Create a new Twilio Subaccount from the account making the request
pub async fn create_account(configuration: &configuration::Configuration, params: CreateAccountParams) -> Result<ResponseContent<CreateAccountSuccess>, Error<CreateAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts.json", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateAccountSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_address(configuration: &configuration::Configuration, params: CreateAddressParams) -> Result<ResponseContent<CreateAddressSuccess>, Error<CreateAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let city = params.city;
    let customer_name = params.customer_name;
    let iso_country = params.iso_country;
    let postal_code = params.postal_code;
    let region = params.region;
    let street = params.street;
    let auto_correct_address = params.auto_correct_address;
    let emergency_enabled = params.emergency_enabled;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Addresses.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = auto_correct_address {
        local_var_form_params.insert("AutoCorrectAddress", local_var_param_value.to_string());
    }
    local_var_form_params.insert("City", city.to_string());
    local_var_form_params.insert("CustomerName", customer_name.to_string());
    if let Some(local_var_param_value) = emergency_enabled {
        local_var_form_params.insert("EmergencyEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("IsoCountry", iso_country.to_string());
    local_var_form_params.insert("PostalCode", postal_code.to_string());
    local_var_form_params.insert("Region", region.to_string());
    local_var_form_params.insert("Street", street.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateAddressSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new application within your account
pub async fn create_application(configuration: &configuration::Configuration, params: CreateApplicationParams) -> Result<ResponseContent<CreateApplicationSuccess>, Error<CreateApplicationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let api_version = params.api_version;
    let friendly_name = params.friendly_name;
    let message_status_callback = params.message_status_callback;
    let sms_fallback_method = params.sms_fallback_method;
    let sms_fallback_url = params.sms_fallback_url;
    let sms_method = params.sms_method;
    let sms_status_callback = params.sms_status_callback;
    let sms_url = params.sms_url;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let voice_caller_id_lookup = params.voice_caller_id_lookup;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Applications.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_version {
        local_var_form_params.insert("ApiVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = message_status_callback {
        local_var_form_params.insert("MessageStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_method {
        local_var_form_params.insert("SmsFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_url {
        local_var_form_params.insert("SmsFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_method {
        local_var_form_params.insert("SmsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_status_callback {
        local_var_form_params.insert("SmsStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_url {
        local_var_form_params.insert("SmsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_caller_id_lookup {
        local_var_form_params.insert("VoiceCallerIdLookup", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateApplicationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateApplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new outgoing call to phones, SIP-enabled endpoints or Twilio Client connections
pub async fn create_call(configuration: &configuration::Configuration, params: CreateCallParams) -> Result<ResponseContent<CreateCallSuccess>, Error<CreateCallError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let from = params.from;
    let to = params.to;
    let application_sid = params.application_sid;
    let async_amd = params.async_amd;
    let async_amd_status_callback = params.async_amd_status_callback;
    let async_amd_status_callback_method = params.async_amd_status_callback_method;
    let byoc = params.byoc;
    let call_reason = params.call_reason;
    let call_token = params.call_token;
    let caller_id = params.caller_id;
    let fallback_method = params.fallback_method;
    let fallback_url = params.fallback_url;
    let machine_detection = params.machine_detection;
    let machine_detection_silence_timeout = params.machine_detection_silence_timeout;
    let machine_detection_speech_end_threshold = params.machine_detection_speech_end_threshold;
    let machine_detection_speech_threshold = params.machine_detection_speech_threshold;
    let machine_detection_timeout = params.machine_detection_timeout;
    let method = params.method;
    let record = params.record;
    let recording_channels = params.recording_channels;
    let recording_status_callback = params.recording_status_callback;
    let recording_status_callback_event = params.recording_status_callback_event;
    let recording_status_callback_method = params.recording_status_callback_method;
    let recording_track = params.recording_track;
    let send_digits = params.send_digits;
    let sip_auth_password = params.sip_auth_password;
    let sip_auth_username = params.sip_auth_username;
    let status_callback = params.status_callback;
    let status_callback_event = params.status_callback_event;
    let status_callback_method = params.status_callback_method;
    let time_limit = params.time_limit;
    let timeout = params.timeout;
    let trim = params.trim;
    let twiml = params.twiml;
    let url = params.url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = application_sid {
        local_var_form_params.insert("ApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = async_amd {
        local_var_form_params.insert("AsyncAmd", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = async_amd_status_callback {
        local_var_form_params.insert("AsyncAmdStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = async_amd_status_callback_method {
        local_var_form_params.insert("AsyncAmdStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = byoc {
        local_var_form_params.insert("Byoc", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_reason {
        local_var_form_params.insert("CallReason", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_token {
        local_var_form_params.insert("CallToken", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = caller_id {
        local_var_form_params.insert("CallerId", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fallback_method {
        local_var_form_params.insert("FallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fallback_url {
        local_var_form_params.insert("FallbackUrl", local_var_param_value.to_string());
    }
    local_var_form_params.insert("From", from.to_string());
    if let Some(local_var_param_value) = machine_detection {
        local_var_form_params.insert("MachineDetection", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = machine_detection_silence_timeout {
        local_var_form_params.insert("MachineDetectionSilenceTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = machine_detection_speech_end_threshold {
        local_var_form_params.insert("MachineDetectionSpeechEndThreshold", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = machine_detection_speech_threshold {
        local_var_form_params.insert("MachineDetectionSpeechThreshold", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = machine_detection_timeout {
        local_var_form_params.insert("MachineDetectionTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = method {
        local_var_form_params.insert("Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = record {
        local_var_form_params.insert("Record", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_channels {
        local_var_form_params.insert("RecordingChannels", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback {
        local_var_form_params.insert("RecordingStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback_event {
        local_var_form_params.insert("RecordingStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback_method {
        local_var_form_params.insert("RecordingStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_track {
        local_var_form_params.insert("RecordingTrack", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = send_digits {
        local_var_form_params.insert("SendDigits", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_auth_password {
        local_var_form_params.insert("SipAuthPassword", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_auth_username {
        local_var_form_params.insert("SipAuthUsername", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_event {
        local_var_form_params.insert("StatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = time_limit {
        local_var_form_params.insert("TimeLimit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timeout {
        local_var_form_params.insert("Timeout", local_var_param_value.to_string());
    }
    local_var_form_params.insert("To", to.to_string());
    if let Some(local_var_param_value) = trim {
        local_var_form_params.insert("Trim", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = twiml {
        local_var_form_params.insert("Twiml", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = url {
        local_var_form_params.insert("Url", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCallSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCallError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a FeedbackSummary resource for a call
pub async fn create_call_feedback_summary(configuration: &configuration::Configuration, params: CreateCallFeedbackSummaryParams) -> Result<ResponseContent<CreateCallFeedbackSummarySuccess>, Error<CreateCallFeedbackSummaryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let end_date = params.end_date;
    let start_date = params.start_date;
    let include_subaccounts = params.include_subaccounts;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("EndDate", end_date.to_string());
    if let Some(local_var_param_value) = include_subaccounts {
        local_var_form_params.insert("IncludeSubaccounts", local_var_param_value.to_string());
    }
    local_var_form_params.insert("StartDate", start_date.to_string());
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCallFeedbackSummarySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCallFeedbackSummaryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a recording for the call
pub async fn create_call_recording(configuration: &configuration::Configuration, params: CreateCallRecordingParams) -> Result<ResponseContent<CreateCallRecordingSuccess>, Error<CreateCallRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let recording_channels = params.recording_channels;
    let recording_status_callback = params.recording_status_callback;
    let recording_status_callback_event = params.recording_status_callback_event;
    let recording_status_callback_method = params.recording_status_callback_method;
    let recording_track = params.recording_track;
    let trim = params.trim;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = recording_channels {
        local_var_form_params.insert("RecordingChannels", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback {
        local_var_form_params.insert("RecordingStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback_event {
        local_var_form_params.insert("RecordingStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback_method {
        local_var_form_params.insert("RecordingStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_track {
        local_var_form_params.insert("RecordingTrack", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trim {
        local_var_form_params.insert("Trim", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCallRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCallRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Purchase a phone-number for the account.
pub async fn create_incoming_phone_number(configuration: &configuration::Configuration, params: CreateIncomingPhoneNumberParams) -> Result<ResponseContent<CreateIncomingPhoneNumberSuccess>, Error<CreateIncomingPhoneNumberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let address_sid = params.address_sid;
    let api_version = params.api_version;
    let area_code = params.area_code;
    let bundle_sid = params.bundle_sid;
    let emergency_address_sid = params.emergency_address_sid;
    let emergency_status = params.emergency_status;
    let friendly_name = params.friendly_name;
    let identity_sid = params.identity_sid;
    let phone_number = params.phone_number;
    let sms_application_sid = params.sms_application_sid;
    let sms_fallback_method = params.sms_fallback_method;
    let sms_fallback_url = params.sms_fallback_url;
    let sms_method = params.sms_method;
    let sms_url = params.sms_url;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let trunk_sid = params.trunk_sid;
    let voice_application_sid = params.voice_application_sid;
    let voice_caller_id_lookup = params.voice_caller_id_lookup;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_receive_mode = params.voice_receive_mode;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = address_sid {
        local_var_form_params.insert("AddressSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = api_version {
        local_var_form_params.insert("ApiVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = area_code {
        local_var_form_params.insert("AreaCode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = bundle_sid {
        local_var_form_params.insert("BundleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_address_sid {
        local_var_form_params.insert("EmergencyAddressSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_status {
        local_var_form_params.insert("EmergencyStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = identity_sid {
        local_var_form_params.insert("IdentitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = phone_number {
        local_var_form_params.insert("PhoneNumber", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_application_sid {
        local_var_form_params.insert("SmsApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_method {
        local_var_form_params.insert("SmsFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_url {
        local_var_form_params.insert("SmsFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_method {
        local_var_form_params.insert("SmsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_url {
        local_var_form_params.insert("SmsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trunk_sid {
        local_var_form_params.insert("TrunkSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_application_sid {
        local_var_form_params.insert("VoiceApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_caller_id_lookup {
        local_var_form_params.insert("VoiceCallerIdLookup", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_receive_mode {
        local_var_form_params.insert("VoiceReceiveMode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateIncomingPhoneNumberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateIncomingPhoneNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Assign an Add-on installation to the Number specified.
pub async fn create_incoming_phone_number_assigned_add_on(configuration: &configuration::Configuration, params: CreateIncomingPhoneNumberAssignedAddOnParams) -> Result<ResponseContent<CreateIncomingPhoneNumberAssignedAddOnSuccess>, Error<CreateIncomingPhoneNumberAssignedAddOnError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let resource_sid = params.resource_sid;
    let installed_add_on_sid = params.installed_add_on_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ResourceSid=crate::apis::urlencode(resource_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("InstalledAddOnSid", installed_add_on_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateIncomingPhoneNumberAssignedAddOnSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateIncomingPhoneNumberAssignedAddOnError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_incoming_phone_number_local(configuration: &configuration::Configuration, params: CreateIncomingPhoneNumberLocalParams) -> Result<ResponseContent<CreateIncomingPhoneNumberLocalSuccess>, Error<CreateIncomingPhoneNumberLocalError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let phone_number = params.phone_number;
    let address_sid = params.address_sid;
    let api_version = params.api_version;
    let bundle_sid = params.bundle_sid;
    let emergency_address_sid = params.emergency_address_sid;
    let emergency_status = params.emergency_status;
    let friendly_name = params.friendly_name;
    let identity_sid = params.identity_sid;
    let sms_application_sid = params.sms_application_sid;
    let sms_fallback_method = params.sms_fallback_method;
    let sms_fallback_url = params.sms_fallback_url;
    let sms_method = params.sms_method;
    let sms_url = params.sms_url;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let trunk_sid = params.trunk_sid;
    let voice_application_sid = params.voice_application_sid;
    let voice_caller_id_lookup = params.voice_caller_id_lookup;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_receive_mode = params.voice_receive_mode;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = address_sid {
        local_var_form_params.insert("AddressSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = api_version {
        local_var_form_params.insert("ApiVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = bundle_sid {
        local_var_form_params.insert("BundleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_address_sid {
        local_var_form_params.insert("EmergencyAddressSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_status {
        local_var_form_params.insert("EmergencyStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = identity_sid {
        local_var_form_params.insert("IdentitySid", local_var_param_value.to_string());
    }
    local_var_form_params.insert("PhoneNumber", phone_number.to_string());
    if let Some(local_var_param_value) = sms_application_sid {
        local_var_form_params.insert("SmsApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_method {
        local_var_form_params.insert("SmsFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_url {
        local_var_form_params.insert("SmsFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_method {
        local_var_form_params.insert("SmsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_url {
        local_var_form_params.insert("SmsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trunk_sid {
        local_var_form_params.insert("TrunkSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_application_sid {
        local_var_form_params.insert("VoiceApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_caller_id_lookup {
        local_var_form_params.insert("VoiceCallerIdLookup", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_receive_mode {
        local_var_form_params.insert("VoiceReceiveMode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateIncomingPhoneNumberLocalSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateIncomingPhoneNumberLocalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_incoming_phone_number_mobile(configuration: &configuration::Configuration, params: CreateIncomingPhoneNumberMobileParams) -> Result<ResponseContent<CreateIncomingPhoneNumberMobileSuccess>, Error<CreateIncomingPhoneNumberMobileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let phone_number = params.phone_number;
    let address_sid = params.address_sid;
    let api_version = params.api_version;
    let bundle_sid = params.bundle_sid;
    let emergency_address_sid = params.emergency_address_sid;
    let emergency_status = params.emergency_status;
    let friendly_name = params.friendly_name;
    let identity_sid = params.identity_sid;
    let sms_application_sid = params.sms_application_sid;
    let sms_fallback_method = params.sms_fallback_method;
    let sms_fallback_url = params.sms_fallback_url;
    let sms_method = params.sms_method;
    let sms_url = params.sms_url;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let trunk_sid = params.trunk_sid;
    let voice_application_sid = params.voice_application_sid;
    let voice_caller_id_lookup = params.voice_caller_id_lookup;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_receive_mode = params.voice_receive_mode;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = address_sid {
        local_var_form_params.insert("AddressSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = api_version {
        local_var_form_params.insert("ApiVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = bundle_sid {
        local_var_form_params.insert("BundleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_address_sid {
        local_var_form_params.insert("EmergencyAddressSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_status {
        local_var_form_params.insert("EmergencyStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = identity_sid {
        local_var_form_params.insert("IdentitySid", local_var_param_value.to_string());
    }
    local_var_form_params.insert("PhoneNumber", phone_number.to_string());
    if let Some(local_var_param_value) = sms_application_sid {
        local_var_form_params.insert("SmsApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_method {
        local_var_form_params.insert("SmsFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_url {
        local_var_form_params.insert("SmsFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_method {
        local_var_form_params.insert("SmsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_url {
        local_var_form_params.insert("SmsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trunk_sid {
        local_var_form_params.insert("TrunkSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_application_sid {
        local_var_form_params.insert("VoiceApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_caller_id_lookup {
        local_var_form_params.insert("VoiceCallerIdLookup", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_receive_mode {
        local_var_form_params.insert("VoiceReceiveMode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateIncomingPhoneNumberMobileSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateIncomingPhoneNumberMobileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_incoming_phone_number_toll_free(configuration: &configuration::Configuration, params: CreateIncomingPhoneNumberTollFreeParams) -> Result<ResponseContent<CreateIncomingPhoneNumberTollFreeSuccess>, Error<CreateIncomingPhoneNumberTollFreeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let phone_number = params.phone_number;
    let address_sid = params.address_sid;
    let api_version = params.api_version;
    let bundle_sid = params.bundle_sid;
    let emergency_address_sid = params.emergency_address_sid;
    let emergency_status = params.emergency_status;
    let friendly_name = params.friendly_name;
    let identity_sid = params.identity_sid;
    let sms_application_sid = params.sms_application_sid;
    let sms_fallback_method = params.sms_fallback_method;
    let sms_fallback_url = params.sms_fallback_url;
    let sms_method = params.sms_method;
    let sms_url = params.sms_url;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let trunk_sid = params.trunk_sid;
    let voice_application_sid = params.voice_application_sid;
    let voice_caller_id_lookup = params.voice_caller_id_lookup;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_receive_mode = params.voice_receive_mode;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = address_sid {
        local_var_form_params.insert("AddressSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = api_version {
        local_var_form_params.insert("ApiVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = bundle_sid {
        local_var_form_params.insert("BundleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_address_sid {
        local_var_form_params.insert("EmergencyAddressSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_status {
        local_var_form_params.insert("EmergencyStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = identity_sid {
        local_var_form_params.insert("IdentitySid", local_var_param_value.to_string());
    }
    local_var_form_params.insert("PhoneNumber", phone_number.to_string());
    if let Some(local_var_param_value) = sms_application_sid {
        local_var_form_params.insert("SmsApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_method {
        local_var_form_params.insert("SmsFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_url {
        local_var_form_params.insert("SmsFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_method {
        local_var_form_params.insert("SmsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_url {
        local_var_form_params.insert("SmsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trunk_sid {
        local_var_form_params.insert("TrunkSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_application_sid {
        local_var_form_params.insert("VoiceApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_caller_id_lookup {
        local_var_form_params.insert("VoiceCallerIdLookup", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_receive_mode {
        local_var_form_params.insert("VoiceReceiveMode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateIncomingPhoneNumberTollFreeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateIncomingPhoneNumberTollFreeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Send a message from the account used to make the request
pub async fn create_message(configuration: &configuration::Configuration, params: CreateMessageParams) -> Result<ResponseContent<CreateMessageSuccess>, Error<CreateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let to = params.to;
    let address_retention = params.address_retention;
    let application_sid = params.application_sid;
    let attempt = params.attempt;
    let body = params.body;
    let content_retention = params.content_retention;
    let force_delivery = params.force_delivery;
    let from = params.from;
    let max_price = params.max_price;
    let media_url = params.media_url;
    let messaging_service_sid = params.messaging_service_sid;
    let persistent_action = params.persistent_action;
    let provide_feedback = params.provide_feedback;
    let smart_encoded = params.smart_encoded;
    let status_callback = params.status_callback;
    let validity_period = params.validity_period;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Messages.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = address_retention {
        local_var_form_params.insert("AddressRetention", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = application_sid {
        local_var_form_params.insert("ApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = attempt {
        local_var_form_params.insert("Attempt", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = content_retention {
        local_var_form_params.insert("ContentRetention", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = force_delivery {
        local_var_form_params.insert("ForceDelivery", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = from {
        local_var_form_params.insert("From", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = max_price {
        local_var_form_params.insert("MaxPrice", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = media_url {
        local_var_form_params.insert("MediaUrl", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = messaging_service_sid {
        local_var_form_params.insert("MessagingServiceSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = persistent_action {
        local_var_form_params.insert("PersistentAction", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = provide_feedback {
        local_var_form_params.insert("ProvideFeedback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = smart_encoded {
        local_var_form_params.insert("SmartEncoded", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    local_var_form_params.insert("To", to.to_string());
    if let Some(local_var_param_value) = validity_period {
        local_var_form_params.insert("ValidityPeriod", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_message_feedback(configuration: &configuration::Configuration, params: CreateMessageFeedbackParams) -> Result<ResponseContent<CreateMessageFeedbackSuccess>, Error<CreateMessageFeedbackError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let message_sid = params.message_sid;
    let outcome = params.outcome;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Feedback.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), MessageSid=crate::apis::urlencode(message_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = outcome {
        local_var_form_params.insert("Outcome", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMessageFeedbackSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMessageFeedbackError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_new_key(configuration: &configuration::Configuration, params: CreateNewKeyParams) -> Result<ResponseContent<CreateNewKeySuccess>, Error<CreateNewKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Keys.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateNewKeySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateNewKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Signing Key for the account making the request.
pub async fn create_new_signing_key(configuration: &configuration::Configuration, params: CreateNewSigningKeyParams) -> Result<ResponseContent<CreateNewSigningKeySuccess>, Error<CreateNewSigningKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SigningKeys.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateNewSigningKeySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateNewSigningKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_participant(configuration: &configuration::Configuration, params: CreateParticipantParams) -> Result<ResponseContent<CreateParticipantSuccess>, Error<CreateParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let from = params.from;
    let to = params.to;
    let beep = params.beep;
    let byoc = params.byoc;
    let call_reason = params.call_reason;
    let call_sid_to_coach = params.call_sid_to_coach;
    let caller_id = params.caller_id;
    let coaching = params.coaching;
    let conference_record = params.conference_record;
    let conference_recording_status_callback = params.conference_recording_status_callback;
    let conference_recording_status_callback_event = params.conference_recording_status_callback_event;
    let conference_recording_status_callback_method = params.conference_recording_status_callback_method;
    let conference_status_callback = params.conference_status_callback;
    let conference_status_callback_event = params.conference_status_callback_event;
    let conference_status_callback_method = params.conference_status_callback_method;
    let conference_trim = params.conference_trim;
    let early_media = params.early_media;
    let end_conference_on_exit = params.end_conference_on_exit;
    let jitter_buffer_size = params.jitter_buffer_size;
    let label = params.label;
    let max_participants = params.max_participants;
    let muted = params.muted;
    let record = params.record;
    let recording_channels = params.recording_channels;
    let recording_status_callback = params.recording_status_callback;
    let recording_status_callback_event = params.recording_status_callback_event;
    let recording_status_callback_method = params.recording_status_callback_method;
    let recording_track = params.recording_track;
    let region = params.region;
    let sip_auth_password = params.sip_auth_password;
    let sip_auth_username = params.sip_auth_username;
    let start_conference_on_enter = params.start_conference_on_enter;
    let status_callback = params.status_callback;
    let status_callback_event = params.status_callback_event;
    let status_callback_method = params.status_callback_method;
    let time_limit = params.time_limit;
    let timeout = params.timeout;
    let wait_method = params.wait_method;
    let wait_url = params.wait_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = beep {
        local_var_form_params.insert("Beep", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = byoc {
        local_var_form_params.insert("Byoc", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_reason {
        local_var_form_params.insert("CallReason", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_sid_to_coach {
        local_var_form_params.insert("CallSidToCoach", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = caller_id {
        local_var_form_params.insert("CallerId", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = coaching {
        local_var_form_params.insert("Coaching", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_record {
        local_var_form_params.insert("ConferenceRecord", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_recording_status_callback {
        local_var_form_params.insert("ConferenceRecordingStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_recording_status_callback_event {
        local_var_form_params.insert("ConferenceRecordingStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = conference_recording_status_callback_method {
        local_var_form_params.insert("ConferenceRecordingStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback {
        local_var_form_params.insert("ConferenceStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback_event {
        local_var_form_params.insert("ConferenceStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback_method {
        local_var_form_params.insert("ConferenceStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_trim {
        local_var_form_params.insert("ConferenceTrim", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = early_media {
        local_var_form_params.insert("EarlyMedia", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = end_conference_on_exit {
        local_var_form_params.insert("EndConferenceOnExit", local_var_param_value.to_string());
    }
    local_var_form_params.insert("From", from.to_string());
    if let Some(local_var_param_value) = jitter_buffer_size {
        local_var_form_params.insert("JitterBufferSize", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = label {
        local_var_form_params.insert("Label", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = max_participants {
        local_var_form_params.insert("MaxParticipants", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = muted {
        local_var_form_params.insert("Muted", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = record {
        local_var_form_params.insert("Record", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_channels {
        local_var_form_params.insert("RecordingChannels", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback {
        local_var_form_params.insert("RecordingStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback_event {
        local_var_form_params.insert("RecordingStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback_method {
        local_var_form_params.insert("RecordingStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_track {
        local_var_form_params.insert("RecordingTrack", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = region {
        local_var_form_params.insert("Region", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_auth_password {
        local_var_form_params.insert("SipAuthPassword", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_auth_username {
        local_var_form_params.insert("SipAuthUsername", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = start_conference_on_enter {
        local_var_form_params.insert("StartConferenceOnEnter", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_event {
        local_var_form_params.insert("StatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = time_limit {
        local_var_form_params.insert("TimeLimit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timeout {
        local_var_form_params.insert("Timeout", local_var_param_value.to_string());
    }
    local_var_form_params.insert("To", to.to_string());
    if let Some(local_var_param_value) = wait_method {
        local_var_form_params.insert("WaitMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_url {
        local_var_form_params.insert("WaitUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// create an instance of payments. This will start a new payments session
pub async fn create_payments(configuration: &configuration::Configuration, params: CreatePaymentsParams) -> Result<ResponseContent<CreatePaymentsSuccess>, Error<CreatePaymentsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let idempotency_key = params.idempotency_key;
    let status_callback = params.status_callback;
    let bank_account_type = params.bank_account_type;
    let charge_amount = params.charge_amount;
    let currency = params.currency;
    let description = params.description;
    let input = params.input;
    let min_postal_code_length = params.min_postal_code_length;
    let parameter = params.parameter;
    let payment_connector = params.payment_connector;
    let payment_method = params.payment_method;
    let postal_code = params.postal_code;
    let security_code = params.security_code;
    let timeout = params.timeout;
    let token_type = params.token_type;
    let valid_card_types = params.valid_card_types;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = bank_account_type {
        local_var_form_params.insert("BankAccountType", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = charge_amount {
        local_var_form_params.insert("ChargeAmount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = currency {
        local_var_form_params.insert("Currency", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = description {
        local_var_form_params.insert("Description", local_var_param_value.to_string());
    }
    local_var_form_params.insert("IdempotencyKey", idempotency_key.to_string());
    if let Some(local_var_param_value) = input {
        local_var_form_params.insert("Input", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = min_postal_code_length {
        local_var_form_params.insert("MinPostalCodeLength", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = parameter {
        local_var_form_params.insert("Parameter", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = payment_connector {
        local_var_form_params.insert("PaymentConnector", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = payment_method {
        local_var_form_params.insert("PaymentMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = postal_code {
        local_var_form_params.insert("PostalCode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = security_code {
        local_var_form_params.insert("SecurityCode", local_var_param_value.to_string());
    }
    local_var_form_params.insert("StatusCallback", status_callback.to_string());
    if let Some(local_var_param_value) = timeout {
        local_var_form_params.insert("Timeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = token_type {
        local_var_form_params.insert("TokenType", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = valid_card_types {
        local_var_form_params.insert("ValidCardTypes", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreatePaymentsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreatePaymentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a queue
pub async fn create_queue(configuration: &configuration::Configuration, params: CreateQueueParams) -> Result<ResponseContent<CreateQueueSuccess>, Error<CreateQueueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let friendly_name = params.friendly_name;
    let max_size = params.max_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Queues.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = max_size {
        local_var_form_params.insert("MaxSize", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateQueueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new credential list mapping resource
pub async fn create_sip_auth_calls_credential_list_mapping(configuration: &configuration::Configuration, params: CreateSipAuthCallsCredentialListMappingParams) -> Result<ResponseContent<CreateSipAuthCallsCredentialListMappingSuccess>, Error<CreateSipAuthCallsCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let credential_list_sid = params.credential_list_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("CredentialListSid", credential_list_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSipAuthCallsCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSipAuthCallsCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new IP Access Control List mapping
pub async fn create_sip_auth_calls_ip_access_control_list_mapping(configuration: &configuration::Configuration, params: CreateSipAuthCallsIpAccessControlListMappingParams) -> Result<ResponseContent<CreateSipAuthCallsIpAccessControlListMappingSuccess>, Error<CreateSipAuthCallsIpAccessControlListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let ip_access_control_list_sid = params.ip_access_control_list_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("IpAccessControlListSid", ip_access_control_list_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSipAuthCallsIpAccessControlListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSipAuthCallsIpAccessControlListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new credential list mapping resource
pub async fn create_sip_auth_registrations_credential_list_mapping(configuration: &configuration::Configuration, params: CreateSipAuthRegistrationsCredentialListMappingParams) -> Result<ResponseContent<CreateSipAuthRegistrationsCredentialListMappingSuccess>, Error<CreateSipAuthRegistrationsCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let credential_list_sid = params.credential_list_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("CredentialListSid", credential_list_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSipAuthRegistrationsCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSipAuthRegistrationsCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new credential resource.
pub async fn create_sip_credential(configuration: &configuration::Configuration, params: CreateSipCredentialParams) -> Result<ResponseContent<CreateSipCredentialSuccess>, Error<CreateSipCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let credential_list_sid = params.credential_list_sid;
    let password = params.password;
    let username = params.username;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CredentialListSid=crate::apis::urlencode(credential_list_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Password", password.to_string());
    local_var_form_params.insert("Username", username.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSipCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSipCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a Credential List
pub async fn create_sip_credential_list(configuration: &configuration::Configuration, params: CreateSipCredentialListParams) -> Result<ResponseContent<CreateSipCredentialListSuccess>, Error<CreateSipCredentialListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSipCredentialListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSipCredentialListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a CredentialListMapping resource for an account.
pub async fn create_sip_credential_list_mapping(configuration: &configuration::Configuration, params: CreateSipCredentialListMappingParams) -> Result<ResponseContent<CreateSipCredentialListMappingSuccess>, Error<CreateSipCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let credential_list_sid = params.credential_list_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("CredentialListSid", credential_list_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSipCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSipCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Domain
pub async fn create_sip_domain(configuration: &configuration::Configuration, params: CreateSipDomainParams) -> Result<ResponseContent<CreateSipDomainSuccess>, Error<CreateSipDomainError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_name = params.domain_name;
    let byoc_trunk_sid = params.byoc_trunk_sid;
    let emergency_caller_sid = params.emergency_caller_sid;
    let emergency_calling_enabled = params.emergency_calling_enabled;
    let friendly_name = params.friendly_name;
    let secure = params.secure;
    let sip_registration = params.sip_registration;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_status_callback_method = params.voice_status_callback_method;
    let voice_status_callback_url = params.voice_status_callback_url;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = byoc_trunk_sid {
        local_var_form_params.insert("ByocTrunkSid", local_var_param_value.to_string());
    }
    local_var_form_params.insert("DomainName", domain_name.to_string());
    if let Some(local_var_param_value) = emergency_caller_sid {
        local_var_form_params.insert("EmergencyCallerSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_calling_enabled {
        local_var_form_params.insert("EmergencyCallingEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secure {
        local_var_form_params.insert("Secure", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_registration {
        local_var_form_params.insert("SipRegistration", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_status_callback_method {
        local_var_form_params.insert("VoiceStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_status_callback_url {
        local_var_form_params.insert("VoiceStatusCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSipDomainSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSipDomainError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new IpAccessControlList resource
pub async fn create_sip_ip_access_control_list(configuration: &configuration::Configuration, params: CreateSipIpAccessControlListParams) -> Result<ResponseContent<CreateSipIpAccessControlListSuccess>, Error<CreateSipIpAccessControlListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSipIpAccessControlListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSipIpAccessControlListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new IpAccessControlListMapping resource.
pub async fn create_sip_ip_access_control_list_mapping(configuration: &configuration::Configuration, params: CreateSipIpAccessControlListMappingParams) -> Result<ResponseContent<CreateSipIpAccessControlListMappingSuccess>, Error<CreateSipIpAccessControlListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let ip_access_control_list_sid = params.ip_access_control_list_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("IpAccessControlListSid", ip_access_control_list_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSipIpAccessControlListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSipIpAccessControlListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new IpAddress resource.
pub async fn create_sip_ip_address(configuration: &configuration::Configuration, params: CreateSipIpAddressParams) -> Result<ResponseContent<CreateSipIpAddressSuccess>, Error<CreateSipIpAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let ip_access_control_list_sid = params.ip_access_control_list_sid;
    let friendly_name = params.friendly_name;
    let ip_address = params.ip_address;
    let cidr_prefix_length = params.cidr_prefix_length;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), IpAccessControlListSid=crate::apis::urlencode(ip_access_control_list_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = cidr_prefix_length {
        local_var_form_params.insert("CidrPrefixLength", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("IpAddress", ip_address.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSipIpAddressSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSipIpAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new token for ICE servers
pub async fn create_token(configuration: &configuration::Configuration, params: CreateTokenParams) -> Result<ResponseContent<CreateTokenSuccess>, Error<CreateTokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Tokens.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateTokenSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new UsageTrigger
pub async fn create_usage_trigger(configuration: &configuration::Configuration, params: CreateUsageTriggerParams) -> Result<ResponseContent<CreateUsageTriggerSuccess>, Error<CreateUsageTriggerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let callback_url = params.callback_url;
    let trigger_value = params.trigger_value;
    let usage_category = params.usage_category;
    let callback_method = params.callback_method;
    let friendly_name = params.friendly_name;
    let recurring = params.recurring;
    let trigger_by = params.trigger_by;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = callback_method {
        local_var_form_params.insert("CallbackMethod", local_var_param_value.to_string());
    }
    local_var_form_params.insert("CallbackUrl", callback_url.to_string());
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recurring {
        local_var_form_params.insert("Recurring", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trigger_by {
        local_var_form_params.insert("TriggerBy", local_var_param_value.to_string());
    }
    local_var_form_params.insert("TriggerValue", trigger_value.to_string());
    local_var_form_params.insert("UsageCategory", usage_category.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateUsageTriggerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateUsageTriggerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_validation_request(configuration: &configuration::Configuration, params: CreateValidationRequestParams) -> Result<ResponseContent<CreateValidationRequestSuccess>, Error<CreateValidationRequestError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let phone_number = params.phone_number;
    let call_delay = params.call_delay;
    let extension = params.extension;
    let friendly_name = params.friendly_name;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = call_delay {
        local_var_form_params.insert("CallDelay", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = extension {
        local_var_form_params.insert("Extension", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("PhoneNumber", phone_number.to_string());
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateValidationRequestSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateValidationRequestError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_address(configuration: &configuration::Configuration, params: DeleteAddressParams) -> Result<ResponseContent<DeleteAddressSuccess>, Error<DeleteAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteAddressSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete the application by the specified application sid
pub async fn delete_application(configuration: &configuration::Configuration, params: DeleteApplicationParams) -> Result<ResponseContent<DeleteApplicationSuccess>, Error<DeleteApplicationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteApplicationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteApplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a Call record from your account. Once the record is deleted, it will no longer appear in the API and Account Portal logs.
pub async fn delete_call(configuration: &configuration::Configuration, params: DeleteCallParams) -> Result<ResponseContent<DeleteCallSuccess>, Error<DeleteCallError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCallSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCallError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a FeedbackSummary resource from a call
pub async fn delete_call_feedback_summary(configuration: &configuration::Configuration, params: DeleteCallFeedbackSummaryParams) -> Result<ResponseContent<DeleteCallFeedbackSummarySuccess>, Error<DeleteCallFeedbackSummaryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCallFeedbackSummarySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCallFeedbackSummaryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a recording from your account
pub async fn delete_call_recording(configuration: &configuration::Configuration, params: DeleteCallRecordingParams) -> Result<ResponseContent<DeleteCallRecordingSuccess>, Error<DeleteCallRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCallRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCallRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a recording from your account
pub async fn delete_conference_recording(configuration: &configuration::Configuration, params: DeleteConferenceRecordingParams) -> Result<ResponseContent<DeleteConferenceRecordingSuccess>, Error<DeleteConferenceRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteConferenceRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteConferenceRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an instance of a connect-app
pub async fn delete_connect_app(configuration: &configuration::Configuration, params: DeleteConnectAppParams) -> Result<ResponseContent<DeleteConnectAppSuccess>, Error<DeleteConnectAppError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteConnectAppSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteConnectAppError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a phone-numbers belonging to the account used to make the request.
pub async fn delete_incoming_phone_number(configuration: &configuration::Configuration, params: DeleteIncomingPhoneNumberParams) -> Result<ResponseContent<DeleteIncomingPhoneNumberSuccess>, Error<DeleteIncomingPhoneNumberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteIncomingPhoneNumberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteIncomingPhoneNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove the assignment of an Add-on installation from the Number specified.
pub async fn delete_incoming_phone_number_assigned_add_on(configuration: &configuration::Configuration, params: DeleteIncomingPhoneNumberAssignedAddOnParams) -> Result<ResponseContent<DeleteIncomingPhoneNumberAssignedAddOnSuccess>, Error<DeleteIncomingPhoneNumberAssignedAddOnError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let resource_sid = params.resource_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ResourceSid=crate::apis::urlencode(resource_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteIncomingPhoneNumberAssignedAddOnSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteIncomingPhoneNumberAssignedAddOnError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_key(configuration: &configuration::Configuration, params: DeleteKeyParams) -> Result<ResponseContent<DeleteKeySuccess>, Error<DeleteKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteKeySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete media from your account. Once delete, you will no longer be billed
pub async fn delete_media(configuration: &configuration::Configuration, params: DeleteMediaParams) -> Result<ResponseContent<DeleteMediaSuccess>, Error<DeleteMediaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let message_sid = params.message_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), MessageSid=crate::apis::urlencode(message_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMediaSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMediaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a message record from your account
pub async fn delete_message(configuration: &configuration::Configuration, params: DeleteMessageParams) -> Result<ResponseContent<DeleteMessageSuccess>, Error<DeleteMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete the caller-id specified from the account
pub async fn delete_outgoing_caller_id(configuration: &configuration::Configuration, params: DeleteOutgoingCallerIdParams) -> Result<ResponseContent<DeleteOutgoingCallerIdSuccess>, Error<DeleteOutgoingCallerIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteOutgoingCallerIdSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteOutgoingCallerIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Kick a participant from a given conference
pub async fn delete_participant(configuration: &configuration::Configuration, params: DeleteParticipantParams) -> Result<ResponseContent<DeleteParticipantSuccess>, Error<DeleteParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let call_sid = params.call_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an empty queue
pub async fn delete_queue(configuration: &configuration::Configuration, params: DeleteQueueParams) -> Result<ResponseContent<DeleteQueueSuccess>, Error<DeleteQueueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteQueueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a recording from your account
pub async fn delete_recording(configuration: &configuration::Configuration, params: DeleteRecordingParams) -> Result<ResponseContent<DeleteRecordingSuccess>, Error<DeleteRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a result and purge all associated Payloads
pub async fn delete_recording_add_on_result(configuration: &configuration::Configuration, params: DeleteRecordingAddOnResultParams) -> Result<ResponseContent<DeleteRecordingAddOnResultSuccess>, Error<DeleteRecordingAddOnResultError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let reference_sid = params.reference_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ReferenceSid=crate::apis::urlencode(reference_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRecordingAddOnResultSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRecordingAddOnResultError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a payload from the result along with all associated Data
pub async fn delete_recording_add_on_result_payload(configuration: &configuration::Configuration, params: DeleteRecordingAddOnResultPayloadParams) -> Result<ResponseContent<DeleteRecordingAddOnResultPayloadSuccess>, Error<DeleteRecordingAddOnResultPayloadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let reference_sid = params.reference_sid;
    let add_on_result_sid = params.add_on_result_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ReferenceSid=crate::apis::urlencode(reference_sid), AddOnResultSid=crate::apis::urlencode(add_on_result_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRecordingAddOnResultPayloadSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRecordingAddOnResultPayloadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_recording_transcription(configuration: &configuration::Configuration, params: DeleteRecordingTranscriptionParams) -> Result<ResponseContent<DeleteRecordingTranscriptionSuccess>, Error<DeleteRecordingTranscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let recording_sid = params.recording_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), RecordingSid=crate::apis::urlencode(recording_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRecordingTranscriptionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRecordingTranscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_signing_key(configuration: &configuration::Configuration, params: DeleteSigningKeyParams) -> Result<ResponseContent<DeleteSigningKeySuccess>, Error<DeleteSigningKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSigningKeySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSigningKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a credential list mapping from the requested domain
pub async fn delete_sip_auth_calls_credential_list_mapping(configuration: &configuration::Configuration, params: DeleteSipAuthCallsCredentialListMappingParams) -> Result<ResponseContent<DeleteSipAuthCallsCredentialListMappingSuccess>, Error<DeleteSipAuthCallsCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSipAuthCallsCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSipAuthCallsCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an IP Access Control List mapping from the requested domain
pub async fn delete_sip_auth_calls_ip_access_control_list_mapping(configuration: &configuration::Configuration, params: DeleteSipAuthCallsIpAccessControlListMappingParams) -> Result<ResponseContent<DeleteSipAuthCallsIpAccessControlListMappingSuccess>, Error<DeleteSipAuthCallsIpAccessControlListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSipAuthCallsIpAccessControlListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSipAuthCallsIpAccessControlListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a credential list mapping from the requested domain
pub async fn delete_sip_auth_registrations_credential_list_mapping(configuration: &configuration::Configuration, params: DeleteSipAuthRegistrationsCredentialListMappingParams) -> Result<ResponseContent<DeleteSipAuthRegistrationsCredentialListMappingSuccess>, Error<DeleteSipAuthRegistrationsCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSipAuthRegistrationsCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSipAuthRegistrationsCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a credential resource.
pub async fn delete_sip_credential(configuration: &configuration::Configuration, params: DeleteSipCredentialParams) -> Result<ResponseContent<DeleteSipCredentialSuccess>, Error<DeleteSipCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let credential_list_sid = params.credential_list_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CredentialListSid=crate::apis::urlencode(credential_list_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSipCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSipCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a Credential List
pub async fn delete_sip_credential_list(configuration: &configuration::Configuration, params: DeleteSipCredentialListParams) -> Result<ResponseContent<DeleteSipCredentialListSuccess>, Error<DeleteSipCredentialListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSipCredentialListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSipCredentialListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a CredentialListMapping resource from an account.
pub async fn delete_sip_credential_list_mapping(configuration: &configuration::Configuration, params: DeleteSipCredentialListMappingParams) -> Result<ResponseContent<DeleteSipCredentialListMappingSuccess>, Error<DeleteSipCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSipCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSipCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an instance of a Domain
pub async fn delete_sip_domain(configuration: &configuration::Configuration, params: DeleteSipDomainParams) -> Result<ResponseContent<DeleteSipDomainSuccess>, Error<DeleteSipDomainError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSipDomainSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSipDomainError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an IpAccessControlList from the requested account
pub async fn delete_sip_ip_access_control_list(configuration: &configuration::Configuration, params: DeleteSipIpAccessControlListParams) -> Result<ResponseContent<DeleteSipIpAccessControlListSuccess>, Error<DeleteSipIpAccessControlListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSipIpAccessControlListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSipIpAccessControlListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an IpAccessControlListMapping resource.
pub async fn delete_sip_ip_access_control_list_mapping(configuration: &configuration::Configuration, params: DeleteSipIpAccessControlListMappingParams) -> Result<ResponseContent<DeleteSipIpAccessControlListMappingSuccess>, Error<DeleteSipIpAccessControlListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSipIpAccessControlListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSipIpAccessControlListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an IpAddress resource.
pub async fn delete_sip_ip_address(configuration: &configuration::Configuration, params: DeleteSipIpAddressParams) -> Result<ResponseContent<DeleteSipIpAddressSuccess>, Error<DeleteSipIpAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let ip_access_control_list_sid = params.ip_access_control_list_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), IpAccessControlListSid=crate::apis::urlencode(ip_access_control_list_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSipIpAddressSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSipIpAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a transcription from the account used to make the request
pub async fn delete_transcription(configuration: &configuration::Configuration, params: DeleteTranscriptionParams) -> Result<ResponseContent<DeleteTranscriptionSuccess>, Error<DeleteTranscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteTranscriptionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteTranscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_usage_trigger(configuration: &configuration::Configuration, params: DeleteUsageTriggerParams) -> Result<ResponseContent<DeleteUsageTriggerSuccess>, Error<DeleteUsageTriggerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUsageTriggerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUsageTriggerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the account specified by the provided Account Sid
pub async fn fetch_account(configuration: &configuration::Configuration, params: FetchAccountParams) -> Result<ResponseContent<FetchAccountSuccess>, Error<FetchAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{Sid}.json", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchAccountSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_address(configuration: &configuration::Configuration, params: FetchAddressParams) -> Result<ResponseContent<FetchAddressSuccess>, Error<FetchAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchAddressSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the application specified by the provided sid
pub async fn fetch_application(configuration: &configuration::Configuration, params: FetchApplicationParams) -> Result<ResponseContent<FetchApplicationSuccess>, Error<FetchApplicationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchApplicationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchApplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of an authorized-connect-app
pub async fn fetch_authorized_connect_app(configuration: &configuration::Configuration, params: FetchAuthorizedConnectAppParams) -> Result<ResponseContent<FetchAuthorizedConnectAppSuccess>, Error<FetchAuthorizedConnectAppError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let connect_app_sid = params.connect_app_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps/{ConnectAppSid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConnectAppSid=crate::apis::urlencode(connect_app_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchAuthorizedConnectAppSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchAuthorizedConnectAppError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_available_phone_number_country(configuration: &configuration::Configuration, params: FetchAvailablePhoneNumberCountryParams) -> Result<ResponseContent<FetchAvailablePhoneNumberCountrySuccess>, Error<FetchAvailablePhoneNumberCountryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let country_code = params.country_code;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CountryCode=crate::apis::urlencode(country_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchAvailablePhoneNumberCountrySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchAvailablePhoneNumberCountryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the balance for an Account based on Account Sid. Balance changes may not be reflected immediately. Child accounts do not contain balance information
pub async fn fetch_balance(configuration: &configuration::Configuration, params: FetchBalanceParams) -> Result<ResponseContent<FetchBalanceSuccess>, Error<FetchBalanceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Balance.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchBalanceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchBalanceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the call specified by the provided Call SID
pub async fn fetch_call(configuration: &configuration::Configuration, params: FetchCallParams) -> Result<ResponseContent<FetchCallSuccess>, Error<FetchCallError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCallSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCallError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a Feedback resource from a call
pub async fn fetch_call_feedback(configuration: &configuration::Configuration, params: FetchCallFeedbackParams) -> Result<ResponseContent<FetchCallFeedbackSuccess>, Error<FetchCallFeedbackError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCallFeedbackSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCallFeedbackError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a FeedbackSummary resource from a call
pub async fn fetch_call_feedback_summary(configuration: &configuration::Configuration, params: FetchCallFeedbackSummaryParams) -> Result<ResponseContent<FetchCallFeedbackSummarySuccess>, Error<FetchCallFeedbackSummaryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCallFeedbackSummarySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCallFeedbackSummaryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_call_notification(configuration: &configuration::Configuration, params: FetchCallNotificationParams) -> Result<ResponseContent<FetchCallNotificationSuccess>, Error<FetchCallNotificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCallNotificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCallNotificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a recording for a call
pub async fn fetch_call_recording(configuration: &configuration::Configuration, params: FetchCallRecordingParams) -> Result<ResponseContent<FetchCallRecordingSuccess>, Error<FetchCallRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCallRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCallRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a conference
pub async fn fetch_conference(configuration: &configuration::Configuration, params: FetchConferenceParams) -> Result<ResponseContent<FetchConferenceSuccess>, Error<FetchConferenceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConferenceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConferenceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a recording for a call
pub async fn fetch_conference_recording(configuration: &configuration::Configuration, params: FetchConferenceRecordingParams) -> Result<ResponseContent<FetchConferenceRecordingSuccess>, Error<FetchConferenceRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConferenceRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConferenceRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a connect-app
pub async fn fetch_connect_app(configuration: &configuration::Configuration, params: FetchConnectAppParams) -> Result<ResponseContent<FetchConnectAppSuccess>, Error<FetchConnectAppError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConnectAppSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConnectAppError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an incoming-phone-number belonging to the account used to make the request.
pub async fn fetch_incoming_phone_number(configuration: &configuration::Configuration, params: FetchIncomingPhoneNumberParams) -> Result<ResponseContent<FetchIncomingPhoneNumberSuccess>, Error<FetchIncomingPhoneNumberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchIncomingPhoneNumberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchIncomingPhoneNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of an Add-on installation currently assigned to this Number.
pub async fn fetch_incoming_phone_number_assigned_add_on(configuration: &configuration::Configuration, params: FetchIncomingPhoneNumberAssignedAddOnParams) -> Result<ResponseContent<FetchIncomingPhoneNumberAssignedAddOnSuccess>, Error<FetchIncomingPhoneNumberAssignedAddOnError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let resource_sid = params.resource_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ResourceSid=crate::apis::urlencode(resource_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchIncomingPhoneNumberAssignedAddOnSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchIncomingPhoneNumberAssignedAddOnError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of an Extension for the Assigned Add-on.
pub async fn fetch_incoming_phone_number_assigned_add_on_extension(configuration: &configuration::Configuration, params: FetchIncomingPhoneNumberAssignedAddOnExtensionParams) -> Result<ResponseContent<FetchIncomingPhoneNumberAssignedAddOnExtensionSuccess>, Error<FetchIncomingPhoneNumberAssignedAddOnExtensionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let resource_sid = params.resource_sid;
    let assigned_add_on_sid = params.assigned_add_on_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ResourceSid=crate::apis::urlencode(resource_sid), AssignedAddOnSid=crate::apis::urlencode(assigned_add_on_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchIncomingPhoneNumberAssignedAddOnExtensionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchIncomingPhoneNumberAssignedAddOnExtensionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_key(configuration: &configuration::Configuration, params: FetchKeyParams) -> Result<ResponseContent<FetchKeySuccess>, Error<FetchKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchKeySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a single media instance belonging to the account used to make the request
pub async fn fetch_media(configuration: &configuration::Configuration, params: FetchMediaParams) -> Result<ResponseContent<FetchMediaSuccess>, Error<FetchMediaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let message_sid = params.message_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), MessageSid=crate::apis::urlencode(message_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMediaSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMediaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific member from the queue
pub async fn fetch_member(configuration: &configuration::Configuration, params: FetchMemberParams) -> Result<ResponseContent<FetchMemberSuccess>, Error<FetchMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let queue_sid = params.queue_sid;
    let call_sid = params.call_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), QueueSid=crate::apis::urlencode(queue_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a message belonging to the account used to make the request
pub async fn fetch_message(configuration: &configuration::Configuration, params: FetchMessageParams) -> Result<ResponseContent<FetchMessageSuccess>, Error<FetchMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a notification belonging to the account used to make the request
pub async fn fetch_notification(configuration: &configuration::Configuration, params: FetchNotificationParams) -> Result<ResponseContent<FetchNotificationSuccess>, Error<FetchNotificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Notifications/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchNotificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchNotificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an outgoing-caller-id belonging to the account used to make the request
pub async fn fetch_outgoing_caller_id(configuration: &configuration::Configuration, params: FetchOutgoingCallerIdParams) -> Result<ResponseContent<FetchOutgoingCallerIdSuccess>, Error<FetchOutgoingCallerIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchOutgoingCallerIdSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchOutgoingCallerIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a participant
pub async fn fetch_participant(configuration: &configuration::Configuration, params: FetchParticipantParams) -> Result<ResponseContent<FetchParticipantSuccess>, Error<FetchParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let call_sid = params.call_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a queue identified by the QueueSid
pub async fn fetch_queue(configuration: &configuration::Configuration, params: FetchQueueParams) -> Result<ResponseContent<FetchQueueSuccess>, Error<FetchQueueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchQueueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a recording
pub async fn fetch_recording(configuration: &configuration::Configuration, params: FetchRecordingParams) -> Result<ResponseContent<FetchRecordingSuccess>, Error<FetchRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of an AddOnResult
pub async fn fetch_recording_add_on_result(configuration: &configuration::Configuration, params: FetchRecordingAddOnResultParams) -> Result<ResponseContent<FetchRecordingAddOnResultSuccess>, Error<FetchRecordingAddOnResultError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let reference_sid = params.reference_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ReferenceSid=crate::apis::urlencode(reference_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRecordingAddOnResultSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRecordingAddOnResultError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a result payload
pub async fn fetch_recording_add_on_result_payload(configuration: &configuration::Configuration, params: FetchRecordingAddOnResultPayloadParams) -> Result<ResponseContent<FetchRecordingAddOnResultPayloadSuccess>, Error<FetchRecordingAddOnResultPayloadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let reference_sid = params.reference_sid;
    let add_on_result_sid = params.add_on_result_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ReferenceSid=crate::apis::urlencode(reference_sid), AddOnResultSid=crate::apis::urlencode(add_on_result_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRecordingAddOnResultPayloadSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRecordingAddOnResultPayloadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_recording_transcription(configuration: &configuration::Configuration, params: FetchRecordingTranscriptionParams) -> Result<ResponseContent<FetchRecordingTranscriptionSuccess>, Error<FetchRecordingTranscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let recording_sid = params.recording_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), RecordingSid=crate::apis::urlencode(recording_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRecordingTranscriptionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRecordingTranscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a short code
pub async fn fetch_short_code(configuration: &configuration::Configuration, params: FetchShortCodeParams) -> Result<ResponseContent<FetchShortCodeSuccess>, Error<FetchShortCodeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchShortCodeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchShortCodeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_signing_key(configuration: &configuration::Configuration, params: FetchSigningKeyParams) -> Result<ResponseContent<FetchSigningKeySuccess>, Error<FetchSigningKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSigningKeySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSigningKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific instance of a credential list mapping
pub async fn fetch_sip_auth_calls_credential_list_mapping(configuration: &configuration::Configuration, params: FetchSipAuthCallsCredentialListMappingParams) -> Result<ResponseContent<FetchSipAuthCallsCredentialListMappingSuccess>, Error<FetchSipAuthCallsCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSipAuthCallsCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSipAuthCallsCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific instance of an IP Access Control List mapping
pub async fn fetch_sip_auth_calls_ip_access_control_list_mapping(configuration: &configuration::Configuration, params: FetchSipAuthCallsIpAccessControlListMappingParams) -> Result<ResponseContent<FetchSipAuthCallsIpAccessControlListMappingSuccess>, Error<FetchSipAuthCallsIpAccessControlListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSipAuthCallsIpAccessControlListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSipAuthCallsIpAccessControlListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific instance of a credential list mapping
pub async fn fetch_sip_auth_registrations_credential_list_mapping(configuration: &configuration::Configuration, params: FetchSipAuthRegistrationsCredentialListMappingParams) -> Result<ResponseContent<FetchSipAuthRegistrationsCredentialListMappingSuccess>, Error<FetchSipAuthRegistrationsCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSipAuthRegistrationsCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSipAuthRegistrationsCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a single credential.
pub async fn fetch_sip_credential(configuration: &configuration::Configuration, params: FetchSipCredentialParams) -> Result<ResponseContent<FetchSipCredentialSuccess>, Error<FetchSipCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let credential_list_sid = params.credential_list_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CredentialListSid=crate::apis::urlencode(credential_list_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSipCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSipCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a Credential List
pub async fn fetch_sip_credential_list(configuration: &configuration::Configuration, params: FetchSipCredentialListParams) -> Result<ResponseContent<FetchSipCredentialListSuccess>, Error<FetchSipCredentialListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSipCredentialListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSipCredentialListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a single CredentialListMapping resource from an account.
pub async fn fetch_sip_credential_list_mapping(configuration: &configuration::Configuration, params: FetchSipCredentialListMappingParams) -> Result<ResponseContent<FetchSipCredentialListMappingSuccess>, Error<FetchSipCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSipCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSipCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a Domain
pub async fn fetch_sip_domain(configuration: &configuration::Configuration, params: FetchSipDomainParams) -> Result<ResponseContent<FetchSipDomainSuccess>, Error<FetchSipDomainError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSipDomainSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSipDomainError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific instance of an IpAccessControlList
pub async fn fetch_sip_ip_access_control_list(configuration: &configuration::Configuration, params: FetchSipIpAccessControlListParams) -> Result<ResponseContent<FetchSipIpAccessControlListSuccess>, Error<FetchSipIpAccessControlListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSipIpAccessControlListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSipIpAccessControlListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an IpAccessControlListMapping resource.
pub async fn fetch_sip_ip_access_control_list_mapping(configuration: &configuration::Configuration, params: FetchSipIpAccessControlListMappingParams) -> Result<ResponseContent<FetchSipIpAccessControlListMappingSuccess>, Error<FetchSipIpAccessControlListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSipIpAccessControlListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSipIpAccessControlListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Read one IpAddress resource.
pub async fn fetch_sip_ip_address(configuration: &configuration::Configuration, params: FetchSipIpAddressParams) -> Result<ResponseContent<FetchSipIpAddressSuccess>, Error<FetchSipIpAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let ip_access_control_list_sid = params.ip_access_control_list_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), IpAccessControlListSid=crate::apis::urlencode(ip_access_control_list_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSipIpAddressSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSipIpAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a Transcription
pub async fn fetch_transcription(configuration: &configuration::Configuration, params: FetchTranscriptionParams) -> Result<ResponseContent<FetchTranscriptionSuccess>, Error<FetchTranscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTranscriptionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTranscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch and instance of a usage-trigger
pub async fn fetch_usage_trigger(configuration: &configuration::Configuration, params: FetchUsageTriggerParams) -> Result<ResponseContent<FetchUsageTriggerSuccess>, Error<FetchUsageTriggerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUsageTriggerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUsageTriggerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves a collection of Accounts belonging to the account used to make the request
pub async fn list_account(configuration: &configuration::Configuration, params: ListAccountParams) -> Result<ResponseContent<ListAccountSuccess>, Error<ListAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let status = params.status;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts.json", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAccountSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_address(configuration: &configuration::Configuration, params: ListAddressParams) -> Result<ResponseContent<ListAddressSuccess>, Error<ListAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let customer_name = params.customer_name;
    let friendly_name = params.friendly_name;
    let iso_country = params.iso_country;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Addresses.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = customer_name {
        local_var_req_builder = local_var_req_builder.query(&[("CustomerName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iso_country {
        local_var_req_builder = local_var_req_builder.query(&[("IsoCountry", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAddressSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of applications representing an application within the requesting account
pub async fn list_application(configuration: &configuration::Configuration, params: ListApplicationParams) -> Result<ResponseContent<ListApplicationSuccess>, Error<ListApplicationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let friendly_name = params.friendly_name;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Applications.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListApplicationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListApplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of authorized-connect-apps belonging to the account used to make the request
pub async fn list_authorized_connect_app(configuration: &configuration::Configuration, params: ListAuthorizedConnectAppParams) -> Result<ResponseContent<ListAuthorizedConnectAppSuccess>, Error<ListAuthorizedConnectAppError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAuthorizedConnectAppSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAuthorizedConnectAppError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_available_phone_number_country(configuration: &configuration::Configuration, params: ListAvailablePhoneNumberCountryParams) -> Result<ResponseContent<ListAvailablePhoneNumberCountrySuccess>, Error<ListAvailablePhoneNumberCountryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAvailablePhoneNumberCountrySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAvailablePhoneNumberCountryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_available_phone_number_local(configuration: &configuration::Configuration, params: ListAvailablePhoneNumberLocalParams) -> Result<ResponseContent<ListAvailablePhoneNumberLocalSuccess>, Error<ListAvailablePhoneNumberLocalError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let country_code = params.country_code;
    let area_code = params.area_code;
    let contains = params.contains;
    let sms_enabled = params.sms_enabled;
    let mms_enabled = params.mms_enabled;
    let voice_enabled = params.voice_enabled;
    let exclude_all_address_required = params.exclude_all_address_required;
    let exclude_local_address_required = params.exclude_local_address_required;
    let exclude_foreign_address_required = params.exclude_foreign_address_required;
    let beta = params.beta;
    let near_number = params.near_number;
    let near_lat_long = params.near_lat_long;
    let distance = params.distance;
    let in_postal_code = params.in_postal_code;
    let in_region = params.in_region;
    let in_rate_center = params.in_rate_center;
    let in_lata = params.in_lata;
    let in_locality = params.in_locality;
    let fax_enabled = params.fax_enabled;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Local.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CountryCode=crate::apis::urlencode(country_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = area_code {
        local_var_req_builder = local_var_req_builder.query(&[("AreaCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = contains {
        local_var_req_builder = local_var_req_builder.query(&[("Contains", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("SmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("MmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = voice_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("VoiceEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_all_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeAllAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_local_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeLocalAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_foreign_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeForeignAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_number {
        local_var_req_builder = local_var_req_builder.query(&[("NearNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_lat_long {
        local_var_req_builder = local_var_req_builder.query(&[("NearLatLong", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = distance {
        local_var_req_builder = local_var_req_builder.query(&[("Distance", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_postal_code {
        local_var_req_builder = local_var_req_builder.query(&[("InPostalCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_region {
        local_var_req_builder = local_var_req_builder.query(&[("InRegion", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_rate_center {
        local_var_req_builder = local_var_req_builder.query(&[("InRateCenter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_lata {
        local_var_req_builder = local_var_req_builder.query(&[("InLata", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_locality {
        local_var_req_builder = local_var_req_builder.query(&[("InLocality", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fax_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("FaxEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAvailablePhoneNumberLocalSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAvailablePhoneNumberLocalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_available_phone_number_machine_to_machine(configuration: &configuration::Configuration, params: ListAvailablePhoneNumberMachineToMachineParams) -> Result<ResponseContent<ListAvailablePhoneNumberMachineToMachineSuccess>, Error<ListAvailablePhoneNumberMachineToMachineError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let country_code = params.country_code;
    let area_code = params.area_code;
    let contains = params.contains;
    let sms_enabled = params.sms_enabled;
    let mms_enabled = params.mms_enabled;
    let voice_enabled = params.voice_enabled;
    let exclude_all_address_required = params.exclude_all_address_required;
    let exclude_local_address_required = params.exclude_local_address_required;
    let exclude_foreign_address_required = params.exclude_foreign_address_required;
    let beta = params.beta;
    let near_number = params.near_number;
    let near_lat_long = params.near_lat_long;
    let distance = params.distance;
    let in_postal_code = params.in_postal_code;
    let in_region = params.in_region;
    let in_rate_center = params.in_rate_center;
    let in_lata = params.in_lata;
    let in_locality = params.in_locality;
    let fax_enabled = params.fax_enabled;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/MachineToMachine.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CountryCode=crate::apis::urlencode(country_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = area_code {
        local_var_req_builder = local_var_req_builder.query(&[("AreaCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = contains {
        local_var_req_builder = local_var_req_builder.query(&[("Contains", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("SmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("MmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = voice_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("VoiceEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_all_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeAllAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_local_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeLocalAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_foreign_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeForeignAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_number {
        local_var_req_builder = local_var_req_builder.query(&[("NearNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_lat_long {
        local_var_req_builder = local_var_req_builder.query(&[("NearLatLong", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = distance {
        local_var_req_builder = local_var_req_builder.query(&[("Distance", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_postal_code {
        local_var_req_builder = local_var_req_builder.query(&[("InPostalCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_region {
        local_var_req_builder = local_var_req_builder.query(&[("InRegion", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_rate_center {
        local_var_req_builder = local_var_req_builder.query(&[("InRateCenter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_lata {
        local_var_req_builder = local_var_req_builder.query(&[("InLata", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_locality {
        local_var_req_builder = local_var_req_builder.query(&[("InLocality", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fax_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("FaxEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAvailablePhoneNumberMachineToMachineSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAvailablePhoneNumberMachineToMachineError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_available_phone_number_mobile(configuration: &configuration::Configuration, params: ListAvailablePhoneNumberMobileParams) -> Result<ResponseContent<ListAvailablePhoneNumberMobileSuccess>, Error<ListAvailablePhoneNumberMobileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let country_code = params.country_code;
    let area_code = params.area_code;
    let contains = params.contains;
    let sms_enabled = params.sms_enabled;
    let mms_enabled = params.mms_enabled;
    let voice_enabled = params.voice_enabled;
    let exclude_all_address_required = params.exclude_all_address_required;
    let exclude_local_address_required = params.exclude_local_address_required;
    let exclude_foreign_address_required = params.exclude_foreign_address_required;
    let beta = params.beta;
    let near_number = params.near_number;
    let near_lat_long = params.near_lat_long;
    let distance = params.distance;
    let in_postal_code = params.in_postal_code;
    let in_region = params.in_region;
    let in_rate_center = params.in_rate_center;
    let in_lata = params.in_lata;
    let in_locality = params.in_locality;
    let fax_enabled = params.fax_enabled;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Mobile.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CountryCode=crate::apis::urlencode(country_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = area_code {
        local_var_req_builder = local_var_req_builder.query(&[("AreaCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = contains {
        local_var_req_builder = local_var_req_builder.query(&[("Contains", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("SmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("MmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = voice_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("VoiceEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_all_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeAllAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_local_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeLocalAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_foreign_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeForeignAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_number {
        local_var_req_builder = local_var_req_builder.query(&[("NearNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_lat_long {
        local_var_req_builder = local_var_req_builder.query(&[("NearLatLong", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = distance {
        local_var_req_builder = local_var_req_builder.query(&[("Distance", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_postal_code {
        local_var_req_builder = local_var_req_builder.query(&[("InPostalCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_region {
        local_var_req_builder = local_var_req_builder.query(&[("InRegion", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_rate_center {
        local_var_req_builder = local_var_req_builder.query(&[("InRateCenter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_lata {
        local_var_req_builder = local_var_req_builder.query(&[("InLata", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_locality {
        local_var_req_builder = local_var_req_builder.query(&[("InLocality", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fax_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("FaxEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAvailablePhoneNumberMobileSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAvailablePhoneNumberMobileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_available_phone_number_national(configuration: &configuration::Configuration, params: ListAvailablePhoneNumberNationalParams) -> Result<ResponseContent<ListAvailablePhoneNumberNationalSuccess>, Error<ListAvailablePhoneNumberNationalError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let country_code = params.country_code;
    let area_code = params.area_code;
    let contains = params.contains;
    let sms_enabled = params.sms_enabled;
    let mms_enabled = params.mms_enabled;
    let voice_enabled = params.voice_enabled;
    let exclude_all_address_required = params.exclude_all_address_required;
    let exclude_local_address_required = params.exclude_local_address_required;
    let exclude_foreign_address_required = params.exclude_foreign_address_required;
    let beta = params.beta;
    let near_number = params.near_number;
    let near_lat_long = params.near_lat_long;
    let distance = params.distance;
    let in_postal_code = params.in_postal_code;
    let in_region = params.in_region;
    let in_rate_center = params.in_rate_center;
    let in_lata = params.in_lata;
    let in_locality = params.in_locality;
    let fax_enabled = params.fax_enabled;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/National.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CountryCode=crate::apis::urlencode(country_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = area_code {
        local_var_req_builder = local_var_req_builder.query(&[("AreaCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = contains {
        local_var_req_builder = local_var_req_builder.query(&[("Contains", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("SmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("MmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = voice_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("VoiceEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_all_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeAllAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_local_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeLocalAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_foreign_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeForeignAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_number {
        local_var_req_builder = local_var_req_builder.query(&[("NearNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_lat_long {
        local_var_req_builder = local_var_req_builder.query(&[("NearLatLong", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = distance {
        local_var_req_builder = local_var_req_builder.query(&[("Distance", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_postal_code {
        local_var_req_builder = local_var_req_builder.query(&[("InPostalCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_region {
        local_var_req_builder = local_var_req_builder.query(&[("InRegion", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_rate_center {
        local_var_req_builder = local_var_req_builder.query(&[("InRateCenter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_lata {
        local_var_req_builder = local_var_req_builder.query(&[("InLata", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_locality {
        local_var_req_builder = local_var_req_builder.query(&[("InLocality", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fax_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("FaxEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAvailablePhoneNumberNationalSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAvailablePhoneNumberNationalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_available_phone_number_shared_cost(configuration: &configuration::Configuration, params: ListAvailablePhoneNumberSharedCostParams) -> Result<ResponseContent<ListAvailablePhoneNumberSharedCostSuccess>, Error<ListAvailablePhoneNumberSharedCostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let country_code = params.country_code;
    let area_code = params.area_code;
    let contains = params.contains;
    let sms_enabled = params.sms_enabled;
    let mms_enabled = params.mms_enabled;
    let voice_enabled = params.voice_enabled;
    let exclude_all_address_required = params.exclude_all_address_required;
    let exclude_local_address_required = params.exclude_local_address_required;
    let exclude_foreign_address_required = params.exclude_foreign_address_required;
    let beta = params.beta;
    let near_number = params.near_number;
    let near_lat_long = params.near_lat_long;
    let distance = params.distance;
    let in_postal_code = params.in_postal_code;
    let in_region = params.in_region;
    let in_rate_center = params.in_rate_center;
    let in_lata = params.in_lata;
    let in_locality = params.in_locality;
    let fax_enabled = params.fax_enabled;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/SharedCost.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CountryCode=crate::apis::urlencode(country_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = area_code {
        local_var_req_builder = local_var_req_builder.query(&[("AreaCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = contains {
        local_var_req_builder = local_var_req_builder.query(&[("Contains", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("SmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("MmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = voice_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("VoiceEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_all_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeAllAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_local_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeLocalAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_foreign_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeForeignAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_number {
        local_var_req_builder = local_var_req_builder.query(&[("NearNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_lat_long {
        local_var_req_builder = local_var_req_builder.query(&[("NearLatLong", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = distance {
        local_var_req_builder = local_var_req_builder.query(&[("Distance", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_postal_code {
        local_var_req_builder = local_var_req_builder.query(&[("InPostalCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_region {
        local_var_req_builder = local_var_req_builder.query(&[("InRegion", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_rate_center {
        local_var_req_builder = local_var_req_builder.query(&[("InRateCenter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_lata {
        local_var_req_builder = local_var_req_builder.query(&[("InLata", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_locality {
        local_var_req_builder = local_var_req_builder.query(&[("InLocality", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fax_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("FaxEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAvailablePhoneNumberSharedCostSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAvailablePhoneNumberSharedCostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_available_phone_number_toll_free(configuration: &configuration::Configuration, params: ListAvailablePhoneNumberTollFreeParams) -> Result<ResponseContent<ListAvailablePhoneNumberTollFreeSuccess>, Error<ListAvailablePhoneNumberTollFreeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let country_code = params.country_code;
    let area_code = params.area_code;
    let contains = params.contains;
    let sms_enabled = params.sms_enabled;
    let mms_enabled = params.mms_enabled;
    let voice_enabled = params.voice_enabled;
    let exclude_all_address_required = params.exclude_all_address_required;
    let exclude_local_address_required = params.exclude_local_address_required;
    let exclude_foreign_address_required = params.exclude_foreign_address_required;
    let beta = params.beta;
    let near_number = params.near_number;
    let near_lat_long = params.near_lat_long;
    let distance = params.distance;
    let in_postal_code = params.in_postal_code;
    let in_region = params.in_region;
    let in_rate_center = params.in_rate_center;
    let in_lata = params.in_lata;
    let in_locality = params.in_locality;
    let fax_enabled = params.fax_enabled;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/TollFree.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CountryCode=crate::apis::urlencode(country_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = area_code {
        local_var_req_builder = local_var_req_builder.query(&[("AreaCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = contains {
        local_var_req_builder = local_var_req_builder.query(&[("Contains", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("SmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("MmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = voice_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("VoiceEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_all_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeAllAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_local_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeLocalAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_foreign_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeForeignAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_number {
        local_var_req_builder = local_var_req_builder.query(&[("NearNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_lat_long {
        local_var_req_builder = local_var_req_builder.query(&[("NearLatLong", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = distance {
        local_var_req_builder = local_var_req_builder.query(&[("Distance", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_postal_code {
        local_var_req_builder = local_var_req_builder.query(&[("InPostalCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_region {
        local_var_req_builder = local_var_req_builder.query(&[("InRegion", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_rate_center {
        local_var_req_builder = local_var_req_builder.query(&[("InRateCenter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_lata {
        local_var_req_builder = local_var_req_builder.query(&[("InLata", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_locality {
        local_var_req_builder = local_var_req_builder.query(&[("InLocality", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fax_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("FaxEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAvailablePhoneNumberTollFreeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAvailablePhoneNumberTollFreeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_available_phone_number_voip(configuration: &configuration::Configuration, params: ListAvailablePhoneNumberVoipParams) -> Result<ResponseContent<ListAvailablePhoneNumberVoipSuccess>, Error<ListAvailablePhoneNumberVoipError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let country_code = params.country_code;
    let area_code = params.area_code;
    let contains = params.contains;
    let sms_enabled = params.sms_enabled;
    let mms_enabled = params.mms_enabled;
    let voice_enabled = params.voice_enabled;
    let exclude_all_address_required = params.exclude_all_address_required;
    let exclude_local_address_required = params.exclude_local_address_required;
    let exclude_foreign_address_required = params.exclude_foreign_address_required;
    let beta = params.beta;
    let near_number = params.near_number;
    let near_lat_long = params.near_lat_long;
    let distance = params.distance;
    let in_postal_code = params.in_postal_code;
    let in_region = params.in_region;
    let in_rate_center = params.in_rate_center;
    let in_lata = params.in_lata;
    let in_locality = params.in_locality;
    let fax_enabled = params.fax_enabled;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Voip.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CountryCode=crate::apis::urlencode(country_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = area_code {
        local_var_req_builder = local_var_req_builder.query(&[("AreaCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = contains {
        local_var_req_builder = local_var_req_builder.query(&[("Contains", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("SmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mms_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("MmsEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = voice_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("VoiceEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_all_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeAllAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_local_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeLocalAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_foreign_address_required {
        local_var_req_builder = local_var_req_builder.query(&[("ExcludeForeignAddressRequired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_number {
        local_var_req_builder = local_var_req_builder.query(&[("NearNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = near_lat_long {
        local_var_req_builder = local_var_req_builder.query(&[("NearLatLong", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = distance {
        local_var_req_builder = local_var_req_builder.query(&[("Distance", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_postal_code {
        local_var_req_builder = local_var_req_builder.query(&[("InPostalCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_region {
        local_var_req_builder = local_var_req_builder.query(&[("InRegion", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_rate_center {
        local_var_req_builder = local_var_req_builder.query(&[("InRateCenter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_lata {
        local_var_req_builder = local_var_req_builder.query(&[("InLata", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = in_locality {
        local_var_req_builder = local_var_req_builder.query(&[("InLocality", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fax_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("FaxEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAvailablePhoneNumberVoipSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAvailablePhoneNumberVoipError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves a collection of calls made to and from your account
pub async fn list_call(configuration: &configuration::Configuration, params: ListCallParams) -> Result<ResponseContent<ListCallSuccess>, Error<ListCallError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let to = params.to;
    let from = params.from;
    let parent_call_sid = params.parent_call_sid;
    let status = params.status;
    let start_time = params.start_time;
    let start_time2 = params.start_time2;
    let start_time3 = params.start_time3;
    let end_time = params.end_time;
    let end_time2 = params.end_time2;
    let end_time3 = params.end_time3;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = to {
        local_var_req_builder = local_var_req_builder.query(&[("To", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("From", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_call_sid {
        local_var_req_builder = local_var_req_builder.query(&[("ParentCallSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_time {
        local_var_req_builder = local_var_req_builder.query(&[("StartTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_time2 {
        local_var_req_builder = local_var_req_builder.query(&[("StartTime<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_time3 {
        local_var_req_builder = local_var_req_builder.query(&[("StartTime>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_time {
        local_var_req_builder = local_var_req_builder.query(&[("EndTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_time2 {
        local_var_req_builder = local_var_req_builder.query(&[("EndTime<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_time3 {
        local_var_req_builder = local_var_req_builder.query(&[("EndTime>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCallSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCallError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all events for a call.
pub async fn list_call_event(configuration: &configuration::Configuration, params: ListCallEventParams) -> Result<ResponseContent<ListCallEventSuccess>, Error<ListCallEventError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Events.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCallEventSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCallEventError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_call_notification(configuration: &configuration::Configuration, params: ListCallNotificationParams) -> Result<ResponseContent<ListCallNotificationSuccess>, Error<ListCallNotificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let log = params.log;
    let message_date = params.message_date;
    let message_date2 = params.message_date2;
    let message_date3 = params.message_date3;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = log {
        local_var_req_builder = local_var_req_builder.query(&[("Log", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_date {
        local_var_req_builder = local_var_req_builder.query(&[("MessageDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_date2 {
        local_var_req_builder = local_var_req_builder.query(&[("MessageDate<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_date3 {
        local_var_req_builder = local_var_req_builder.query(&[("MessageDate>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCallNotificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCallNotificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of recordings belonging to the call used to make the request
pub async fn list_call_recording(configuration: &configuration::Configuration, params: ListCallRecordingParams) -> Result<ResponseContent<ListCallRecordingSuccess>, Error<ListCallRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let date_created = params.date_created;
    let date_created2 = params.date_created2;
    let date_created3 = params.date_created3;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = date_created {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created2 {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created3 {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCallRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCallRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of conferences belonging to the account used to make the request
pub async fn list_conference(configuration: &configuration::Configuration, params: ListConferenceParams) -> Result<ResponseContent<ListConferenceSuccess>, Error<ListConferenceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let date_created = params.date_created;
    let date_created2 = params.date_created2;
    let date_created3 = params.date_created3;
    let date_updated = params.date_updated;
    let date_updated2 = params.date_updated2;
    let date_updated3 = params.date_updated3;
    let friendly_name = params.friendly_name;
    let status = params.status;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = date_created {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created2 {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created3 {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_updated {
        local_var_req_builder = local_var_req_builder.query(&[("DateUpdated", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_updated2 {
        local_var_req_builder = local_var_req_builder.query(&[("DateUpdated<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_updated3 {
        local_var_req_builder = local_var_req_builder.query(&[("DateUpdated>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListConferenceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListConferenceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of recordings belonging to the call used to make the request
pub async fn list_conference_recording(configuration: &configuration::Configuration, params: ListConferenceRecordingParams) -> Result<ResponseContent<ListConferenceRecordingSuccess>, Error<ListConferenceRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let date_created = params.date_created;
    let date_created2 = params.date_created2;
    let date_created3 = params.date_created3;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = date_created {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created2 {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created3 {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListConferenceRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListConferenceRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of connect-apps belonging to the account used to make the request
pub async fn list_connect_app(configuration: &configuration::Configuration, params: ListConnectAppParams) -> Result<ResponseContent<ListConnectAppSuccess>, Error<ListConnectAppError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/ConnectApps.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListConnectAppSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListConnectAppError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_dependent_phone_number(configuration: &configuration::Configuration, params: ListDependentPhoneNumberParams) -> Result<ResponseContent<ListDependentPhoneNumberSuccess>, Error<ListDependentPhoneNumberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let address_sid = params.address_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Addresses/{AddressSid}/DependentPhoneNumbers.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), AddressSid=crate::apis::urlencode(address_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListDependentPhoneNumberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListDependentPhoneNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of incoming-phone-numbers belonging to the account used to make the request.
pub async fn list_incoming_phone_number(configuration: &configuration::Configuration, params: ListIncomingPhoneNumberParams) -> Result<ResponseContent<ListIncomingPhoneNumberSuccess>, Error<ListIncomingPhoneNumberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let beta = params.beta;
    let friendly_name = params.friendly_name;
    let phone_number = params.phone_number;
    let origin = params.origin;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = phone_number {
        local_var_req_builder = local_var_req_builder.query(&[("PhoneNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = origin {
        local_var_req_builder = local_var_req_builder.query(&[("Origin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListIncomingPhoneNumberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListIncomingPhoneNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Add-on installations currently assigned to this Number.
pub async fn list_incoming_phone_number_assigned_add_on(configuration: &configuration::Configuration, params: ListIncomingPhoneNumberAssignedAddOnParams) -> Result<ResponseContent<ListIncomingPhoneNumberAssignedAddOnSuccess>, Error<ListIncomingPhoneNumberAssignedAddOnError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let resource_sid = params.resource_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ResourceSid=crate::apis::urlencode(resource_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListIncomingPhoneNumberAssignedAddOnSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListIncomingPhoneNumberAssignedAddOnError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Extensions for the Assigned Add-on.
pub async fn list_incoming_phone_number_assigned_add_on_extension(configuration: &configuration::Configuration, params: ListIncomingPhoneNumberAssignedAddOnExtensionParams) -> Result<ResponseContent<ListIncomingPhoneNumberAssignedAddOnExtensionSuccess>, Error<ListIncomingPhoneNumberAssignedAddOnExtensionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let resource_sid = params.resource_sid;
    let assigned_add_on_sid = params.assigned_add_on_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ResourceSid=crate::apis::urlencode(resource_sid), AssignedAddOnSid=crate::apis::urlencode(assigned_add_on_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListIncomingPhoneNumberAssignedAddOnExtensionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListIncomingPhoneNumberAssignedAddOnExtensionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_incoming_phone_number_local(configuration: &configuration::Configuration, params: ListIncomingPhoneNumberLocalParams) -> Result<ResponseContent<ListIncomingPhoneNumberLocalSuccess>, Error<ListIncomingPhoneNumberLocalError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let beta = params.beta;
    let friendly_name = params.friendly_name;
    let phone_number = params.phone_number;
    let origin = params.origin;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = phone_number {
        local_var_req_builder = local_var_req_builder.query(&[("PhoneNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = origin {
        local_var_req_builder = local_var_req_builder.query(&[("Origin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListIncomingPhoneNumberLocalSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListIncomingPhoneNumberLocalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_incoming_phone_number_mobile(configuration: &configuration::Configuration, params: ListIncomingPhoneNumberMobileParams) -> Result<ResponseContent<ListIncomingPhoneNumberMobileSuccess>, Error<ListIncomingPhoneNumberMobileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let beta = params.beta;
    let friendly_name = params.friendly_name;
    let phone_number = params.phone_number;
    let origin = params.origin;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = phone_number {
        local_var_req_builder = local_var_req_builder.query(&[("PhoneNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = origin {
        local_var_req_builder = local_var_req_builder.query(&[("Origin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListIncomingPhoneNumberMobileSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListIncomingPhoneNumberMobileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_incoming_phone_number_toll_free(configuration: &configuration::Configuration, params: ListIncomingPhoneNumberTollFreeParams) -> Result<ResponseContent<ListIncomingPhoneNumberTollFreeSuccess>, Error<ListIncomingPhoneNumberTollFreeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let beta = params.beta;
    let friendly_name = params.friendly_name;
    let phone_number = params.phone_number;
    let origin = params.origin;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = beta {
        local_var_req_builder = local_var_req_builder.query(&[("Beta", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = phone_number {
        local_var_req_builder = local_var_req_builder.query(&[("PhoneNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = origin {
        local_var_req_builder = local_var_req_builder.query(&[("Origin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListIncomingPhoneNumberTollFreeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListIncomingPhoneNumberTollFreeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_key(configuration: &configuration::Configuration, params: ListKeyParams) -> Result<ResponseContent<ListKeySuccess>, Error<ListKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Keys.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListKeySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Media resources belonging to the account used to make the request
pub async fn list_media(configuration: &configuration::Configuration, params: ListMediaParams) -> Result<ResponseContent<ListMediaSuccess>, Error<ListMediaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let message_sid = params.message_sid;
    let date_created = params.date_created;
    let date_created2 = params.date_created2;
    let date_created3 = params.date_created3;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), MessageSid=crate::apis::urlencode(message_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = date_created {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created2 {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created3 {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMediaSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMediaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the members of the queue
pub async fn list_member(configuration: &configuration::Configuration, params: ListMemberParams) -> Result<ResponseContent<ListMemberSuccess>, Error<ListMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let queue_sid = params.queue_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), QueueSid=crate::apis::urlencode(queue_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of messages belonging to the account used to make the request
pub async fn list_message(configuration: &configuration::Configuration, params: ListMessageParams) -> Result<ResponseContent<ListMessageSuccess>, Error<ListMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let to = params.to;
    let from = params.from;
    let date_sent = params.date_sent;
    let date_sent2 = params.date_sent2;
    let date_sent3 = params.date_sent3;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Messages.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = to {
        local_var_req_builder = local_var_req_builder.query(&[("To", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("From", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_sent {
        local_var_req_builder = local_var_req_builder.query(&[("DateSent", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_sent2 {
        local_var_req_builder = local_var_req_builder.query(&[("DateSent<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_sent3 {
        local_var_req_builder = local_var_req_builder.query(&[("DateSent>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of notifications belonging to the account used to make the request
pub async fn list_notification(configuration: &configuration::Configuration, params: ListNotificationParams) -> Result<ResponseContent<ListNotificationSuccess>, Error<ListNotificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let log = params.log;
    let message_date = params.message_date;
    let message_date2 = params.message_date2;
    let message_date3 = params.message_date3;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Notifications.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = log {
        local_var_req_builder = local_var_req_builder.query(&[("Log", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_date {
        local_var_req_builder = local_var_req_builder.query(&[("MessageDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_date2 {
        local_var_req_builder = local_var_req_builder.query(&[("MessageDate<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_date3 {
        local_var_req_builder = local_var_req_builder.query(&[("MessageDate>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListNotificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListNotificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of outgoing-caller-ids belonging to the account used to make the request
pub async fn list_outgoing_caller_id(configuration: &configuration::Configuration, params: ListOutgoingCallerIdParams) -> Result<ResponseContent<ListOutgoingCallerIdSuccess>, Error<ListOutgoingCallerIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let phone_number = params.phone_number;
    let friendly_name = params.friendly_name;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = phone_number {
        local_var_req_builder = local_var_req_builder.query(&[("PhoneNumber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListOutgoingCallerIdSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListOutgoingCallerIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of participants belonging to the account used to make the request
pub async fn list_participant(configuration: &configuration::Configuration, params: ListParticipantParams) -> Result<ResponseContent<ListParticipantSuccess>, Error<ListParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let muted = params.muted;
    let hold = params.hold;
    let coaching = params.coaching;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = muted {
        local_var_req_builder = local_var_req_builder.query(&[("Muted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = hold {
        local_var_req_builder = local_var_req_builder.query(&[("Hold", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = coaching {
        local_var_req_builder = local_var_req_builder.query(&[("Coaching", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of queues belonging to the account used to make the request
pub async fn list_queue(configuration: &configuration::Configuration, params: ListQueueParams) -> Result<ResponseContent<ListQueueSuccess>, Error<ListQueueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Queues.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListQueueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of recordings belonging to the account used to make the request
pub async fn list_recording(configuration: &configuration::Configuration, params: ListRecordingParams) -> Result<ResponseContent<ListRecordingSuccess>, Error<ListRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let date_created = params.date_created;
    let date_created2 = params.date_created2;
    let date_created3 = params.date_created3;
    let call_sid = params.call_sid;
    let conference_sid = params.conference_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = date_created {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created2 {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated<", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created3 {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreated>", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = call_sid {
        local_var_req_builder = local_var_req_builder.query(&[("CallSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = conference_sid {
        local_var_req_builder = local_var_req_builder.query(&[("ConferenceSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of results belonging to the recording
pub async fn list_recording_add_on_result(configuration: &configuration::Configuration, params: ListRecordingAddOnResultParams) -> Result<ResponseContent<ListRecordingAddOnResultSuccess>, Error<ListRecordingAddOnResultError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let reference_sid = params.reference_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ReferenceSid=crate::apis::urlencode(reference_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRecordingAddOnResultSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRecordingAddOnResultError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of payloads belonging to the AddOnResult
pub async fn list_recording_add_on_result_payload(configuration: &configuration::Configuration, params: ListRecordingAddOnResultPayloadParams) -> Result<ResponseContent<ListRecordingAddOnResultPayloadSuccess>, Error<ListRecordingAddOnResultPayloadError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let reference_sid = params.reference_sid;
    let add_on_result_sid = params.add_on_result_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ReferenceSid=crate::apis::urlencode(reference_sid), AddOnResultSid=crate::apis::urlencode(add_on_result_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRecordingAddOnResultPayloadSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRecordingAddOnResultPayloadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_recording_transcription(configuration: &configuration::Configuration, params: ListRecordingTranscriptionParams) -> Result<ResponseContent<ListRecordingTranscriptionSuccess>, Error<ListRecordingTranscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let recording_sid = params.recording_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), RecordingSid=crate::apis::urlencode(recording_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRecordingTranscriptionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRecordingTranscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of short-codes belonging to the account used to make the request
pub async fn list_short_code(configuration: &configuration::Configuration, params: ListShortCodeParams) -> Result<ResponseContent<ListShortCodeSuccess>, Error<ListShortCodeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let friendly_name = params.friendly_name;
    let short_code = params.short_code;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = short_code {
        local_var_req_builder = local_var_req_builder.query(&[("ShortCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListShortCodeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListShortCodeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_signing_key(configuration: &configuration::Configuration, params: ListSigningKeyParams) -> Result<ResponseContent<ListSigningKeySuccess>, Error<ListSigningKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SigningKeys.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSigningKeySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSigningKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of credential list mappings belonging to the domain used in the request
pub async fn list_sip_auth_calls_credential_list_mapping(configuration: &configuration::Configuration, params: ListSipAuthCallsCredentialListMappingParams) -> Result<ResponseContent<ListSipAuthCallsCredentialListMappingSuccess>, Error<ListSipAuthCallsCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSipAuthCallsCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSipAuthCallsCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of IP Access Control List mappings belonging to the domain used in the request
pub async fn list_sip_auth_calls_ip_access_control_list_mapping(configuration: &configuration::Configuration, params: ListSipAuthCallsIpAccessControlListMappingParams) -> Result<ResponseContent<ListSipAuthCallsIpAccessControlListMappingSuccess>, Error<ListSipAuthCallsIpAccessControlListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSipAuthCallsIpAccessControlListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSipAuthCallsIpAccessControlListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of credential list mappings belonging to the domain used in the request
pub async fn list_sip_auth_registrations_credential_list_mapping(configuration: &configuration::Configuration, params: ListSipAuthRegistrationsCredentialListMappingParams) -> Result<ResponseContent<ListSipAuthRegistrationsCredentialListMappingSuccess>, Error<ListSipAuthRegistrationsCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSipAuthRegistrationsCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSipAuthRegistrationsCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of credentials.
pub async fn list_sip_credential(configuration: &configuration::Configuration, params: ListSipCredentialParams) -> Result<ResponseContent<ListSipCredentialSuccess>, Error<ListSipCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let credential_list_sid = params.credential_list_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CredentialListSid=crate::apis::urlencode(credential_list_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSipCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSipCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get All Credential Lists
pub async fn list_sip_credential_list(configuration: &configuration::Configuration, params: ListSipCredentialListParams) -> Result<ResponseContent<ListSipCredentialListSuccess>, Error<ListSipCredentialListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSipCredentialListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSipCredentialListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Read multiple CredentialListMapping resources from an account.
pub async fn list_sip_credential_list_mapping(configuration: &configuration::Configuration, params: ListSipCredentialListMappingParams) -> Result<ResponseContent<ListSipCredentialListMappingSuccess>, Error<ListSipCredentialListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSipCredentialListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSipCredentialListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of domains belonging to the account used to make the request
pub async fn list_sip_domain(configuration: &configuration::Configuration, params: ListSipDomainParams) -> Result<ResponseContent<ListSipDomainSuccess>, Error<ListSipDomainError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSipDomainSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSipDomainError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of IpAccessControlLists that belong to the account used to make the request
pub async fn list_sip_ip_access_control_list(configuration: &configuration::Configuration, params: ListSipIpAccessControlListParams) -> Result<ResponseContent<ListSipIpAccessControlListSuccess>, Error<ListSipIpAccessControlListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSipIpAccessControlListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSipIpAccessControlListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of IpAccessControlListMapping resources.
pub async fn list_sip_ip_access_control_list_mapping(configuration: &configuration::Configuration, params: ListSipIpAccessControlListMappingParams) -> Result<ResponseContent<ListSipIpAccessControlListMappingSuccess>, Error<ListSipIpAccessControlListMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let domain_sid = params.domain_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), DomainSid=crate::apis::urlencode(domain_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSipIpAccessControlListMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSipIpAccessControlListMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Read multiple IpAddress resources.
pub async fn list_sip_ip_address(configuration: &configuration::Configuration, params: ListSipIpAddressParams) -> Result<ResponseContent<ListSipIpAddressSuccess>, Error<ListSipIpAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let ip_access_control_list_sid = params.ip_access_control_list_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), IpAccessControlListSid=crate::apis::urlencode(ip_access_control_list_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSipIpAddressSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSipIpAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of transcriptions belonging to the account used to make the request
pub async fn list_transcription(configuration: &configuration::Configuration, params: ListTranscriptionParams) -> Result<ResponseContent<ListTranscriptionSuccess>, Error<ListTranscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Transcriptions.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListTranscriptionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListTranscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of usage-records belonging to the account used to make the request
pub async fn list_usage_record(configuration: &configuration::Configuration, params: ListUsageRecordParams) -> Result<ResponseContent<ListUsageRecordSuccess>, Error<ListUsageRecordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let category = params.category;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let include_subaccounts = params.include_subaccounts;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Records.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = category {
        local_var_req_builder = local_var_req_builder.query(&[("Category", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subaccounts {
        local_var_req_builder = local_var_req_builder.query(&[("IncludeSubaccounts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_usage_record_all_time(configuration: &configuration::Configuration, params: ListUsageRecordAllTimeParams) -> Result<ResponseContent<ListUsageRecordAllTimeSuccess>, Error<ListUsageRecordAllTimeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let category = params.category;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let include_subaccounts = params.include_subaccounts;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Records/AllTime.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = category {
        local_var_req_builder = local_var_req_builder.query(&[("Category", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subaccounts {
        local_var_req_builder = local_var_req_builder.query(&[("IncludeSubaccounts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordAllTimeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordAllTimeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_usage_record_daily(configuration: &configuration::Configuration, params: ListUsageRecordDailyParams) -> Result<ResponseContent<ListUsageRecordDailySuccess>, Error<ListUsageRecordDailyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let category = params.category;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let include_subaccounts = params.include_subaccounts;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Records/Daily.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = category {
        local_var_req_builder = local_var_req_builder.query(&[("Category", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subaccounts {
        local_var_req_builder = local_var_req_builder.query(&[("IncludeSubaccounts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordDailySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordDailyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_usage_record_last_month(configuration: &configuration::Configuration, params: ListUsageRecordLastMonthParams) -> Result<ResponseContent<ListUsageRecordLastMonthSuccess>, Error<ListUsageRecordLastMonthError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let category = params.category;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let include_subaccounts = params.include_subaccounts;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Records/LastMonth.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = category {
        local_var_req_builder = local_var_req_builder.query(&[("Category", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subaccounts {
        local_var_req_builder = local_var_req_builder.query(&[("IncludeSubaccounts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordLastMonthSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordLastMonthError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_usage_record_monthly(configuration: &configuration::Configuration, params: ListUsageRecordMonthlyParams) -> Result<ResponseContent<ListUsageRecordMonthlySuccess>, Error<ListUsageRecordMonthlyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let category = params.category;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let include_subaccounts = params.include_subaccounts;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Records/Monthly.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = category {
        local_var_req_builder = local_var_req_builder.query(&[("Category", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subaccounts {
        local_var_req_builder = local_var_req_builder.query(&[("IncludeSubaccounts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordMonthlySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordMonthlyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_usage_record_this_month(configuration: &configuration::Configuration, params: ListUsageRecordThisMonthParams) -> Result<ResponseContent<ListUsageRecordThisMonthSuccess>, Error<ListUsageRecordThisMonthError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let category = params.category;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let include_subaccounts = params.include_subaccounts;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Records/ThisMonth.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = category {
        local_var_req_builder = local_var_req_builder.query(&[("Category", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subaccounts {
        local_var_req_builder = local_var_req_builder.query(&[("IncludeSubaccounts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordThisMonthSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordThisMonthError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_usage_record_today(configuration: &configuration::Configuration, params: ListUsageRecordTodayParams) -> Result<ResponseContent<ListUsageRecordTodaySuccess>, Error<ListUsageRecordTodayError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let category = params.category;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let include_subaccounts = params.include_subaccounts;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Records/Today.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = category {
        local_var_req_builder = local_var_req_builder.query(&[("Category", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subaccounts {
        local_var_req_builder = local_var_req_builder.query(&[("IncludeSubaccounts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordTodaySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordTodayError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_usage_record_yearly(configuration: &configuration::Configuration, params: ListUsageRecordYearlyParams) -> Result<ResponseContent<ListUsageRecordYearlySuccess>, Error<ListUsageRecordYearlyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let category = params.category;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let include_subaccounts = params.include_subaccounts;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Records/Yearly.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = category {
        local_var_req_builder = local_var_req_builder.query(&[("Category", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subaccounts {
        local_var_req_builder = local_var_req_builder.query(&[("IncludeSubaccounts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordYearlySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordYearlyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_usage_record_yesterday(configuration: &configuration::Configuration, params: ListUsageRecordYesterdayParams) -> Result<ResponseContent<ListUsageRecordYesterdaySuccess>, Error<ListUsageRecordYesterdayError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let category = params.category;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let include_subaccounts = params.include_subaccounts;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Records/Yesterday.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = category {
        local_var_req_builder = local_var_req_builder.query(&[("Category", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_subaccounts {
        local_var_req_builder = local_var_req_builder.query(&[("IncludeSubaccounts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordYesterdaySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordYesterdayError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of usage-triggers belonging to the account used to make the request
pub async fn list_usage_trigger(configuration: &configuration::Configuration, params: ListUsageTriggerParams) -> Result<ResponseContent<ListUsageTriggerSuccess>, Error<ListUsageTriggerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let recurring = params.recurring;
    let trigger_by = params.trigger_by;
    let usage_category = params.usage_category;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = recurring {
        local_var_req_builder = local_var_req_builder.query(&[("Recurring", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = trigger_by {
        local_var_req_builder = local_var_req_builder.query(&[("TriggerBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = usage_category {
        local_var_req_builder = local_var_req_builder.query(&[("UsageCategory", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageTriggerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageTriggerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Modify the properties of a given Account
pub async fn update_account(configuration: &configuration::Configuration, params: UpdateAccountParams) -> Result<ResponseContent<UpdateAccountSuccess>, Error<UpdateAccountError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let friendly_name = params.friendly_name;
    let status = params.status;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{Sid}.json", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateAccountSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateAccountError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_address(configuration: &configuration::Configuration, params: UpdateAddressParams) -> Result<ResponseContent<UpdateAddressSuccess>, Error<UpdateAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let auto_correct_address = params.auto_correct_address;
    let city = params.city;
    let customer_name = params.customer_name;
    let emergency_enabled = params.emergency_enabled;
    let friendly_name = params.friendly_name;
    let postal_code = params.postal_code;
    let region = params.region;
    let street = params.street;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = auto_correct_address {
        local_var_form_params.insert("AutoCorrectAddress", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = city {
        local_var_form_params.insert("City", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = customer_name {
        local_var_form_params.insert("CustomerName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_enabled {
        local_var_form_params.insert("EmergencyEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = postal_code {
        local_var_form_params.insert("PostalCode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = region {
        local_var_form_params.insert("Region", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = street {
        local_var_form_params.insert("Street", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateAddressSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the application's properties
pub async fn update_application(configuration: &configuration::Configuration, params: UpdateApplicationParams) -> Result<ResponseContent<UpdateApplicationSuccess>, Error<UpdateApplicationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let api_version = params.api_version;
    let friendly_name = params.friendly_name;
    let message_status_callback = params.message_status_callback;
    let sms_fallback_method = params.sms_fallback_method;
    let sms_fallback_url = params.sms_fallback_url;
    let sms_method = params.sms_method;
    let sms_status_callback = params.sms_status_callback;
    let sms_url = params.sms_url;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let voice_caller_id_lookup = params.voice_caller_id_lookup;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_version {
        local_var_form_params.insert("ApiVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = message_status_callback {
        local_var_form_params.insert("MessageStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_method {
        local_var_form_params.insert("SmsFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_url {
        local_var_form_params.insert("SmsFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_method {
        local_var_form_params.insert("SmsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_status_callback {
        local_var_form_params.insert("SmsStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_url {
        local_var_form_params.insert("SmsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_caller_id_lookup {
        local_var_form_params.insert("VoiceCallerIdLookup", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateApplicationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateApplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Initiates a call redirect or terminates a call
pub async fn update_call(configuration: &configuration::Configuration, params: UpdateCallParams) -> Result<ResponseContent<UpdateCallSuccess>, Error<UpdateCallError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let fallback_method = params.fallback_method;
    let fallback_url = params.fallback_url;
    let method = params.method;
    let status = params.status;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let time_limit = params.time_limit;
    let twiml = params.twiml;
    let url = params.url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = fallback_method {
        local_var_form_params.insert("FallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fallback_url {
        local_var_form_params.insert("FallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = method {
        local_var_form_params.insert("Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = time_limit {
        local_var_form_params.insert("TimeLimit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = twiml {
        local_var_form_params.insert("Twiml", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = url {
        local_var_form_params.insert("Url", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateCallSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateCallError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a Feedback resource for a call
pub async fn update_call_feedback(configuration: &configuration::Configuration, params: UpdateCallFeedbackParams) -> Result<ResponseContent<UpdateCallFeedbackSuccess>, Error<UpdateCallFeedbackError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let issue = params.issue;
    let quality_score = params.quality_score;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = issue {
        local_var_form_params.insert("Issue", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = quality_score {
        local_var_form_params.insert("QualityScore", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateCallFeedbackSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateCallFeedbackError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Changes the status of the recording to paused, stopped, or in-progress. Note: Pass `Twilio.CURRENT` instead of recording sid to reference current active recording.
pub async fn update_call_recording(configuration: &configuration::Configuration, params: UpdateCallRecordingParams) -> Result<ResponseContent<UpdateCallRecordingSuccess>, Error<UpdateCallRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let sid = params.sid;
    let status = params.status;
    let pause_behavior = params.pause_behavior;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = pause_behavior {
        local_var_form_params.insert("PauseBehavior", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateCallRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateCallRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_conference(configuration: &configuration::Configuration, params: UpdateConferenceParams) -> Result<ResponseContent<UpdateConferenceSuccess>, Error<UpdateConferenceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let announce_method = params.announce_method;
    let announce_url = params.announce_url;
    let status = params.status;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = announce_method {
        local_var_form_params.insert("AnnounceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = announce_url {
        local_var_form_params.insert("AnnounceUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConferenceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConferenceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Changes the status of the recording to paused, stopped, or in-progress. Note: To use `Twilio.CURRENT`, pass it as recording sid.
pub async fn update_conference_recording(configuration: &configuration::Configuration, params: UpdateConferenceRecordingParams) -> Result<ResponseContent<UpdateConferenceRecordingSuccess>, Error<UpdateConferenceRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let sid = params.sid;
    let status = params.status;
    let pause_behavior = params.pause_behavior;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = pause_behavior {
        local_var_form_params.insert("PauseBehavior", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConferenceRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConferenceRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a connect-app with the specified parameters
pub async fn update_connect_app(configuration: &configuration::Configuration, params: UpdateConnectAppParams) -> Result<ResponseContent<UpdateConnectAppSuccess>, Error<UpdateConnectAppError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let authorize_redirect_url = params.authorize_redirect_url;
    let company_name = params.company_name;
    let deauthorize_callback_method = params.deauthorize_callback_method;
    let deauthorize_callback_url = params.deauthorize_callback_url;
    let description = params.description;
    let friendly_name = params.friendly_name;
    let homepage_url = params.homepage_url;
    let permissions = params.permissions;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = authorize_redirect_url {
        local_var_form_params.insert("AuthorizeRedirectUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = company_name {
        local_var_form_params.insert("CompanyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = deauthorize_callback_method {
        local_var_form_params.insert("DeauthorizeCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = deauthorize_callback_url {
        local_var_form_params.insert("DeauthorizeCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = description {
        local_var_form_params.insert("Description", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = homepage_url {
        local_var_form_params.insert("HomepageUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = permissions {
        local_var_form_params.insert("Permissions", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConnectAppSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConnectAppError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an incoming-phone-number instance.
pub async fn update_incoming_phone_number(configuration: &configuration::Configuration, params: UpdateIncomingPhoneNumberParams) -> Result<ResponseContent<UpdateIncomingPhoneNumberSuccess>, Error<UpdateIncomingPhoneNumberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let account_sid2 = params.account_sid2;
    let address_sid = params.address_sid;
    let api_version = params.api_version;
    let bundle_sid = params.bundle_sid;
    let emergency_address_sid = params.emergency_address_sid;
    let emergency_status = params.emergency_status;
    let friendly_name = params.friendly_name;
    let identity_sid = params.identity_sid;
    let sms_application_sid = params.sms_application_sid;
    let sms_fallback_method = params.sms_fallback_method;
    let sms_fallback_url = params.sms_fallback_url;
    let sms_method = params.sms_method;
    let sms_url = params.sms_url;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let trunk_sid = params.trunk_sid;
    let voice_application_sid = params.voice_application_sid;
    let voice_caller_id_lookup = params.voice_caller_id_lookup;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_receive_mode = params.voice_receive_mode;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = account_sid2 {
        local_var_form_params.insert("AccountSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = address_sid {
        local_var_form_params.insert("AddressSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = api_version {
        local_var_form_params.insert("ApiVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = bundle_sid {
        local_var_form_params.insert("BundleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_address_sid {
        local_var_form_params.insert("EmergencyAddressSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_status {
        local_var_form_params.insert("EmergencyStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = identity_sid {
        local_var_form_params.insert("IdentitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_application_sid {
        local_var_form_params.insert("SmsApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_method {
        local_var_form_params.insert("SmsFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_url {
        local_var_form_params.insert("SmsFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_method {
        local_var_form_params.insert("SmsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_url {
        local_var_form_params.insert("SmsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trunk_sid {
        local_var_form_params.insert("TrunkSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_application_sid {
        local_var_form_params.insert("VoiceApplicationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_caller_id_lookup {
        local_var_form_params.insert("VoiceCallerIdLookup", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_receive_mode {
        local_var_form_params.insert("VoiceReceiveMode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateIncomingPhoneNumberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateIncomingPhoneNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_key(configuration: &configuration::Configuration, params: UpdateKeyParams) -> Result<ResponseContent<UpdateKeySuccess>, Error<UpdateKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateKeySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL
pub async fn update_member(configuration: &configuration::Configuration, params: UpdateMemberParams) -> Result<ResponseContent<UpdateMemberSuccess>, Error<UpdateMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let queue_sid = params.queue_sid;
    let call_sid = params.call_sid;
    let url = params.url;
    let method = params.method;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), QueueSid=crate::apis::urlencode(queue_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = method {
        local_var_form_params.insert("Method", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Url", url.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// To redact a message-body from a post-flight message record, post to the message instance resource with an empty body
pub async fn update_message(configuration: &configuration::Configuration, params: UpdateMessageParams) -> Result<ResponseContent<UpdateMessageSuccess>, Error<UpdateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let body = params.body;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the caller-id
pub async fn update_outgoing_caller_id(configuration: &configuration::Configuration, params: UpdateOutgoingCallerIdParams) -> Result<ResponseContent<UpdateOutgoingCallerIdSuccess>, Error<UpdateOutgoingCallerIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateOutgoingCallerIdSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateOutgoingCallerIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the properties of the participant
pub async fn update_participant(configuration: &configuration::Configuration, params: UpdateParticipantParams) -> Result<ResponseContent<UpdateParticipantSuccess>, Error<UpdateParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let call_sid = params.call_sid;
    let announce_method = params.announce_method;
    let announce_url = params.announce_url;
    let beep_on_exit = params.beep_on_exit;
    let call_sid_to_coach = params.call_sid_to_coach;
    let coaching = params.coaching;
    let end_conference_on_exit = params.end_conference_on_exit;
    let hold = params.hold;
    let hold_method = params.hold_method;
    let hold_url = params.hold_url;
    let muted = params.muted;
    let wait_method = params.wait_method;
    let wait_url = params.wait_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = announce_method {
        local_var_form_params.insert("AnnounceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = announce_url {
        local_var_form_params.insert("AnnounceUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = beep_on_exit {
        local_var_form_params.insert("BeepOnExit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_sid_to_coach {
        local_var_form_params.insert("CallSidToCoach", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = coaching {
        local_var_form_params.insert("Coaching", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = end_conference_on_exit {
        local_var_form_params.insert("EndConferenceOnExit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = hold {
        local_var_form_params.insert("Hold", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = hold_method {
        local_var_form_params.insert("HoldMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = hold_url {
        local_var_form_params.insert("HoldUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = muted {
        local_var_form_params.insert("Muted", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_method {
        local_var_form_params.insert("WaitMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_url {
        local_var_form_params.insert("WaitUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// update an instance of payments with different phases of payment flows.
pub async fn update_payments(configuration: &configuration::Configuration, params: UpdatePaymentsParams) -> Result<ResponseContent<UpdatePaymentsSuccess>, Error<UpdatePaymentsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let call_sid = params.call_sid;
    let sid = params.sid;
    let idempotency_key = params.idempotency_key;
    let status_callback = params.status_callback;
    let capture = params.capture;
    let status = params.status;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CallSid=crate::apis::urlencode(call_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = capture {
        local_var_form_params.insert("Capture", local_var_param_value.to_string());
    }
    local_var_form_params.insert("IdempotencyKey", idempotency_key.to_string());
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    local_var_form_params.insert("StatusCallback", status_callback.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdatePaymentsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdatePaymentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the queue with the new parameters
pub async fn update_queue(configuration: &configuration::Configuration, params: UpdateQueueParams) -> Result<ResponseContent<UpdateQueueSuccess>, Error<UpdateQueueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let friendly_name = params.friendly_name;
    let max_size = params.max_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = max_size {
        local_var_form_params.insert("MaxSize", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateQueueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a short code with the following parameters
pub async fn update_short_code(configuration: &configuration::Configuration, params: UpdateShortCodeParams) -> Result<ResponseContent<UpdateShortCodeSuccess>, Error<UpdateShortCodeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let api_version = params.api_version;
    let friendly_name = params.friendly_name;
    let sms_fallback_method = params.sms_fallback_method;
    let sms_fallback_url = params.sms_fallback_url;
    let sms_method = params.sms_method;
    let sms_url = params.sms_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_version {
        local_var_form_params.insert("ApiVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_method {
        local_var_form_params.insert("SmsFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_url {
        local_var_form_params.insert("SmsFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_method {
        local_var_form_params.insert("SmsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_url {
        local_var_form_params.insert("SmsUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateShortCodeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateShortCodeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_signing_key(configuration: &configuration::Configuration, params: UpdateSigningKeyParams) -> Result<ResponseContent<UpdateSigningKeySuccess>, Error<UpdateSigningKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSigningKeySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSigningKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a credential resource.
pub async fn update_sip_credential(configuration: &configuration::Configuration, params: UpdateSipCredentialParams) -> Result<ResponseContent<UpdateSipCredentialSuccess>, Error<UpdateSipCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let credential_list_sid = params.credential_list_sid;
    let sid = params.sid;
    let password = params.password;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), CredentialListSid=crate::apis::urlencode(credential_list_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = password {
        local_var_form_params.insert("Password", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSipCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSipCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a Credential List
pub async fn update_sip_credential_list(configuration: &configuration::Configuration, params: UpdateSipCredentialListParams) -> Result<ResponseContent<UpdateSipCredentialListSuccess>, Error<UpdateSipCredentialListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSipCredentialListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSipCredentialListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the attributes of a domain
pub async fn update_sip_domain(configuration: &configuration::Configuration, params: UpdateSipDomainParams) -> Result<ResponseContent<UpdateSipDomainSuccess>, Error<UpdateSipDomainError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let byoc_trunk_sid = params.byoc_trunk_sid;
    let domain_name = params.domain_name;
    let emergency_caller_sid = params.emergency_caller_sid;
    let emergency_calling_enabled = params.emergency_calling_enabled;
    let friendly_name = params.friendly_name;
    let secure = params.secure;
    let sip_registration = params.sip_registration;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_status_callback_method = params.voice_status_callback_method;
    let voice_status_callback_url = params.voice_status_callback_url;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = byoc_trunk_sid {
        local_var_form_params.insert("ByocTrunkSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = domain_name {
        local_var_form_params.insert("DomainName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_caller_sid {
        local_var_form_params.insert("EmergencyCallerSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = emergency_calling_enabled {
        local_var_form_params.insert("EmergencyCallingEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secure {
        local_var_form_params.insert("Secure", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_registration {
        local_var_form_params.insert("SipRegistration", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_status_callback_method {
        local_var_form_params.insert("VoiceStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_status_callback_url {
        local_var_form_params.insert("VoiceStatusCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSipDomainSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSipDomainError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Rename an IpAccessControlList
pub async fn update_sip_ip_access_control_list(configuration: &configuration::Configuration, params: UpdateSipIpAccessControlListParams) -> Result<ResponseContent<UpdateSipIpAccessControlListSuccess>, Error<UpdateSipIpAccessControlListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSipIpAccessControlListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSipIpAccessControlListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an IpAddress resource.
pub async fn update_sip_ip_address(configuration: &configuration::Configuration, params: UpdateSipIpAddressParams) -> Result<ResponseContent<UpdateSipIpAddressSuccess>, Error<UpdateSipIpAddressError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let ip_access_control_list_sid = params.ip_access_control_list_sid;
    let sid = params.sid;
    let cidr_prefix_length = params.cidr_prefix_length;
    let friendly_name = params.friendly_name;
    let ip_address = params.ip_address;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), IpAccessControlListSid=crate::apis::urlencode(ip_access_control_list_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = cidr_prefix_length {
        local_var_form_params.insert("CidrPrefixLength", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ip_address {
        local_var_form_params.insert("IpAddress", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSipIpAddressSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSipIpAddressError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an instance of a usage trigger
pub async fn update_usage_trigger(configuration: &configuration::Configuration, params: UpdateUsageTriggerParams) -> Result<ResponseContent<UpdateUsageTriggerSuccess>, Error<UpdateUsageTriggerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let sid = params.sid;
    let callback_method = params.callback_method;
    let callback_url = params.callback_url;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = callback_method {
        local_var_form_params.insert("CallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = callback_url {
        local_var_form_params.insert("CallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateUsageTriggerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateUsageTriggerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

