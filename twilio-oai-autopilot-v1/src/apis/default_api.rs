/*
 * Twilio - Autopilot
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_assistant`
#[derive(Clone, Debug, Default)]
pub struct CreateAssistantParams {
    /// Reserved.
    pub callback_events: Option<String>,
    /// Reserved.
    pub callback_url: Option<String>,
    /// A JSON object that defines the Assistant's [default tasks](https://www.twilio.com/docs/autopilot/api/assistant/defaults) for various scenarios, including initiation actions and fallback tasks.
    pub defaults: Option<serde_json::Value>,
    /// A descriptive string that you create to describe the new resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>,
    /// Whether queries should be logged and kept after training. Can be: `true` or `false` and defaults to `true`. If `true`, queries are stored for 30 days, and then deleted. If `false`, no queries are stored.
    pub log_queries: Option<bool>,
    /// The JSON string that defines the Assistant's [style sheet](https://www.twilio.com/docs/autopilot/api/assistant/stylesheet)
    pub style_sheet: Option<serde_json::Value>,
    /// An application-defined string that uniquely identifies the new resource. It can be used as an alternative to the `sid` in the URL path to address the resource. The first 64 characters must be unique.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `create_field`
#[derive(Clone, Debug, Default)]
pub struct CreateFieldParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task associated with the new resource.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) resource associated with the new Field resource.
    pub task_sid: String,
    /// The Field Type of the new field. Can be: a [Built-in Field Type](https://www.twilio.com/docs/autopilot/built-in-field-types), the `unique_name`, or the `sid` of a custom Field Type.
    pub field_type: String,
    /// An application-defined string that uniquely identifies the new resource. This value must be a unique string of no more than 64 characters. It can be used as an alternative to the `sid` in the URL path to address the resource.
    pub unique_name: String
}

/// struct for passing parameters to the method `create_field_type`
#[derive(Clone, Debug, Default)]
pub struct CreateFieldTypeParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the new resource.
    pub assistant_sid: String,
    /// An application-defined string that uniquely identifies the new resource. It can be used as an alternative to the `sid` in the URL path to address the resource. The first 64 characters must be unique.
    pub unique_name: String,
    /// A descriptive string that you create to describe the new resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `create_field_value`
#[derive(Clone, Debug, Default)]
pub struct CreateFieldValueParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the FieldType associated with the new resource.
    pub assistant_sid: String,
    /// The SID of the Field Type associated with the Field Value.
    pub field_type_sid: String,
    /// The [ISO language-country](https://docs.oracle.com/cd/E13214_01/wli/docs92/xref/xqisocodes.html) tag that specifies the language of the value. Currently supported tags: `en-US`
    pub language: String,
    /// The Field Value data.
    pub value: String,
    /// The string value that indicates which word the field value is a synonym of.
    pub synonym_of: Option<String>
}

/// struct for passing parameters to the method `create_model_build`
#[derive(Clone, Debug, Default)]
pub struct CreateModelBuildParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the new resource.
    pub assistant_sid: String,
    /// The URL we should call using a POST method to send status information to your application.
    pub status_callback: Option<String>,
    /// An application-defined string that uniquely identifies the new resource. This value must be a unique string of no more than 64 characters. It can be used as an alternative to the `sid` in the URL path to address the resource.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `create_query`
#[derive(Clone, Debug, Default)]
pub struct CreateQueryParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the new resource.
    pub assistant_sid: String,
    /// The [ISO language-country](https://docs.oracle.com/cd/E13214_01/wli/docs92/xref/xqisocodes.html) string that specifies the language used for the new query. For example: `en-US`.
    pub language: String,
    /// The end-user's natural language input. It can be up to 2048 characters long.
    pub query: String,
    /// The SID or unique name of the [Model Build](https://www.twilio.com/docs/autopilot/api/model-build) to be queried.
    pub model_build: Option<String>,
    /// The list of tasks to limit the new query to. Tasks are expressed as a comma-separated list of task `unique_name` values. For example, `task-unique_name-1, task-unique_name-2`. Listing specific tasks is useful to constrain the paths that a user can take.
    pub tasks: Option<String>
}

/// struct for passing parameters to the method `create_sample`
#[derive(Clone, Debug, Default)]
pub struct CreateSampleParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task associated with the new resource.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) associated with the Sample resource to create.
    pub task_sid: String,
    /// The [ISO language-country](https://docs.oracle.com/cd/E13214_01/wli/docs92/xref/xqisocodes.html) string that specifies the language used for the new sample. For example: `en-US`.
    pub language: String,
    /// The text example of how end users might express the task. The sample can contain [Field tag blocks](https://www.twilio.com/docs/autopilot/api/task-sample#field-tagging).
    pub tagged_text: String,
    /// The communication channel from which the new sample was captured. Can be: `voice`, `sms`, `chat`, `alexa`, `google-assistant`, `slack`, or null if not included.
    pub source_channel: Option<String>
}

/// struct for passing parameters to the method `create_task`
#[derive(Clone, Debug, Default)]
pub struct CreateTaskParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the new resource.
    pub assistant_sid: String,
    /// An application-defined string that uniquely identifies the new resource. It can be used as an alternative to the `sid` in the URL path to address the resource. This value must be unique and 64 characters or less in length.
    pub unique_name: String,
    /// The JSON string that specifies the [actions](https://www.twilio.com/docs/autopilot/actions) that instruct the Assistant on how to perform the task. It is optional and not unique.
    pub actions: Option<serde_json::Value>,
    /// The URL from which the Assistant can fetch actions.
    pub actions_url: Option<String>,
    /// A descriptive string that you create to describe the new resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `create_webhook`
#[derive(Clone, Debug, Default)]
pub struct CreateWebhookParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the new resource.
    pub assistant_sid: String,
    /// The list of space-separated events that this Webhook will subscribe to.
    pub events: String,
    /// An application-defined string that uniquely identifies the new resource. It can be used as an alternative to the `sid` in the URL path to address the resource. This value must be unique and 64 characters or less in length.
    pub unique_name: String,
    /// The URL associated with this Webhook.
    pub webhook_url: String,
    /// The method to be used when calling the webhook's URL.
    pub webhook_method: Option<String>
}

/// struct for passing parameters to the method `delete_assistant`
#[derive(Clone, Debug, Default)]
pub struct DeleteAssistantParams {
    /// The Twilio-provided string that uniquely identifies the Assistant resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_field`
#[derive(Clone, Debug, Default)]
pub struct DeleteFieldParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task associated with the resources to delete.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) resource associated with the Field resource to delete.
    pub task_sid: String,
    /// The Twilio-provided string that uniquely identifies the Field resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_field_type`
#[derive(Clone, Debug, Default)]
pub struct DeleteFieldTypeParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resources to delete.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the FieldType resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_field_value`
#[derive(Clone, Debug, Default)]
pub struct DeleteFieldValueParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the FieldType associated with the resources to delete.
    pub assistant_sid: String,
    /// The SID of the Field Type associated with the Field Value to delete.
    pub field_type_sid: String,
    /// The Twilio-provided string that uniquely identifies the FieldValue resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_model_build`
#[derive(Clone, Debug, Default)]
pub struct DeleteModelBuildParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resources to delete.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the ModelBuild resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_query`
#[derive(Clone, Debug, Default)]
pub struct DeleteQueryParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resources to delete.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the Query resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sample`
#[derive(Clone, Debug, Default)]
pub struct DeleteSampleParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task associated with the resources to delete.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) associated with the Sample resource to delete.
    pub task_sid: String,
    /// The Twilio-provided string that uniquely identifies the Sample resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_task`
#[derive(Clone, Debug, Default)]
pub struct DeleteTaskParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resources to delete.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the Task resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_webhook`
#[derive(Clone, Debug, Default)]
pub struct DeleteWebhookParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resources to delete.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the Webhook resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_assistant`
#[derive(Clone, Debug, Default)]
pub struct FetchAssistantParams {
    /// The Twilio-provided string that uniquely identifies the Assistant resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_defaults`
#[derive(Clone, Debug, Default)]
pub struct FetchDefaultsParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to fetch.
    pub assistant_sid: String
}

/// struct for passing parameters to the method `fetch_dialogue`
#[derive(Clone, Debug, Default)]
pub struct FetchDialogueParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to fetch.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the Dialogue resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_field`
#[derive(Clone, Debug, Default)]
pub struct FetchFieldParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task associated with the resource to fetch.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) resource associated with the Field resource to fetch.
    pub task_sid: String,
    /// The Twilio-provided string that uniquely identifies the Field resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_field_type`
#[derive(Clone, Debug, Default)]
pub struct FetchFieldTypeParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to fetch.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the FieldType resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_field_value`
#[derive(Clone, Debug, Default)]
pub struct FetchFieldValueParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the FieldType associated with the resource to fetch.
    pub assistant_sid: String,
    /// The SID of the Field Type associated with the Field Value to fetch.
    pub field_type_sid: String,
    /// The Twilio-provided string that uniquely identifies the FieldValue resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_model_build`
#[derive(Clone, Debug, Default)]
pub struct FetchModelBuildParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to fetch.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the ModelBuild resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_query`
#[derive(Clone, Debug, Default)]
pub struct FetchQueryParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to fetch.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the Query resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sample`
#[derive(Clone, Debug, Default)]
pub struct FetchSampleParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task associated with the resource to fetch.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) associated with the Sample resource to create.
    pub task_sid: String,
    /// The Twilio-provided string that uniquely identifies the Sample resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_style_sheet`
#[derive(Clone, Debug, Default)]
pub struct FetchStyleSheetParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to fetch.
    pub assistant_sid: String
}

/// struct for passing parameters to the method `fetch_task`
#[derive(Clone, Debug, Default)]
pub struct FetchTaskParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to fetch.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the Task resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_task_actions`
#[derive(Clone, Debug, Default)]
pub struct FetchTaskActionsParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task for which the task actions to fetch were defined.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) for which the task actions to fetch were defined.
    pub task_sid: String
}

/// struct for passing parameters to the method `fetch_task_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchTaskStatisticsParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to fetch.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) that is associated with the resource to fetch.
    pub task_sid: String
}

/// struct for passing parameters to the method `fetch_webhook`
#[derive(Clone, Debug, Default)]
pub struct FetchWebhookParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to fetch.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the Webhook resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `list_assistant`
#[derive(Clone, Debug, Default)]
pub struct ListAssistantParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_field`
#[derive(Clone, Debug, Default)]
pub struct ListFieldParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task associated with the resources to read.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) resource associated with the Field resources to read.
    pub task_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_field_type`
#[derive(Clone, Debug, Default)]
pub struct ListFieldTypeParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resources to read.
    pub assistant_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_field_value`
#[derive(Clone, Debug, Default)]
pub struct ListFieldValueParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the FieldType associated with the resources to read.
    pub assistant_sid: String,
    /// The SID of the Field Type associated with the Field Value to read.
    pub field_type_sid: String,
    /// The [ISO language-country](https://docs.oracle.com/cd/E13214_01/wli/docs92/xref/xqisocodes.html) tag that specifies the language of the value. Currently supported tags: `en-US`
    pub language: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_model_build`
#[derive(Clone, Debug, Default)]
pub struct ListModelBuildParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resources to read.
    pub assistant_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_query`
#[derive(Clone, Debug, Default)]
pub struct ListQueryParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resources to read.
    pub assistant_sid: String,
    /// The [ISO language-country](https://docs.oracle.com/cd/E13214_01/wli/docs92/xref/xqisocodes.html) string that specifies the language used by the Query resources to read. For example: `en-US`.
    pub language: Option<String>,
    /// The SID or unique name of the [Model Build](https://www.twilio.com/docs/autopilot/api/model-build) to be queried.
    pub model_build: Option<String>,
    /// The status of the resources to read. Can be: `pending-review`, `reviewed`, or `discarded`
    pub status: Option<String>,
    /// The SID of the [Dialogue](https://www.twilio.com/docs/autopilot/api/dialogue).
    pub dialogue_sid: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sample`
#[derive(Clone, Debug, Default)]
pub struct ListSampleParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task associated with the resources to read.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) associated with the Sample resources to read.
    pub task_sid: String,
    /// The [ISO language-country](https://docs.oracle.com/cd/E13214_01/wli/docs92/xref/xqisocodes.html) string that specifies the language used for the sample. For example: `en-US`.
    pub language: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_task`
#[derive(Clone, Debug, Default)]
pub struct ListTaskParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resources to read.
    pub assistant_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_webhook`
#[derive(Clone, Debug, Default)]
pub struct ListWebhookParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resources to read.
    pub assistant_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_assistant`
#[derive(Clone, Debug, Default)]
pub struct UpdateAssistantParams {
    /// The Twilio-provided string that uniquely identifies the Assistant resource to update.
    pub sid: String,
    /// Reserved.
    pub callback_events: Option<String>,
    /// Reserved.
    pub callback_url: Option<String>,
    /// A JSON object that defines the Assistant's [default tasks](https://www.twilio.com/docs/autopilot/api/assistant/defaults) for various scenarios, including initiation actions and fallback tasks.
    pub defaults: Option<serde_json::Value>,
    /// A string describing the state of the assistant.
    pub development_stage: Option<String>,
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>,
    /// Whether queries should be logged and kept after training. Can be: `true` or `false` and defaults to `true`. If `true`, queries are stored for 30 days, and then deleted. If `false`, no queries are stored.
    pub log_queries: Option<bool>,
    /// The JSON string that defines the Assistant's [style sheet](https://www.twilio.com/docs/autopilot/api/assistant/stylesheet)
    pub style_sheet: Option<serde_json::Value>,
    /// An application-defined string that uniquely identifies the resource. It can be used as an alternative to the `sid` in the URL path to address the resource. The first 64 characters must be unique.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `update_defaults`
#[derive(Clone, Debug, Default)]
pub struct UpdateDefaultsParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to update.
    pub assistant_sid: String,
    /// A JSON string that describes the default task links for the `assistant_initiation`, `collect`, and `fallback` situations.
    pub defaults: Option<serde_json::Value>
}

/// struct for passing parameters to the method `update_field_type`
#[derive(Clone, Debug, Default)]
pub struct UpdateFieldTypeParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the to update.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the FieldType resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used as an alternative to the `sid` in the URL path to address the resource. The first 64 characters must be unique.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `update_model_build`
#[derive(Clone, Debug, Default)]
pub struct UpdateModelBuildParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to update.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the ModelBuild resource to update.
    pub sid: String,
    /// An application-defined string that uniquely identifies the resource. This value must be a unique string of no more than 64 characters. It can be used as an alternative to the `sid` in the URL path to address the resource.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `update_query`
#[derive(Clone, Debug, Default)]
pub struct UpdateQueryParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to update.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the Query resource to update.
    pub sid: String,
    /// The SID of an optional reference to the [Sample](https://www.twilio.com/docs/autopilot/api/task-sample) created from the query.
    pub sample_sid: Option<String>,
    /// The new status of the resource. Can be: `pending-review`, `reviewed`, or `discarded`
    pub status: Option<String>
}

/// struct for passing parameters to the method `update_restore_assistant`
#[derive(Clone, Debug, Default)]
pub struct UpdateRestoreAssistantParams {
    /// The Twilio-provided string that uniquely identifies the Assistant resource to restore.
    pub assistant: String
}

/// struct for passing parameters to the method `update_sample`
#[derive(Clone, Debug, Default)]
pub struct UpdateSampleParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task associated with the resource to update.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) associated with the Sample resource to update.
    pub task_sid: String,
    /// The Twilio-provided string that uniquely identifies the Sample resource to update.
    pub sid: String,
    /// The [ISO language-country](https://docs.oracle.com/cd/E13214_01/wli/docs92/xref/xqisocodes.html) string that specifies the language used for the sample. For example: `en-US`.
    pub language: Option<String>,
    /// The communication channel from which the sample was captured. Can be: `voice`, `sms`, `chat`, `alexa`, `google-assistant`, `slack`, or null if not included.
    pub source_channel: Option<String>,
    /// The text example of how end users might express the task. The sample can contain [Field tag blocks](https://www.twilio.com/docs/autopilot/api/task-sample#field-tagging).
    pub tagged_text: Option<String>
}

/// struct for passing parameters to the method `update_style_sheet`
#[derive(Clone, Debug, Default)]
pub struct UpdateStyleSheetParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to update.
    pub assistant_sid: String,
    /// The JSON string that describes the style sheet object.
    pub style_sheet: Option<serde_json::Value>
}

/// struct for passing parameters to the method `update_task`
#[derive(Clone, Debug, Default)]
pub struct UpdateTaskParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to update.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the Task resource to update.
    pub sid: String,
    /// The JSON string that specifies the [actions](https://www.twilio.com/docs/autopilot/actions) that instruct the Assistant on how to perform the task.
    pub actions: Option<serde_json::Value>,
    /// The URL from which the Assistant can fetch actions.
    pub actions_url: Option<String>,
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>,
    /// An application-defined string that uniquely identifies the resource. This value must be 64 characters or less in length and be unique. It can be used as an alternative to the `sid` in the URL path to address the resource.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `update_task_actions`
#[derive(Clone, Debug, Default)]
pub struct UpdateTaskActionsParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the Task for which the task actions to update were defined.
    pub assistant_sid: String,
    /// The SID of the [Task](https://www.twilio.com/docs/autopilot/api/task) for which the task actions to update were defined.
    pub task_sid: String,
    /// The JSON string that specifies the [actions](https://www.twilio.com/docs/autopilot/actions) that instruct the Assistant on how to perform the task.
    pub actions: Option<serde_json::Value>
}

/// struct for passing parameters to the method `update_webhook`
#[derive(Clone, Debug, Default)]
pub struct UpdateWebhookParams {
    /// The SID of the [Assistant](https://www.twilio.com/docs/autopilot/api/assistant) that is the parent of the resource to update.
    pub assistant_sid: String,
    /// The Twilio-provided string that uniquely identifies the Webhook resource to update.
    pub sid: String,
    /// The list of space-separated events that this Webhook will subscribe to.
    pub events: Option<String>,
    /// An application-defined string that uniquely identifies the new resource. It can be used as an alternative to the `sid` in the URL path to address the resource. This value must be unique and 64 characters or less in length.
    pub unique_name: Option<String>,
    /// The method to be used when calling the webhook's URL.
    pub webhook_method: Option<String>,
    /// The URL associated with this Webhook.
    pub webhook_url: Option<String>
}


/// struct for typed successes of method `create_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssistantSuccess {
    Status201(crate::models::AutopilotV1Assistant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFieldSuccess {
    Status201(crate::models::AutopilotV1AssistantTaskField),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_field_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFieldTypeSuccess {
    Status201(crate::models::AutopilotV1AssistantFieldType),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_field_value`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFieldValueSuccess {
    Status201(crate::models::AutopilotV1AssistantFieldTypeFieldValue),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_model_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateModelBuildSuccess {
    Status201(crate::models::AutopilotV1AssistantModelBuild),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateQuerySuccess {
    Status201(crate::models::AutopilotV1AssistantQuery),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sample`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSampleSuccess {
    Status201(crate::models::AutopilotV1AssistantTaskSample),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskSuccess {
    Status201(crate::models::AutopilotV1AssistantTask),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebhookSuccess {
    Status201(crate::models::AutopilotV1AssistantWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssistantSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFieldSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_field_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFieldTypeSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_field_value`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFieldValueSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_model_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteModelBuildSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteQuerySuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sample`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSampleSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTaskSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebhookSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAssistantSuccess {
    Status200(crate::models::AutopilotV1Assistant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_defaults`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDefaultsSuccess {
    Status200(crate::models::AutopilotV1AssistantDefaults),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_dialogue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDialogueSuccess {
    Status200(crate::models::AutopilotV1AssistantDialogue),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFieldSuccess {
    Status200(crate::models::AutopilotV1AssistantTaskField),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_field_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFieldTypeSuccess {
    Status200(crate::models::AutopilotV1AssistantFieldType),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_field_value`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFieldValueSuccess {
    Status200(crate::models::AutopilotV1AssistantFieldTypeFieldValue),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_model_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchModelBuildSuccess {
    Status200(crate::models::AutopilotV1AssistantModelBuild),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchQuerySuccess {
    Status200(crate::models::AutopilotV1AssistantQuery),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sample`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSampleSuccess {
    Status200(crate::models::AutopilotV1AssistantTaskSample),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_style_sheet`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchStyleSheetSuccess {
    Status200(crate::models::AutopilotV1AssistantStyleSheet),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskSuccess {
    Status200(crate::models::AutopilotV1AssistantTask),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_task_actions`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskActionsSuccess {
    Status200(crate::models::AutopilotV1AssistantTaskTaskActions),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_task_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskStatisticsSuccess {
    Status200(crate::models::AutopilotV1AssistantTaskTaskStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWebhookSuccess {
    Status200(crate::models::AutopilotV1AssistantWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAssistantSuccess {
    Status200(crate::models::ListAssistantResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFieldSuccess {
    Status200(crate::models::ListFieldResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_field_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFieldTypeSuccess {
    Status200(crate::models::ListFieldTypeResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_field_value`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFieldValueSuccess {
    Status200(crate::models::ListFieldValueResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_model_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListModelBuildSuccess {
    Status200(crate::models::ListModelBuildResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListQuerySuccess {
    Status200(crate::models::ListQueryResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sample`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSampleSuccess {
    Status200(crate::models::ListSampleResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskSuccess {
    Status200(crate::models::ListTaskResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWebhookSuccess {
    Status200(crate::models::ListWebhookResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAssistantSuccess {
    Status200(crate::models::AutopilotV1Assistant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_defaults`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDefaultsSuccess {
    Status200(crate::models::AutopilotV1AssistantDefaults),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_field_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFieldTypeSuccess {
    Status200(crate::models::AutopilotV1AssistantFieldType),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_model_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateModelBuildSuccess {
    Status200(crate::models::AutopilotV1AssistantModelBuild),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateQuerySuccess {
    Status200(crate::models::AutopilotV1AssistantQuery),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_restore_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRestoreAssistantSuccess {
    Status200(crate::models::AutopilotV1RestoreAssistant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sample`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSampleSuccess {
    Status200(crate::models::AutopilotV1AssistantTaskSample),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_style_sheet`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateStyleSheetSuccess {
    Status200(crate::models::AutopilotV1AssistantStyleSheet),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskSuccess {
    Status200(crate::models::AutopilotV1AssistantTask),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_task_actions`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskActionsSuccess {
    Status200(crate::models::AutopilotV1AssistantTaskTaskActions),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebhookSuccess {
    Status200(crate::models::AutopilotV1AssistantWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFieldError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_field_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFieldTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_field_value`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFieldValueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_model_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateModelBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateQueryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sample`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSampleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFieldError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_field_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFieldTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_field_value`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFieldValueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_model_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteModelBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteQueryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sample`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSampleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_defaults`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDefaultsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_dialogue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDialogueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFieldError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_field_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFieldTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_field_value`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFieldValueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_model_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchModelBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchQueryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sample`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSampleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_style_sheet`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchStyleSheetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_task_actions`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskActionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_task_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_field`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFieldError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_field_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFieldTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_field_value`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFieldValueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_model_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListModelBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListQueryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sample`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSampleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_defaults`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDefaultsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_field_type`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFieldTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_model_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateModelBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_query`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateQueryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_restore_assistant`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRestoreAssistantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sample`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSampleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_style_sheet`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateStyleSheetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_task_actions`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskActionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebhookError {
    UnknownValue(serde_json::Value),
}


pub async fn create_assistant(configuration: &configuration::Configuration, params: CreateAssistantParams) -> Result<ResponseContent<CreateAssistantSuccess>, Error<CreateAssistantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let callback_events = params.callback_events;
    let callback_url = params.callback_url;
    let defaults = params.defaults;
    let friendly_name = params.friendly_name;
    let log_queries = params.log_queries;
    let style_sheet = params.style_sheet;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = callback_events {
        local_var_form_params.insert("CallbackEvents", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = callback_url {
        local_var_form_params.insert("CallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = defaults {
        local_var_form_params.insert("Defaults", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = log_queries {
        local_var_form_params.insert("LogQueries", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = style_sheet {
        local_var_form_params.insert("StyleSheet", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateAssistantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateAssistantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_field(configuration: &configuration::Configuration, params: CreateFieldParams) -> Result<ResponseContent<CreateFieldSuccess>, Error<CreateFieldError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;
    let field_type = params.field_type;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FieldType", field_type.to_string());
    local_var_form_params.insert("UniqueName", unique_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateFieldSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateFieldError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_field_type(configuration: &configuration::Configuration, params: CreateFieldTypeParams) -> Result<ResponseContent<CreateFieldTypeSuccess>, Error<CreateFieldTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let unique_name = params.unique_name;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/FieldTypes", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("UniqueName", unique_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateFieldTypeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateFieldTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_field_value(configuration: &configuration::Configuration, params: CreateFieldValueParams) -> Result<ResponseContent<CreateFieldValueSuccess>, Error<CreateFieldValueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let field_type_sid = params.field_type_sid;
    let language = params.language;
    let value = params.value;
    let synonym_of = params.synonym_of;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), FieldTypeSid=crate::apis::urlencode(field_type_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Language", language.to_string());
    if let Some(local_var_param_value) = synonym_of {
        local_var_form_params.insert("SynonymOf", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Value", value.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateFieldValueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateFieldValueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_model_build(configuration: &configuration::Configuration, params: CreateModelBuildParams) -> Result<ResponseContent<CreateModelBuildSuccess>, Error<CreateModelBuildError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let status_callback = params.status_callback;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/ModelBuilds", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateModelBuildSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateModelBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_query(configuration: &configuration::Configuration, params: CreateQueryParams) -> Result<ResponseContent<CreateQuerySuccess>, Error<CreateQueryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let language = params.language;
    let query = params.query;
    let model_build = params.model_build;
    let tasks = params.tasks;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Queries", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Language", language.to_string());
    if let Some(local_var_param_value) = model_build {
        local_var_form_params.insert("ModelBuild", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Query", query.to_string());
    if let Some(local_var_param_value) = tasks {
        local_var_form_params.insert("Tasks", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateQuerySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateQueryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_sample(configuration: &configuration::Configuration, params: CreateSampleParams) -> Result<ResponseContent<CreateSampleSuccess>, Error<CreateSampleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;
    let language = params.language;
    let tagged_text = params.tagged_text;
    let source_channel = params.source_channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Language", language.to_string());
    if let Some(local_var_param_value) = source_channel {
        local_var_form_params.insert("SourceChannel", local_var_param_value.to_string());
    }
    local_var_form_params.insert("TaggedText", tagged_text.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSampleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSampleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_task(configuration: &configuration::Configuration, params: CreateTaskParams) -> Result<ResponseContent<CreateTaskSuccess>, Error<CreateTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let unique_name = params.unique_name;
    let actions = params.actions;
    let actions_url = params.actions_url;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = actions {
        local_var_form_params.insert("Actions", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = actions_url {
        local_var_form_params.insert("ActionsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("UniqueName", unique_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateTaskSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_webhook(configuration: &configuration::Configuration, params: CreateWebhookParams) -> Result<ResponseContent<CreateWebhookSuccess>, Error<CreateWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let events = params.events;
    let unique_name = params.unique_name;
    let webhook_url = params.webhook_url;
    let webhook_method = params.webhook_method;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Webhooks", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Events", events.to_string());
    local_var_form_params.insert("UniqueName", unique_name.to_string());
    if let Some(local_var_param_value) = webhook_method {
        local_var_form_params.insert("WebhookMethod", local_var_param_value.to_string());
    }
    local_var_form_params.insert("WebhookUrl", webhook_url.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_assistant(configuration: &configuration::Configuration, params: DeleteAssistantParams) -> Result<ResponseContent<DeleteAssistantSuccess>, Error<DeleteAssistantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteAssistantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteAssistantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_field(configuration: &configuration::Configuration, params: DeleteFieldParams) -> Result<ResponseContent<DeleteFieldSuccess>, Error<DeleteFieldError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteFieldSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteFieldError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_field_type(configuration: &configuration::Configuration, params: DeleteFieldTypeParams) -> Result<ResponseContent<DeleteFieldTypeSuccess>, Error<DeleteFieldTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/FieldTypes/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteFieldTypeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteFieldTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_field_value(configuration: &configuration::Configuration, params: DeleteFieldValueParams) -> Result<ResponseContent<DeleteFieldValueSuccess>, Error<DeleteFieldValueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let field_type_sid = params.field_type_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), FieldTypeSid=crate::apis::urlencode(field_type_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteFieldValueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteFieldValueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_model_build(configuration: &configuration::Configuration, params: DeleteModelBuildParams) -> Result<ResponseContent<DeleteModelBuildSuccess>, Error<DeleteModelBuildError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/ModelBuilds/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteModelBuildSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteModelBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_query(configuration: &configuration::Configuration, params: DeleteQueryParams) -> Result<ResponseContent<DeleteQuerySuccess>, Error<DeleteQueryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Queries/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteQuerySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteQueryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sample(configuration: &configuration::Configuration, params: DeleteSampleParams) -> Result<ResponseContent<DeleteSampleSuccess>, Error<DeleteSampleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSampleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSampleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_task(configuration: &configuration::Configuration, params: DeleteTaskParams) -> Result<ResponseContent<DeleteTaskSuccess>, Error<DeleteTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteTaskSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_webhook(configuration: &configuration::Configuration, params: DeleteWebhookParams) -> Result<ResponseContent<DeleteWebhookSuccess>, Error<DeleteWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Webhooks/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_assistant(configuration: &configuration::Configuration, params: FetchAssistantParams) -> Result<ResponseContent<FetchAssistantSuccess>, Error<FetchAssistantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchAssistantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchAssistantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_defaults(configuration: &configuration::Configuration, params: FetchDefaultsParams) -> Result<ResponseContent<FetchDefaultsSuccess>, Error<FetchDefaultsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Defaults", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchDefaultsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchDefaultsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_dialogue(configuration: &configuration::Configuration, params: FetchDialogueParams) -> Result<ResponseContent<FetchDialogueSuccess>, Error<FetchDialogueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Dialogues/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchDialogueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchDialogueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_field(configuration: &configuration::Configuration, params: FetchFieldParams) -> Result<ResponseContent<FetchFieldSuccess>, Error<FetchFieldError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFieldSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFieldError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_field_type(configuration: &configuration::Configuration, params: FetchFieldTypeParams) -> Result<ResponseContent<FetchFieldTypeSuccess>, Error<FetchFieldTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/FieldTypes/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFieldTypeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFieldTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_field_value(configuration: &configuration::Configuration, params: FetchFieldValueParams) -> Result<ResponseContent<FetchFieldValueSuccess>, Error<FetchFieldValueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let field_type_sid = params.field_type_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), FieldTypeSid=crate::apis::urlencode(field_type_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFieldValueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFieldValueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_model_build(configuration: &configuration::Configuration, params: FetchModelBuildParams) -> Result<ResponseContent<FetchModelBuildSuccess>, Error<FetchModelBuildError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/ModelBuilds/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchModelBuildSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchModelBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_query(configuration: &configuration::Configuration, params: FetchQueryParams) -> Result<ResponseContent<FetchQuerySuccess>, Error<FetchQueryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Queries/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchQuerySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchQueryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_sample(configuration: &configuration::Configuration, params: FetchSampleParams) -> Result<ResponseContent<FetchSampleSuccess>, Error<FetchSampleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSampleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSampleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns Style sheet JSON object for the Assistant
pub async fn fetch_style_sheet(configuration: &configuration::Configuration, params: FetchStyleSheetParams) -> Result<ResponseContent<FetchStyleSheetSuccess>, Error<FetchStyleSheetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/StyleSheet", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchStyleSheetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchStyleSheetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_task(configuration: &configuration::Configuration, params: FetchTaskParams) -> Result<ResponseContent<FetchTaskSuccess>, Error<FetchTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTaskSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns JSON actions for the Task.
pub async fn fetch_task_actions(configuration: &configuration::Configuration, params: FetchTaskActionsParams) -> Result<ResponseContent<FetchTaskActionsSuccess>, Error<FetchTaskActionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTaskActionsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTaskActionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_task_statistics(configuration: &configuration::Configuration, params: FetchTaskStatisticsParams) -> Result<ResponseContent<FetchTaskStatisticsSuccess>, Error<FetchTaskStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Statistics", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTaskStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTaskStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_webhook(configuration: &configuration::Configuration, params: FetchWebhookParams) -> Result<ResponseContent<FetchWebhookSuccess>, Error<FetchWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Webhooks/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_assistant(configuration: &configuration::Configuration, params: ListAssistantParams) -> Result<ResponseContent<ListAssistantSuccess>, Error<ListAssistantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAssistantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAssistantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_field(configuration: &configuration::Configuration, params: ListFieldParams) -> Result<ResponseContent<ListFieldSuccess>, Error<ListFieldError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFieldSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFieldError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_field_type(configuration: &configuration::Configuration, params: ListFieldTypeParams) -> Result<ResponseContent<ListFieldTypeSuccess>, Error<ListFieldTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/FieldTypes", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFieldTypeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFieldTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_field_value(configuration: &configuration::Configuration, params: ListFieldValueParams) -> Result<ResponseContent<ListFieldValueSuccess>, Error<ListFieldValueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let field_type_sid = params.field_type_sid;
    let language = params.language;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), FieldTypeSid=crate::apis::urlencode(field_type_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("Language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFieldValueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFieldValueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_model_build(configuration: &configuration::Configuration, params: ListModelBuildParams) -> Result<ResponseContent<ListModelBuildSuccess>, Error<ListModelBuildError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/ModelBuilds", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListModelBuildSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListModelBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_query(configuration: &configuration::Configuration, params: ListQueryParams) -> Result<ResponseContent<ListQuerySuccess>, Error<ListQueryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let language = params.language;
    let model_build = params.model_build;
    let status = params.status;
    let dialogue_sid = params.dialogue_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Queries", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("Language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = model_build {
        local_var_req_builder = local_var_req_builder.query(&[("ModelBuild", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dialogue_sid {
        local_var_req_builder = local_var_req_builder.query(&[("DialogueSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListQuerySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListQueryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_sample(configuration: &configuration::Configuration, params: ListSampleParams) -> Result<ResponseContent<ListSampleSuccess>, Error<ListSampleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;
    let language = params.language;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("Language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSampleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSampleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_task(configuration: &configuration::Configuration, params: ListTaskParams) -> Result<ResponseContent<ListTaskSuccess>, Error<ListTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListTaskSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_webhook(configuration: &configuration::Configuration, params: ListWebhookParams) -> Result<ResponseContent<ListWebhookSuccess>, Error<ListWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Webhooks", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_assistant(configuration: &configuration::Configuration, params: UpdateAssistantParams) -> Result<ResponseContent<UpdateAssistantSuccess>, Error<UpdateAssistantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let callback_events = params.callback_events;
    let callback_url = params.callback_url;
    let defaults = params.defaults;
    let development_stage = params.development_stage;
    let friendly_name = params.friendly_name;
    let log_queries = params.log_queries;
    let style_sheet = params.style_sheet;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = callback_events {
        local_var_form_params.insert("CallbackEvents", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = callback_url {
        local_var_form_params.insert("CallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = defaults {
        local_var_form_params.insert("Defaults", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = development_stage {
        local_var_form_params.insert("DevelopmentStage", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = log_queries {
        local_var_form_params.insert("LogQueries", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = style_sheet {
        local_var_form_params.insert("StyleSheet", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateAssistantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateAssistantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_defaults(configuration: &configuration::Configuration, params: UpdateDefaultsParams) -> Result<ResponseContent<UpdateDefaultsSuccess>, Error<UpdateDefaultsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let defaults = params.defaults;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Defaults", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = defaults {
        local_var_form_params.insert("Defaults", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateDefaultsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateDefaultsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_field_type(configuration: &configuration::Configuration, params: UpdateFieldTypeParams) -> Result<ResponseContent<UpdateFieldTypeSuccess>, Error<UpdateFieldTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;
    let friendly_name = params.friendly_name;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/FieldTypes/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateFieldTypeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateFieldTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_model_build(configuration: &configuration::Configuration, params: UpdateModelBuildParams) -> Result<ResponseContent<UpdateModelBuildSuccess>, Error<UpdateModelBuildError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/ModelBuilds/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateModelBuildSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateModelBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_query(configuration: &configuration::Configuration, params: UpdateQueryParams) -> Result<ResponseContent<UpdateQuerySuccess>, Error<UpdateQueryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;
    let sample_sid = params.sample_sid;
    let status = params.status;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Queries/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = sample_sid {
        local_var_form_params.insert("SampleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateQuerySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateQueryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_restore_assistant(configuration: &configuration::Configuration, params: UpdateRestoreAssistantParams) -> Result<ResponseContent<UpdateRestoreAssistantSuccess>, Error<UpdateRestoreAssistantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant = params.assistant;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/Restore", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Assistant", assistant.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRestoreAssistantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRestoreAssistantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_sample(configuration: &configuration::Configuration, params: UpdateSampleParams) -> Result<ResponseContent<UpdateSampleSuccess>, Error<UpdateSampleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;
    let sid = params.sid;
    let language = params.language;
    let source_channel = params.source_channel;
    let tagged_text = params.tagged_text;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = language {
        local_var_form_params.insert("Language", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = source_channel {
        local_var_form_params.insert("SourceChannel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = tagged_text {
        local_var_form_params.insert("TaggedText", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSampleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSampleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the style sheet for an Assistant identified by `assistant_sid`.
pub async fn update_style_sheet(configuration: &configuration::Configuration, params: UpdateStyleSheetParams) -> Result<ResponseContent<UpdateStyleSheetSuccess>, Error<UpdateStyleSheetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let style_sheet = params.style_sheet;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/StyleSheet", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = style_sheet {
        local_var_form_params.insert("StyleSheet", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateStyleSheetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateStyleSheetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_task(configuration: &configuration::Configuration, params: UpdateTaskParams) -> Result<ResponseContent<UpdateTaskSuccess>, Error<UpdateTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;
    let actions = params.actions;
    let actions_url = params.actions_url;
    let friendly_name = params.friendly_name;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = actions {
        local_var_form_params.insert("Actions", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = actions_url {
        local_var_form_params.insert("ActionsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateTaskSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the actions of an Task identified by {TaskSid} or {TaskUniqueName}.
pub async fn update_task_actions(configuration: &configuration::Configuration, params: UpdateTaskActionsParams) -> Result<ResponseContent<UpdateTaskActionsSuccess>, Error<UpdateTaskActionsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let task_sid = params.task_sid;
    let actions = params.actions;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), TaskSid=crate::apis::urlencode(task_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = actions {
        local_var_form_params.insert("Actions", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateTaskActionsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateTaskActionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_webhook(configuration: &configuration::Configuration, params: UpdateWebhookParams) -> Result<ResponseContent<UpdateWebhookSuccess>, Error<UpdateWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let assistant_sid = params.assistant_sid;
    let sid = params.sid;
    let events = params.events;
    let unique_name = params.unique_name;
    let webhook_method = params.webhook_method;
    let webhook_url = params.webhook_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Assistants/{AssistantSid}/Webhooks/{Sid}", local_var_configuration.base_path, AssistantSid=crate::apis::urlencode(assistant_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = events {
        local_var_form_params.insert("Events", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_method {
        local_var_form_params.insert("WebhookMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_url {
        local_var_form_params.insert("WebhookUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

