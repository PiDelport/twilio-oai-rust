/*
 * Twilio - Bulkexports
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_export_custom_job`
#[derive(Clone, Debug, Default)]
pub struct CreateExportCustomJobParams {
    /// The type of communication – Messages or Calls, Conferences, and Participants
    pub resource_type: String,
    /// The end day for the custom export specified as a string in the format of yyyy-mm-dd. End day is inclusive and must be 2 days earlier than the current UTC day.
    pub end_day: String,
    /// The friendly name specified when creating the job
    pub friendly_name: String,
    /// The start day for the custom export specified as a string in the format of yyyy-mm-dd
    pub start_day: String,
    /// The optional email to send the completion notification to. You can set both webhook, and email, or one or the other. If you set neither, the job will run but you will have to query to determine your job's status.
    pub email: Option<String>,
    /// This is the method used to call the webhook on completion of the job. If this is supplied, `WebhookUrl` must also be supplied.
    pub webhook_method: Option<String>,
    /// The optional webhook url called on completion of the job. If this is supplied, `WebhookMethod` must also be supplied. If you set neither webhook nor email, you will have to check your job's status manually.
    pub webhook_url: Option<String>
}

/// struct for passing parameters to the method `delete_job`
#[derive(Clone, Debug, Default)]
pub struct DeleteJobParams {
    /// The unique string that that we created to identify the Bulk Export job
    pub job_sid: String
}

/// struct for passing parameters to the method `fetch_day`
#[derive(Clone, Debug, Default)]
pub struct FetchDayParams {
    /// The type of communication – Messages, Calls, Conferences, and Participants
    pub resource_type: String,
    /// The ISO 8601 format date of the resources in the file, for a UTC day
    pub day: String
}

/// struct for passing parameters to the method `fetch_export`
#[derive(Clone, Debug, Default)]
pub struct FetchExportParams {
    /// The type of communication – Messages, Calls, Conferences, and Participants
    pub resource_type: String
}

/// struct for passing parameters to the method `fetch_export_configuration`
#[derive(Clone, Debug, Default)]
pub struct FetchExportConfigurationParams {
    /// The type of communication – Messages, Calls, Conferences, and Participants
    pub resource_type: String
}

/// struct for passing parameters to the method `fetch_job`
#[derive(Clone, Debug, Default)]
pub struct FetchJobParams {
    /// The unique string that that we created to identify the Bulk Export job
    pub job_sid: String
}

/// struct for passing parameters to the method `list_day`
#[derive(Clone, Debug, Default)]
pub struct ListDayParams {
    /// The type of communication – Messages, Calls, Conferences, and Participants
    pub resource_type: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_export_custom_job`
#[derive(Clone, Debug, Default)]
pub struct ListExportCustomJobParams {
    /// The type of communication – Messages, Calls, Conferences, and Participants
    pub resource_type: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_export_configuration`
#[derive(Clone, Debug, Default)]
pub struct UpdateExportConfigurationParams {
    /// The type of communication – Messages, Calls, Conferences, and Participants
    pub resource_type: String,
    /// If true, Twilio will automatically generate every day's file when the day is over.
    pub enabled: Option<bool>,
    /// Sets whether Twilio should call a webhook URL when the automatic generation is complete, using GET or POST. The actual destination is set in the webhook_url
    pub webhook_method: Option<String>,
    /// Stores the URL destination for the method specified in webhook_method.
    pub webhook_url: Option<String>
}


/// struct for typed successes of method `create_export_custom_job`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateExportCustomJobSuccess {
    Status201(crate::models::BulkexportsV1ExportExportCustomJob),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_job`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteJobSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_day`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDaySuccess {
    Status307(crate::models::BulkexportsV1ExportDayInstance),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_export`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExportSuccess {
    Status200(crate::models::BulkexportsV1Export),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_export_configuration`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExportConfigurationSuccess {
    Status200(crate::models::BulkexportsV1ExportConfiguration),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_job`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchJobSuccess {
    Status200(crate::models::BulkexportsV1ExportJob),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_day`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDaySuccess {
    Status200(crate::models::ListDayResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_export_custom_job`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExportCustomJobSuccess {
    Status200(crate::models::ListExportCustomJobResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_export_configuration`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateExportConfigurationSuccess {
    Status200(crate::models::BulkexportsV1ExportConfiguration),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_export_custom_job`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateExportCustomJobError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_job`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteJobError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_day`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDayError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_export`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExportError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_export_configuration`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExportConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_job`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchJobError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_day`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDayError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_export_custom_job`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExportCustomJobError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_export_configuration`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateExportConfigurationError {
    UnknownValue(serde_json::Value),
}


pub async fn create_export_custom_job(configuration: &configuration::Configuration, params: CreateExportCustomJobParams) -> Result<ResponseContent<CreateExportCustomJobSuccess>, Error<CreateExportCustomJobError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let resource_type = params.resource_type;
    let end_day = params.end_day;
    let friendly_name = params.friendly_name;
    let start_day = params.start_day;
    let email = params.email;
    let webhook_method = params.webhook_method;
    let webhook_url = params.webhook_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Exports/{ResourceType}/Jobs", local_var_configuration.base_path, ResourceType=crate::apis::urlencode(resource_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = email {
        local_var_form_params.insert("Email", local_var_param_value.to_string());
    }
    local_var_form_params.insert("EndDay", end_day.to_string());
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("StartDay", start_day.to_string());
    if let Some(local_var_param_value) = webhook_method {
        local_var_form_params.insert("WebhookMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_url {
        local_var_form_params.insert("WebhookUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateExportCustomJobSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateExportCustomJobError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_job(configuration: &configuration::Configuration, params: DeleteJobParams) -> Result<ResponseContent<DeleteJobSuccess>, Error<DeleteJobError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let job_sid = params.job_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Exports/Jobs/{JobSid}", local_var_configuration.base_path, JobSid=crate::apis::urlencode(job_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteJobSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteJobError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Day.
pub async fn fetch_day(configuration: &configuration::Configuration, params: FetchDayParams) -> Result<ResponseContent<FetchDaySuccess>, Error<FetchDayError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let resource_type = params.resource_type;
    let day = params.day;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Exports/{ResourceType}/Days/{Day}", local_var_configuration.base_path, ResourceType=crate::apis::urlencode(resource_type), Day=crate::apis::urlencode(day));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchDaySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchDayError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Export.
pub async fn fetch_export(configuration: &configuration::Configuration, params: FetchExportParams) -> Result<ResponseContent<FetchExportSuccess>, Error<FetchExportError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let resource_type = params.resource_type;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Exports/{ResourceType}", local_var_configuration.base_path, ResourceType=crate::apis::urlencode(resource_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchExportSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchExportError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Export Configuration.
pub async fn fetch_export_configuration(configuration: &configuration::Configuration, params: FetchExportConfigurationParams) -> Result<ResponseContent<FetchExportConfigurationSuccess>, Error<FetchExportConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let resource_type = params.resource_type;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Exports/{ResourceType}/Configuration", local_var_configuration.base_path, ResourceType=crate::apis::urlencode(resource_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchExportConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchExportConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_job(configuration: &configuration::Configuration, params: FetchJobParams) -> Result<ResponseContent<FetchJobSuccess>, Error<FetchJobError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let job_sid = params.job_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Exports/Jobs/{JobSid}", local_var_configuration.base_path, JobSid=crate::apis::urlencode(job_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchJobSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchJobError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Days for a resource.
pub async fn list_day(configuration: &configuration::Configuration, params: ListDayParams) -> Result<ResponseContent<ListDaySuccess>, Error<ListDayError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let resource_type = params.resource_type;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Exports/{ResourceType}/Days", local_var_configuration.base_path, ResourceType=crate::apis::urlencode(resource_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListDaySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListDayError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_export_custom_job(configuration: &configuration::Configuration, params: ListExportCustomJobParams) -> Result<ResponseContent<ListExportCustomJobSuccess>, Error<ListExportCustomJobError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let resource_type = params.resource_type;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Exports/{ResourceType}/Jobs", local_var_configuration.base_path, ResourceType=crate::apis::urlencode(resource_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListExportCustomJobSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListExportCustomJobError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Export Configuration.
pub async fn update_export_configuration(configuration: &configuration::Configuration, params: UpdateExportConfigurationParams) -> Result<ResponseContent<UpdateExportConfigurationSuccess>, Error<UpdateExportConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let resource_type = params.resource_type;
    let enabled = params.enabled;
    let webhook_method = params.webhook_method;
    let webhook_url = params.webhook_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Exports/{ResourceType}/Configuration", local_var_configuration.base_path, ResourceType=crate::apis::urlencode(resource_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = enabled {
        local_var_form_params.insert("Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_method {
        local_var_form_params.insert("WebhookMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_url {
        local_var_form_params.insert("WebhookUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateExportConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateExportConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

