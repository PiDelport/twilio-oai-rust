/*
 * Twilio - Chat
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_channel`]
#[derive(Clone, Debug, Default)]
pub struct CreateChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to create the resource under.
    pub service_sid: String,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The visibility of the channel. Can be: `public` or `private` and defaults to `public`.
    pub _type: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL. This value must be 64 characters or less in length and be unique within the Service.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method [`create_credential`]
#[derive(Clone, Debug, Default)]
pub struct CreateCredentialParams {
    /// The type of push-notification service the credential is for. Can be: `gcm`, `fcm`, or `apn`.
    pub _type: String,
    /// [GCM only] The API key for the project that was obtained from the Google Developer console for your GCM Service application credential.
    pub api_key: Option<String>,
    /// [APN only] The URL encoded representation of the certificate. For example,  `-----BEGIN CERTIFICATE----- MIIFnTCCBIWgAwIBAgIIAjy9H849+E8wDQYJKoZIhvcNAQEFBQAwgZYxCzAJBgNV.....A== -----END CERTIFICATE-----`
    pub certificate: Option<String>,
    /// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// [APN only] The URL encoded representation of the private key. For example, `-----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEAuyf/lNrH9ck8DmNyo3fGgvCI1l9s+cmBY3WIz+cUDqmxiieR. -----END RSA PRIVATE KEY-----`
    pub private_key: Option<String>,
    /// [APN only] Whether to send the credential to sandbox APNs. Can be `true` to send to sandbox APNs or `false` to send to production.
    pub sandbox: Option<bool>,
    /// [FCM only] The **Server key** of your project from the Firebase console, found under Settings / Cloud messaging.
    pub secret: Option<String>
}

/// struct for passing parameters to the method [`create_invite`]
#[derive(Clone, Debug, Default)]
pub struct CreateInviteParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to create the resource under.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the new resource belongs to.
    pub channel_sid: String,
    /// The `identity` value that uniquely identifies the new resource's [User](https://www.twilio.com/docs/api/chat/rest/v1/user) within the [Service](https://www.twilio.com/docs/api/chat/rest/v1/service). See [access tokens](https://www.twilio.com/docs/api/chat/guides/create-tokens) for more info.
    pub identity: String,
    /// The SID of the [Role](https://www.twilio.com/docs/api/chat/rest/roles) assigned to the new member.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`create_member`]
#[derive(Clone, Debug, Default)]
pub struct CreateMemberParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to create the resource under.
    pub service_sid: String,
    /// The unique ID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the new member belongs to. Can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The `identity` value that uniquely identifies the new resource's [User](https://www.twilio.com/docs/api/chat/rest/v1/user) within the [Service](https://www.twilio.com/docs/api/chat/rest/services). See [access tokens](https://www.twilio.com/docs/api/chat/guides/create-tokens) for more details.
    pub identity: String,
    /// The SID of the [Role](https://www.twilio.com/docs/api/chat/rest/roles) to assign to the member. The default roles are those specified on the [Service](https://www.twilio.com/docs/chat/api/services).
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`create_message`]
#[derive(Clone, Debug, Default)]
pub struct CreateMessageParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to create the resource under.
    pub service_sid: String,
    /// The unique ID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the new resource belongs to. Can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The message to send to the channel. Can also be an empty string or `null`, which sets the value as an empty string. You can send structured data in the body by serializing it as a string.
    pub body: String,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// The [identity](https://www.twilio.com/docs/api/chat/guides/identity) of the new message's author. The default value is `system`.
    pub from: Option<String>
}

/// struct for passing parameters to the method [`create_role`]
#[derive(Clone, Debug, Default)]
pub struct CreateRoleParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to create the resource under.
    pub service_sid: String,
    /// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
    pub friendly_name: String,
    /// A permission that you grant to the new role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. The values for this parameter depend on the role's `type` and are described in the documentation.
    pub permission: Vec<String>,
    /// The type of role. Can be: `channel` for [Channel](https://www.twilio.com/docs/chat/api/channels) roles or `deployment` for [Service](https://www.twilio.com/docs/chat/api/services) roles.
    pub _type: String
}

/// struct for passing parameters to the method [`create_service`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceParams {
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: String
}

/// struct for passing parameters to the method [`create_user`]
#[derive(Clone, Debug, Default)]
pub struct CreateUserParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to create the resource under.
    pub service_sid: String,
    /// The `identity` value that uniquely identifies the new resource's [User](https://www.twilio.com/docs/api/chat/rest/v1/user) within the [Service](https://www.twilio.com/docs/api/chat/rest/v1/service). This value is often a username or email address. See the Identity documentation for more details.
    pub identity: String,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// A descriptive string that you create to describe the new resource. This value is often used for display purposes.
    pub friendly_name: Option<String>,
    /// The SID of the [Role](https://www.twilio.com/docs/api/chat/rest/roles) assigned to the new User.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`delete_channel`]
#[derive(Clone, Debug, Default)]
pub struct DeleteChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to delete the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Channel resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_credential`]
#[derive(Clone, Debug, Default)]
pub struct DeleteCredentialParams {
    /// The Twilio-provided string that uniquely identifies the Credential resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_invite`]
#[derive(Clone, Debug, Default)]
pub struct DeleteInviteParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to delete the resource from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the resource to delete belongs to.
    pub channel_sid: String,
    /// The Twilio-provided string that uniquely identifies the Invite resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_member`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMemberParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to delete the resource from.
    pub service_sid: String,
    /// The unique ID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the message belongs to.  Can be the Channel's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The Twilio-provided string that uniquely identifies the Member resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_message`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMessageParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to delete the resource from.
    pub service_sid: String,
    /// The unique ID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the message to delete belongs to.  Can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The Twilio-provided string that uniquely identifies the Message resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_role`]
#[derive(Clone, Debug, Default)]
pub struct DeleteRoleParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to delete the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Role resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_service`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    /// The Twilio-provided string that uniquely identifies the Service resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_user`]
#[derive(Clone, Debug, Default)]
pub struct DeleteUserParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to delete the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the User resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_channel`]
#[derive(Clone, Debug, Default)]
pub struct FetchChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to fetch the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Channel resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_credential`]
#[derive(Clone, Debug, Default)]
pub struct FetchCredentialParams {
    /// The Twilio-provided string that uniquely identifies the Credential resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_invite`]
#[derive(Clone, Debug, Default)]
pub struct FetchInviteParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to fetch the resource from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the resource to fetch belongs to.
    pub channel_sid: String,
    /// The Twilio-provided string that uniquely identifies the Invite resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_member`]
#[derive(Clone, Debug, Default)]
pub struct FetchMemberParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to fetch the resource from.
    pub service_sid: String,
    /// The unique ID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the member to fetch belongs to. Can be the Channel resource's `sid` or `unique_name` value.
    pub channel_sid: String,
    /// The Twilio-provided string that uniquely identifies the Member resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_message`]
#[derive(Clone, Debug, Default)]
pub struct FetchMessageParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to fetch the resource from.
    pub service_sid: String,
    /// The unique ID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the message to fetch belongs to. Can be the Channel's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The Twilio-provided string that uniquely identifies the Message resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_role`]
#[derive(Clone, Debug, Default)]
pub struct FetchRoleParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to fetch the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Role resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceParams {
    /// The Twilio-provided string that uniquely identifies the Service resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_user`]
#[derive(Clone, Debug, Default)]
pub struct FetchUserParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to fetch the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the User resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`list_channel`]
#[derive(Clone, Debug, Default)]
pub struct ListChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to read the resources from.
    pub service_sid: String,
    /// The visibility of the Channels to read. Can be: `public` or `private` and defaults to `public`.
    pub _type: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_credential`]
#[derive(Clone, Debug, Default)]
pub struct ListCredentialParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_invite`]
#[derive(Clone, Debug, Default)]
pub struct ListInviteParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to read the resources from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the resources to read belong to.
    pub channel_sid: String,
    /// The [User](https://www.twilio.com/docs/api/chat/rest/v1/user)'s `identity` value of the resources to read. See [access tokens](https://www.twilio.com/docs/api/chat/guides/create-tokens) for more details.
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_member`]
#[derive(Clone, Debug, Default)]
pub struct ListMemberParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to read the resources from.
    pub service_sid: String,
    /// The unique ID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the members to read belong to. Can be the Channel resource's `sid` or `unique_name` value.
    pub channel_sid: String,
    /// The [User](https://www.twilio.com/docs/api/chat/rest/v1/user)'s `identity` value of the resources to read. See [access tokens](https://www.twilio.com/docs/api/chat/guides/create-tokens) for more details.
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_message`]
#[derive(Clone, Debug, Default)]
pub struct ListMessageParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to read the resources from.
    pub service_sid: String,
    /// The unique ID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the message to read belongs to. Can be the Channel's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The sort order of the returned messages. Can be: `asc` (ascending) or `desc` (descending) with `asc` as the default.
    pub order: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_role`]
#[derive(Clone, Debug, Default)]
pub struct ListRoleParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to read the resources from.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_user`]
#[derive(Clone, Debug, Default)]
pub struct ListUserParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to read the resources from.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_user_channel`]
#[derive(Clone, Debug, Default)]
pub struct ListUserChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to read the resources from.
    pub service_sid: String,
    /// The SID of the [User](https://www.twilio.com/docs/api/chat/rest/users) to read the User Channel resources from.
    pub user_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`update_channel`]
#[derive(Clone, Debug, Default)]
pub struct UpdateChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to update the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Channel resource to update.
    pub sid: String,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL. This value must be 64 characters or less in length and be unique within the Service.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method [`update_credential`]
#[derive(Clone, Debug, Default)]
pub struct UpdateCredentialParams {
    /// The Twilio-provided string that uniquely identifies the Credential resource to update.
    pub sid: String,
    /// [GCM only] The API key for the project that was obtained from the Google Developer console for your GCM Service application credential.
    pub api_key: Option<String>,
    /// [APN only] The URL encoded representation of the certificate. For example,  `-----BEGIN CERTIFICATE----- MIIFnTCCBIWgAwIBAgIIAjy9H849+E8wDQYJKoZIhvcNAQEFBQAwgZYxCzAJBgNV.....A== -----END CERTIFICATE-----`
    pub certificate: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// [APN only] The URL encoded representation of the private key. For example, `-----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEAuyf/lNrH9ck8DmNyo3fGgvCI1l9s+cmBY3WIz+cUDqmxiieR. -----END RSA PRIVATE KEY-----`
    pub private_key: Option<String>,
    /// [APN only] Whether to send the credential to sandbox APNs. Can be `true` to send to sandbox APNs or `false` to send to production.
    pub sandbox: Option<bool>,
    /// [FCM only] The **Server key** of your project from the Firebase console, found under Settings / Cloud messaging.
    pub secret: Option<String>
}

/// struct for passing parameters to the method [`update_member`]
#[derive(Clone, Debug, Default)]
pub struct UpdateMemberParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to update the resource from.
    pub service_sid: String,
    /// The unique ID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the member to update belongs to. Can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The Twilio-provided string that uniquely identifies the Member resource to update.
    pub sid: String,
    /// The index of the last [Message](https://www.twilio.com/docs/api/chat/rest/messages) that the Member has read within the [Channel](https://www.twilio.com/docs/api/chat/rest/channels).
    pub last_consumed_message_index: Option<i32>,
    /// The SID of the [Role](https://www.twilio.com/docs/api/chat/rest/roles) to assign to the member. The default roles are those specified on the [Service](https://www.twilio.com/docs/chat/api/services).
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`update_message`]
#[derive(Clone, Debug, Default)]
pub struct UpdateMessageParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to update the resource from.
    pub service_sid: String,
    /// The unique ID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the message belongs to. Can be the Channel's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The Twilio-provided string that uniquely identifies the Message resource to update.
    pub sid: String,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// The message to send to the channel. Can also be an empty string or `null`, which sets the value as an empty string. You can send structured data in the body by serializing it as a string.
    pub body: Option<String>
}

/// struct for passing parameters to the method [`update_role`]
#[derive(Clone, Debug, Default)]
pub struct UpdateRoleParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to update the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Role resource to update.
    pub sid: String,
    /// A permission that you grant to the role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. The values for this parameter depend on the role's `type` and are described in the documentation.
    pub permission: Vec<String>
}

/// struct for passing parameters to the method [`update_service`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceParams {
    /// The Twilio-provided string that uniquely identifies the Service resource to update.
    pub sid: String,
    /// DEPRECATED. The interval in seconds between consumption reports submission batches from client endpoints.
    pub consumption_report_interval: Option<i32>,
    /// The channel role assigned to a channel creator when they join a new channel. See the [Roles endpoint](https://www.twilio.com/docs/chat/api/roles) for more details.
    pub default_channel_creator_role_sid: Option<String>,
    /// The channel role assigned to users when they are added to a channel. See the [Roles endpoint](https://www.twilio.com/docs/chat/api/roles) for more details.
    pub default_channel_role_sid: Option<String>,
    /// The service role assigned to users when they are added to the service. See the [Roles endpoint](https://www.twilio.com/docs/chat/api/roles) for more details.
    pub default_service_role_sid: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The maximum number of Members that can be added to Channels within this Service. Can be up to 1,000.
    pub limits_channel_members: Option<i32>,
    /// The maximum number of Channels Users can be a Member of within this Service. Can be up to 1,000.
    pub limits_user_channels: Option<i32>,
    /// Whether to send a notification when a member is added to a channel. Can be: `true` or `false` and the default is `false`.
    pub notifications_added_to_channel_enabled: Option<bool>,
    /// The template to use to create the notification text displayed when a member is added to a channel and `notifications.added_to_channel.enabled` is `true`.
    pub notifications_added_to_channel_template: Option<String>,
    /// Whether to send a notification when a user is invited to a channel. Can be: `true` or `false` and the default is `false`.
    pub notifications_invited_to_channel_enabled: Option<bool>,
    /// The template to use to create the notification text displayed when a user is invited to a channel and `notifications.invited_to_channel.enabled` is `true`.
    pub notifications_invited_to_channel_template: Option<String>,
    /// Whether to send a notification when a new message is added to a channel. Can be: `true` or `false` and the default is `false`.
    pub notifications_new_message_enabled: Option<bool>,
    /// The template to use to create the notification text displayed when a new message is added to a channel and `notifications.new_message.enabled` is `true`.
    pub notifications_new_message_template: Option<String>,
    /// Whether to send a notification to a user when they are removed from a channel. Can be: `true` or `false` and the default is `false`.
    pub notifications_removed_from_channel_enabled: Option<bool>,
    /// The template to use to create the notification text displayed to a user when they are removed from a channel and `notifications.removed_from_channel.enabled` is `true`.
    pub notifications_removed_from_channel_template: Option<String>,
    /// The URL for post-event webhooks, which are called by using the `webhook_method`. See [Webhook Events](https://www.twilio.com/docs/api/chat/webhooks) for more details.
    pub post_webhook_url: Option<String>,
    /// The URL for pre-event webhooks, which are called by using the `webhook_method`. See [Webhook Events](https://www.twilio.com/docs/api/chat/webhooks) for more details.
    pub pre_webhook_url: Option<String>,
    /// Whether to enable the [Reachability Indicator](https://www.twilio.com/docs/chat/reachability-indicator) for this Service instance. The default is `false`.
    pub reachability_enabled: Option<bool>,
    /// Whether to enable the [Message Consumption Horizon](https://www.twilio.com/docs/chat/consumption-horizon) feature. The default is `true`.
    pub read_status_enabled: Option<bool>,
    /// How long in seconds after a `started typing` event until clients should assume that user is no longer typing, even if no `ended typing` message was received.  The default is 5 seconds.
    pub typing_indicator_timeout: Option<i32>,
    /// The list of WebHook events that are enabled for this Service instance. See [Webhook Events](https://www.twilio.com/docs/chat/webhook-events) for more details.
    pub webhook_filters: Option<Vec<String>>,
    /// The HTTP method to use for calls to the `pre_webhook_url` and `post_webhook_url` webhooks.  Can be: `POST` or `GET` and the default is `POST`. See [Webhook Events](https://www.twilio.com/docs/chat/webhook-events) for more details.
    pub webhook_method: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_channel_add.url`.
    pub webhooks_on_channel_add_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_channel_add` event using the `webhooks.on_channel_add.method` HTTP method.
    pub webhooks_on_channel_add_url: Option<String>,
    /// The URL of the webhook to call in response to the `on_channel_added` event`.
    pub webhooks_on_channel_added_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_channel_added` event using the `webhooks.on_channel_added.method` HTTP method.
    pub webhooks_on_channel_added_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_channel_destroy.url`.
    pub webhooks_on_channel_destroy_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_channel_destroy` event using the `webhooks.on_channel_destroy.method` HTTP method.
    pub webhooks_on_channel_destroy_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_channel_destroyed.url`.
    pub webhooks_on_channel_destroyed_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_channel_added` event using the `webhooks.on_channel_destroyed.method` HTTP method.
    pub webhooks_on_channel_destroyed_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_channel_update.url`.
    pub webhooks_on_channel_update_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_channel_update` event using the `webhooks.on_channel_update.method` HTTP method.
    pub webhooks_on_channel_update_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_channel_updated.url`.
    pub webhooks_on_channel_updated_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_channel_updated` event using the `webhooks.on_channel_updated.method` HTTP method.
    pub webhooks_on_channel_updated_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_member_add.url`.
    pub webhooks_on_member_add_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_member_add` event using the `webhooks.on_member_add.method` HTTP method.
    pub webhooks_on_member_add_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_channel_updated.url`.
    pub webhooks_on_member_added_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_channel_updated` event using the `webhooks.on_channel_updated.method` HTTP method.
    pub webhooks_on_member_added_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_member_remove.url`.
    pub webhooks_on_member_remove_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_member_remove` event using the `webhooks.on_member_remove.method` HTTP method.
    pub webhooks_on_member_remove_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_member_removed.url`.
    pub webhooks_on_member_removed_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_member_removed` event using the `webhooks.on_member_removed.method` HTTP method.
    pub webhooks_on_member_removed_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_message_remove.url`.
    pub webhooks_on_message_remove_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_message_remove` event using the `webhooks.on_message_remove.method` HTTP method.
    pub webhooks_on_message_remove_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_message_removed.url`.
    pub webhooks_on_message_removed_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_message_removed` event using the `webhooks.on_message_removed.method` HTTP method.
    pub webhooks_on_message_removed_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_message_send.url`.
    pub webhooks_on_message_send_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_message_send` event using the `webhooks.on_message_send.method` HTTP method.
    pub webhooks_on_message_send_url: Option<String>,
    /// The URL of the webhook to call in response to the `on_message_sent` event`.
    pub webhooks_on_message_sent_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_message_sent` event using the `webhooks.on_message_sent.method` HTTP method.
    pub webhooks_on_message_sent_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_message_update.url`.
    pub webhooks_on_message_update_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_message_update` event using the `webhooks.on_message_update.method` HTTP method.
    pub webhooks_on_message_update_url: Option<String>,
    /// The HTTP method to use when calling the `webhooks.on_message_updated.url`.
    pub webhooks_on_message_updated_method: Option<String>,
    /// The URL of the webhook to call in response to the `on_message_updated` event using the `webhooks.on_message_updated.method` HTTP method.
    pub webhooks_on_message_updated_url: Option<String>
}

/// struct for passing parameters to the method [`update_user`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to update the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the User resource to update.
    pub sid: String,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// A descriptive string that you create to describe the resource. It is often used for display purposes.
    pub friendly_name: Option<String>,
    /// The SID of the [Role](https://www.twilio.com/docs/api/chat/rest/roles) assigned to this user.
    pub role_sid: Option<String>
}


/// struct for typed successes of method [`create_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelSuccess {
    Status201(crate::models::ChatV1ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialSuccess {
    Status201(crate::models::ChatV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInviteSuccess {
    Status201(crate::models::ChatV1ServiceChannelInvite),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMemberSuccess {
    Status201(crate::models::ChatV1ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageSuccess {
    Status201(crate::models::ChatV1ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleSuccess {
    Status201(crate::models::ChatV1ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceSuccess {
    Status201(crate::models::ChatV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserSuccess {
    Status201(crate::models::ChatV1ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInviteSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMemberSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelSuccess {
    Status200(crate::models::ChatV1ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialSuccess {
    Status200(crate::models::ChatV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInviteSuccess {
    Status200(crate::models::ChatV1ServiceChannelInvite),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMemberSuccess {
    Status200(crate::models::ChatV1ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessageSuccess {
    Status200(crate::models::ChatV1ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoleSuccess {
    Status200(crate::models::ChatV1ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceSuccess {
    Status200(crate::models::ChatV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserSuccess {
    Status200(crate::models::ChatV1ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelSuccess {
    Status200(crate::models::ListChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialSuccess {
    Status200(crate::models::ListCredentialResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInviteSuccess {
    Status200(crate::models::ListInviteResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMemberSuccess {
    Status200(crate::models::ListMemberResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessageSuccess {
    Status200(crate::models::ListMessageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoleSuccess {
    Status200(crate::models::ListRoleResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceSuccess {
    Status200(crate::models::ListServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserSuccess {
    Status200(crate::models::ListUserResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_user_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserChannelSuccess {
    Status200(crate::models::ListUserChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelSuccess {
    Status200(crate::models::ChatV1ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialSuccess {
    Status200(crate::models::ChatV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMemberSuccess {
    Status200(crate::models::ChatV1ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageSuccess {
    Status200(crate::models::ChatV1ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleSuccess {
    Status200(crate::models::ChatV1ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceSuccess {
    Status200(crate::models::ChatV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserSuccess {
    Status200(crate::models::ChatV1ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_user_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserError {
    UnknownValue(serde_json::Value),
}


pub async fn create_channel(configuration: &configuration::Configuration, params: CreateChannelParams) -> Result<ResponseContent<CreateChannelSuccess>, Error<CreateChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let _type = params._type;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = _type {
        local_var_form_params.insert("Type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_credential(configuration: &configuration::Configuration, params: CreateCredentialParams) -> Result<ResponseContent<CreateCredentialSuccess>, Error<CreateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let _type = params._type;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_invite(configuration: &configuration::Configuration, params: CreateInviteParams) -> Result<ResponseContent<CreateInviteSuccess>, Error<CreateInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_member(configuration: &configuration::Configuration, params: CreateMemberParams) -> Result<ResponseContent<CreateMemberSuccess>, Error<CreateMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_message(configuration: &configuration::Configuration, params: CreateMessageParams) -> Result<ResponseContent<CreateMessageSuccess>, Error<CreateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let body = params.body;
    let attributes = params.attributes;
    let from = params.from;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Body", body.to_string());
    if let Some(local_var_param_value) = from {
        local_var_form_params.insert("From", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_role(configuration: &configuration::Configuration, params: CreateRoleParams) -> Result<ResponseContent<CreateRoleSuccess>, Error<CreateRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let friendly_name = params.friendly_name;
    let permission = params.permission;
    let _type = params._type;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Roles", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("Permission", permission.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_service(configuration: &configuration::Configuration, params: CreateServiceParams) -> Result<ResponseContent<CreateServiceSuccess>, Error<CreateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_user(configuration: &configuration::Configuration, params: CreateUserParams) -> Result<ResponseContent<CreateUserSuccess>, Error<CreateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_channel(configuration: &configuration::Configuration, params: DeleteChannelParams) -> Result<ResponseContent<DeleteChannelSuccess>, Error<DeleteChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_credential(configuration: &configuration::Configuration, params: DeleteCredentialParams) -> Result<ResponseContent<DeleteCredentialSuccess>, Error<DeleteCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_invite(configuration: &configuration::Configuration, params: DeleteInviteParams) -> Result<ResponseContent<DeleteInviteSuccess>, Error<DeleteInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_member(configuration: &configuration::Configuration, params: DeleteMemberParams) -> Result<ResponseContent<DeleteMemberSuccess>, Error<DeleteMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_message(configuration: &configuration::Configuration, params: DeleteMessageParams) -> Result<ResponseContent<DeleteMessageSuccess>, Error<DeleteMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_role(configuration: &configuration::Configuration, params: DeleteRoleParams) -> Result<ResponseContent<DeleteRoleSuccess>, Error<DeleteRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<ResponseContent<DeleteServiceSuccess>, Error<DeleteServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_user(configuration: &configuration::Configuration, params: DeleteUserParams) -> Result<ResponseContent<DeleteUserSuccess>, Error<DeleteUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_channel(configuration: &configuration::Configuration, params: FetchChannelParams) -> Result<ResponseContent<FetchChannelSuccess>, Error<FetchChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_credential(configuration: &configuration::Configuration, params: FetchCredentialParams) -> Result<ResponseContent<FetchCredentialSuccess>, Error<FetchCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_invite(configuration: &configuration::Configuration, params: FetchInviteParams) -> Result<ResponseContent<FetchInviteSuccess>, Error<FetchInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_member(configuration: &configuration::Configuration, params: FetchMemberParams) -> Result<ResponseContent<FetchMemberSuccess>, Error<FetchMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_message(configuration: &configuration::Configuration, params: FetchMessageParams) -> Result<ResponseContent<FetchMessageSuccess>, Error<FetchMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_role(configuration: &configuration::Configuration, params: FetchRoleParams) -> Result<ResponseContent<FetchRoleSuccess>, Error<FetchRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_service(configuration: &configuration::Configuration, params: FetchServiceParams) -> Result<ResponseContent<FetchServiceSuccess>, Error<FetchServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user(configuration: &configuration::Configuration, params: FetchUserParams) -> Result<ResponseContent<FetchUserSuccess>, Error<FetchUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_channel(configuration: &configuration::Configuration, params: ListChannelParams) -> Result<ResponseContent<ListChannelSuccess>, Error<ListChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let _type = params._type;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = _type {
        local_var_req_builder = local_var_req_builder.query(&[("Type", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_credential(configuration: &configuration::Configuration, params: ListCredentialParams) -> Result<ResponseContent<ListCredentialSuccess>, Error<ListCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_invite(configuration: &configuration::Configuration, params: ListInviteParams) -> Result<ResponseContent<ListInviteSuccess>, Error<ListInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_member(configuration: &configuration::Configuration, params: ListMemberParams) -> Result<ResponseContent<ListMemberSuccess>, Error<ListMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_message(configuration: &configuration::Configuration, params: ListMessageParams) -> Result<ResponseContent<ListMessageSuccess>, Error<ListMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let order = params.order;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_role(configuration: &configuration::Configuration, params: ListRoleParams) -> Result<ResponseContent<ListRoleSuccess>, Error<ListRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Roles", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_service(configuration: &configuration::Configuration, params: ListServiceParams) -> Result<ResponseContent<ListServiceSuccess>, Error<ListServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_user(configuration: &configuration::Configuration, params: ListUserParams) -> Result<ResponseContent<ListUserSuccess>, Error<ListUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all Channels for a given User.
pub async fn list_user_channel(configuration: &configuration::Configuration, params: ListUserChannelParams) -> Result<ResponseContent<ListUserChannelSuccess>, Error<ListUserChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users/{UserSid}/Channels", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), UserSid=crate::apis::urlencode(user_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_channel(configuration: &configuration::Configuration, params: UpdateChannelParams) -> Result<ResponseContent<UpdateChannelSuccess>, Error<UpdateChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_credential(configuration: &configuration::Configuration, params: UpdateCredentialParams) -> Result<ResponseContent<UpdateCredentialSuccess>, Error<UpdateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_member(configuration: &configuration::Configuration, params: UpdateMemberParams) -> Result<ResponseContent<UpdateMemberSuccess>, Error<UpdateMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let last_consumed_message_index = params.last_consumed_message_index;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = last_consumed_message_index {
        local_var_form_params.insert("LastConsumedMessageIndex", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_message(configuration: &configuration::Configuration, params: UpdateMessageParams) -> Result<ResponseContent<UpdateMessageSuccess>, Error<UpdateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let attributes = params.attributes;
    let body = params.body;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_role(configuration: &configuration::Configuration, params: UpdateRoleParams) -> Result<ResponseContent<UpdateRoleSuccess>, Error<UpdateRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let permission = params.permission;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Permission", permission.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_service(configuration: &configuration::Configuration, params: UpdateServiceParams) -> Result<ResponseContent<UpdateServiceSuccess>, Error<UpdateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let consumption_report_interval = params.consumption_report_interval;
    let default_channel_creator_role_sid = params.default_channel_creator_role_sid;
    let default_channel_role_sid = params.default_channel_role_sid;
    let default_service_role_sid = params.default_service_role_sid;
    let friendly_name = params.friendly_name;
    let limits_channel_members = params.limits_channel_members;
    let limits_user_channels = params.limits_user_channels;
    let notifications_added_to_channel_enabled = params.notifications_added_to_channel_enabled;
    let notifications_added_to_channel_template = params.notifications_added_to_channel_template;
    let notifications_invited_to_channel_enabled = params.notifications_invited_to_channel_enabled;
    let notifications_invited_to_channel_template = params.notifications_invited_to_channel_template;
    let notifications_new_message_enabled = params.notifications_new_message_enabled;
    let notifications_new_message_template = params.notifications_new_message_template;
    let notifications_removed_from_channel_enabled = params.notifications_removed_from_channel_enabled;
    let notifications_removed_from_channel_template = params.notifications_removed_from_channel_template;
    let post_webhook_url = params.post_webhook_url;
    let pre_webhook_url = params.pre_webhook_url;
    let reachability_enabled = params.reachability_enabled;
    let read_status_enabled = params.read_status_enabled;
    let typing_indicator_timeout = params.typing_indicator_timeout;
    let webhook_filters = params.webhook_filters;
    let webhook_method = params.webhook_method;
    let webhooks_on_channel_add_method = params.webhooks_on_channel_add_method;
    let webhooks_on_channel_add_url = params.webhooks_on_channel_add_url;
    let webhooks_on_channel_added_method = params.webhooks_on_channel_added_method;
    let webhooks_on_channel_added_url = params.webhooks_on_channel_added_url;
    let webhooks_on_channel_destroy_method = params.webhooks_on_channel_destroy_method;
    let webhooks_on_channel_destroy_url = params.webhooks_on_channel_destroy_url;
    let webhooks_on_channel_destroyed_method = params.webhooks_on_channel_destroyed_method;
    let webhooks_on_channel_destroyed_url = params.webhooks_on_channel_destroyed_url;
    let webhooks_on_channel_update_method = params.webhooks_on_channel_update_method;
    let webhooks_on_channel_update_url = params.webhooks_on_channel_update_url;
    let webhooks_on_channel_updated_method = params.webhooks_on_channel_updated_method;
    let webhooks_on_channel_updated_url = params.webhooks_on_channel_updated_url;
    let webhooks_on_member_add_method = params.webhooks_on_member_add_method;
    let webhooks_on_member_add_url = params.webhooks_on_member_add_url;
    let webhooks_on_member_added_method = params.webhooks_on_member_added_method;
    let webhooks_on_member_added_url = params.webhooks_on_member_added_url;
    let webhooks_on_member_remove_method = params.webhooks_on_member_remove_method;
    let webhooks_on_member_remove_url = params.webhooks_on_member_remove_url;
    let webhooks_on_member_removed_method = params.webhooks_on_member_removed_method;
    let webhooks_on_member_removed_url = params.webhooks_on_member_removed_url;
    let webhooks_on_message_remove_method = params.webhooks_on_message_remove_method;
    let webhooks_on_message_remove_url = params.webhooks_on_message_remove_url;
    let webhooks_on_message_removed_method = params.webhooks_on_message_removed_method;
    let webhooks_on_message_removed_url = params.webhooks_on_message_removed_url;
    let webhooks_on_message_send_method = params.webhooks_on_message_send_method;
    let webhooks_on_message_send_url = params.webhooks_on_message_send_url;
    let webhooks_on_message_sent_method = params.webhooks_on_message_sent_method;
    let webhooks_on_message_sent_url = params.webhooks_on_message_sent_url;
    let webhooks_on_message_update_method = params.webhooks_on_message_update_method;
    let webhooks_on_message_update_url = params.webhooks_on_message_update_url;
    let webhooks_on_message_updated_method = params.webhooks_on_message_updated_method;
    let webhooks_on_message_updated_url = params.webhooks_on_message_updated_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = consumption_report_interval {
        local_var_form_params.insert("ConsumptionReportInterval", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_channel_creator_role_sid {
        local_var_form_params.insert("DefaultChannelCreatorRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_channel_role_sid {
        local_var_form_params.insert("DefaultChannelRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_service_role_sid {
        local_var_form_params.insert("DefaultServiceRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = limits_channel_members {
        local_var_form_params.insert("Limits.ChannelMembers", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = limits_user_channels {
        local_var_form_params.insert("Limits.UserChannels", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_added_to_channel_enabled {
        local_var_form_params.insert("Notifications.AddedToChannel.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_added_to_channel_template {
        local_var_form_params.insert("Notifications.AddedToChannel.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_invited_to_channel_enabled {
        local_var_form_params.insert("Notifications.InvitedToChannel.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_invited_to_channel_template {
        local_var_form_params.insert("Notifications.InvitedToChannel.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_new_message_enabled {
        local_var_form_params.insert("Notifications.NewMessage.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_new_message_template {
        local_var_form_params.insert("Notifications.NewMessage.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_removed_from_channel_enabled {
        local_var_form_params.insert("Notifications.RemovedFromChannel.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_removed_from_channel_template {
        local_var_form_params.insert("Notifications.RemovedFromChannel.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = post_webhook_url {
        local_var_form_params.insert("PostWebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = pre_webhook_url {
        local_var_form_params.insert("PreWebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_enabled {
        local_var_form_params.insert("ReachabilityEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = read_status_enabled {
        local_var_form_params.insert("ReadStatusEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = typing_indicator_timeout {
        local_var_form_params.insert("TypingIndicatorTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_filters {
        local_var_form_params.insert("WebhookFilters", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = webhook_method {
        local_var_form_params.insert("WebhookMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_add_method {
        local_var_form_params.insert("Webhooks.OnChannelAdd.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_add_url {
        local_var_form_params.insert("Webhooks.OnChannelAdd.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_added_method {
        local_var_form_params.insert("Webhooks.OnChannelAdded.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_added_url {
        local_var_form_params.insert("Webhooks.OnChannelAdded.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_destroy_method {
        local_var_form_params.insert("Webhooks.OnChannelDestroy.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_destroy_url {
        local_var_form_params.insert("Webhooks.OnChannelDestroy.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_destroyed_method {
        local_var_form_params.insert("Webhooks.OnChannelDestroyed.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_destroyed_url {
        local_var_form_params.insert("Webhooks.OnChannelDestroyed.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_update_method {
        local_var_form_params.insert("Webhooks.OnChannelUpdate.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_update_url {
        local_var_form_params.insert("Webhooks.OnChannelUpdate.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_updated_method {
        local_var_form_params.insert("Webhooks.OnChannelUpdated.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_updated_url {
        local_var_form_params.insert("Webhooks.OnChannelUpdated.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_add_method {
        local_var_form_params.insert("Webhooks.OnMemberAdd.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_add_url {
        local_var_form_params.insert("Webhooks.OnMemberAdd.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_added_method {
        local_var_form_params.insert("Webhooks.OnMemberAdded.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_added_url {
        local_var_form_params.insert("Webhooks.OnMemberAdded.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_remove_method {
        local_var_form_params.insert("Webhooks.OnMemberRemove.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_remove_url {
        local_var_form_params.insert("Webhooks.OnMemberRemove.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_removed_method {
        local_var_form_params.insert("Webhooks.OnMemberRemoved.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_removed_url {
        local_var_form_params.insert("Webhooks.OnMemberRemoved.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_remove_method {
        local_var_form_params.insert("Webhooks.OnMessageRemove.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_remove_url {
        local_var_form_params.insert("Webhooks.OnMessageRemove.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_removed_method {
        local_var_form_params.insert("Webhooks.OnMessageRemoved.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_removed_url {
        local_var_form_params.insert("Webhooks.OnMessageRemoved.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_send_method {
        local_var_form_params.insert("Webhooks.OnMessageSend.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_send_url {
        local_var_form_params.insert("Webhooks.OnMessageSend.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_sent_method {
        local_var_form_params.insert("Webhooks.OnMessageSent.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_sent_url {
        local_var_form_params.insert("Webhooks.OnMessageSent.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_update_method {
        local_var_form_params.insert("Webhooks.OnMessageUpdate.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_update_url {
        local_var_form_params.insert("Webhooks.OnMessageUpdate.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_updated_method {
        local_var_form_params.insert("Webhooks.OnMessageUpdated.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_updated_url {
        local_var_form_params.insert("Webhooks.OnMessageUpdated.Url", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_user(configuration: &configuration::Configuration, params: UpdateUserParams) -> Result<ResponseContent<UpdateUserSuccess>, Error<UpdateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

