/*
 * Twilio - Chat
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.2
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_channel`
#[derive(Clone, Debug, Default)]
pub struct CreateChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to create the Channel resource under.
    pub service_sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// The `identity` of the User that created the channel. Default is: `system`.
    pub created_by: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was created. The default value is the current time set by the Chat service.  Note that this should only be used in cases where a Channel is being recreated from a backup/separate source.
    pub date_created: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was last updated. The default value is `null`. Note that this parameter should only be used in cases where a Channel is being recreated from a backup/separate source  and where a Message was previously updated.
    pub date_updated: Option<String>,
    /// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The visibility of the channel. Can be: `public` or `private` and defaults to `public`.
    pub _type: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the Channel resource's `sid` in the URL. This value must be 64 characters or less in length and be unique within the Service.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `create_channel_webhook`
#[derive(Clone, Debug, Default)]
pub struct CreateChannelWebhookParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) with the Channel to create the Webhook resource under.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the new Channel Webhook resource belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The type of webhook. Can be: `webhook`, `studio`, or `trigger`.
    pub _type: String,
    /// The events that cause us to call the Channel Webhook. Used when `type` is `webhook`. This parameter takes only one event. To specify more than one event, repeat this parameter for each event. For the list of possible events, see [Webhook Event Triggers](https://www.twilio.com/docs/chat/webhook-events#webhook-event-trigger).
    pub configuration_filters: Option<Vec<String>>,
    /// The SID of the Studio [Flow](https://www.twilio.com/docs/studio/rest-api/flow) to call when an event in `configuration.filters` occurs. Used only when `type` is `studio`.
    pub configuration_flow_sid: Option<String>,
    /// The HTTP method used to call `configuration.url`. Can be: `GET` or `POST` and the default is `POST`.
    pub configuration_method: Option<String>,
    /// The number of times to retry the webhook if the first attempt fails. Can be an integer between 0 and 3, inclusive, and the default is 0.
    pub configuration_retry_count: Option<i32>,
    /// A string that will cause us to call the webhook when it is present in a message body. This parameter takes only one trigger string. To specify more than one, repeat this parameter for each trigger string up to a total of 5 trigger strings. Used only when `type` = `trigger`.
    pub configuration_triggers: Option<Vec<String>>,
    /// The URL of the webhook to call using the `configuration.method`.
    pub configuration_url: Option<String>
}

/// struct for passing parameters to the method `create_credential`
#[derive(Clone, Debug, Default)]
pub struct CreateCredentialParams {
    /// The type of push-notification service the credential is for. Can be: `gcm`, `fcm`, or `apn`.
    pub _type: String,
    /// [GCM only] The API key for the project that was obtained from the Google Developer console for your GCM Service application credential.
    pub api_key: Option<String>,
    /// [APN only] The URL encoded representation of the certificate. For example,  `-----BEGIN CERTIFICATE----- MIIFnTCCBIWgAwIBAgIIAjy9H849+E8wDQYJKoZIhvcNAQEF.....A== -----END CERTIFICATE-----`
    pub certificate: Option<String>,
    /// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// [APN only] The URL encoded representation of the private key. For example, `-----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEAuyf/lNrH9ck8DmNyo3fG... -----END RSA PRIVATE KEY-----`
    pub private_key: Option<String>,
    /// [APN only] Whether to send the credential to sandbox APNs. Can be `true` to send to sandbox APNs or `false` to send to production.
    pub sandbox: Option<bool>,
    /// [FCM only] The **Server key** of your project from the Firebase console, found under Settings / Cloud messaging.
    pub secret: Option<String>
}

/// struct for passing parameters to the method `create_invite`
#[derive(Clone, Debug, Default)]
pub struct CreateInviteParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to create the Invite resource under.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the new Invite resource belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The `identity` value that uniquely identifies the new resource's [User](https://www.twilio.com/docs/chat/rest/user-resource) within the [Service](https://www.twilio.com/docs/chat/rest/service-resource). See [access tokens](https://www.twilio.com/docs/chat/create-tokens) for more info.
    pub identity: String,
    /// The SID of the [Role](https://www.twilio.com/docs/chat/rest/role-resource) assigned to the new member.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method `create_member`
#[derive(Clone, Debug, Default)]
pub struct CreateMemberParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to create the Member resource under.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the new Member resource belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The `identity` value that uniquely identifies the new resource's [User](https://www.twilio.com/docs/chat/rest/user-resource) within the [Service](https://www.twilio.com/docs/chat/rest/service-resource). See [access tokens](https://www.twilio.com/docs/chat/create-tokens) for more info.
    pub identity: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was created. The default value is the current time set by the Chat service.  Note that this parameter should only be used when a Member is being recreated from a backup/separate source.
    pub date_created: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was last updated. The default value is `null`. Note that this parameter should only be used when a Member is being recreated from a backup/separate source and where a Member was previously updated.
    pub date_updated: Option<String>,
    /// The index of the last [Message](https://www.twilio.com/docs/chat/rest/message-resource) in the [Channel](https://www.twilio.com/docs/chat/channels) that the Member has read. This parameter should only be used when recreating a Member from a backup/separate source.
    pub last_consumed_message_index: Option<i32>,
    /// The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp of the last [Message](https://www.twilio.com/docs/chat/rest/message-resource) read event for the Member within the [Channel](https://www.twilio.com/docs/chat/channels).
    pub last_consumption_timestamp: Option<String>,
    /// The SID of the [Role](https://www.twilio.com/docs/chat/rest/role-resource) to assign to the member. The default roles are those specified on the [Service](https://www.twilio.com/docs/chat/rest/service-resource).
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method `create_message`
#[derive(Clone, Debug, Default)]
pub struct CreateMessageParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to create the Message resource under.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the new Message resource belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// The message to send to the channel. Can be an empty string or `null`, which sets the value as an empty string. You can send structured data in the body by serializing it as a string.
    pub body: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was created. The default value is the current time set by the Chat service. This parameter should only be used when a Chat's history is being recreated from a backup/separate source.
    pub date_created: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was last updated.
    pub date_updated: Option<String>,
    /// The [Identity](https://www.twilio.com/docs/chat/identity) of the new message's author. The default value is `system`.
    pub from: Option<String>,
    /// The [Identity](https://www.twilio.com/docs/chat/identity) of the User who last updated the Message, if applicable.
    pub last_updated_by: Option<String>,
    /// The SID of the [Media](https://www.twilio.com/docs/chat/rest/media) to attach to the new Message.
    pub media_sid: Option<String>
}

/// struct for passing parameters to the method `create_role`
#[derive(Clone, Debug, Default)]
pub struct CreateRoleParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to create the Role resource under.
    pub service_sid: String,
    /// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
    pub friendly_name: String,
    /// A permission that you grant to the new role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. The values for this parameter depend on the role's `type`.
    pub permission: Vec<String>,
    /// The type of role. Can be: `channel` for [Channel](https://www.twilio.com/docs/chat/channels) roles or `deployment` for [Service](https://www.twilio.com/docs/chat/rest/service-resource) roles.
    pub _type: String
}

/// struct for passing parameters to the method `create_service`
#[derive(Clone, Debug, Default)]
pub struct CreateServiceParams {
    /// A descriptive string that you create to describe the new resource.
    pub friendly_name: String
}

/// struct for passing parameters to the method `create_user`
#[derive(Clone, Debug, Default)]
pub struct CreateUserParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to create the User resource under.
    pub service_sid: String,
    /// The `identity` value that uniquely identifies the new resource's [User](https://www.twilio.com/docs/chat/rest/user-resource) within the [Service](https://www.twilio.com/docs/chat/rest/service-resource). This value is often a username or email address. See the Identity documentation for more info.
    pub identity: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// A descriptive string that you create to describe the new resource. This value is often used for display purposes.
    pub friendly_name: Option<String>,
    /// The SID of the [Role](https://www.twilio.com/docs/chat/rest/role-resource) to assign to the new User.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method `delete_binding`
#[derive(Clone, Debug, Default)]
pub struct DeleteBindingParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to delete the Binding resource from.
    pub service_sid: String,
    /// The SID of the Binding resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_channel`
#[derive(Clone, Debug, Default)]
pub struct DeleteChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to delete the resource from.
    pub service_sid: String,
    /// The SID of the Channel resource to delete.  This value can be either the `sid` or the `unique_name` of the Channel resource to delete.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method `delete_channel_webhook`
#[derive(Clone, Debug, Default)]
pub struct DeleteChannelWebhookParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) with the Channel to delete the Webhook resource from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Channel Webhook resource to delete belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Channel Webhook resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_credential`
#[derive(Clone, Debug, Default)]
pub struct DeleteCredentialParams {
    /// The SID of the Credential resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_invite`
#[derive(Clone, Debug, Default)]
pub struct DeleteInviteParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to delete the Invite resource from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Invite resource to delete belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Invite resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_member`
#[derive(Clone, Debug, Default)]
pub struct DeleteMemberParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to delete the Member resource from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Member resource to delete belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Member resource to delete. This value can be either the Member's `sid` or its `identity` value.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method `delete_message`
#[derive(Clone, Debug, Default)]
pub struct DeleteMessageParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to delete the Message resource from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Message resource to delete belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Message resource to delete.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method `delete_role`
#[derive(Clone, Debug, Default)]
pub struct DeleteRoleParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to delete the Role resource from.
    pub service_sid: String,
    /// The SID of the Role resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_service`
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    /// The SID of the Service resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_user`
#[derive(Clone, Debug, Default)]
pub struct DeleteUserParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to delete the User resource from.
    pub service_sid: String,
    /// The SID of the User resource to delete. This value can be either the `sid` or the `identity` of the User resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_user_binding`
#[derive(Clone, Debug, Default)]
pub struct DeleteUserBindingParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to delete the User Binding resource from.
    pub service_sid: String,
    /// The SID of the [User](https://www.twilio.com/docs/chat/rest/user-resource) with the User Binding resources to delete.  See [push notification configuration](https://www.twilio.com/docs/chat/push-notification-configuration) for more info.
    pub user_sid: String,
    /// The SID of the User Binding resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_user_channel`
#[derive(Clone, Debug, Default)]
pub struct DeleteUserChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/api/chat/rest/services) to read the resources from.
    pub service_sid: String,
    /// The SID of the [User](https://www.twilio.com/docs/api/chat/rest/users) to read the User Channel resources from.
    pub user_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/api/chat/rest/channels) the resource belongs to.
    pub channel_sid: String
}

/// struct for passing parameters to the method `fetch_binding`
#[derive(Clone, Debug, Default)]
pub struct FetchBindingParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to fetch the Binding resource from.
    pub service_sid: String,
    /// The SID of the Binding resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_channel`
#[derive(Clone, Debug, Default)]
pub struct FetchChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to fetch the Channel resource from.
    pub service_sid: String,
    /// The SID of the Channel resource to fetch. This value can be either the `sid` or the `unique_name` of the Channel resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_channel_webhook`
#[derive(Clone, Debug, Default)]
pub struct FetchChannelWebhookParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) with the Channel to fetch the Webhook resource from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Channel Webhook resource to fetch belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Channel Webhook resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_credential`
#[derive(Clone, Debug, Default)]
pub struct FetchCredentialParams {
    /// The SID of the Credential resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_invite`
#[derive(Clone, Debug, Default)]
pub struct FetchInviteParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to fetch the Invite resource from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Invite resource to fetch belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Invite resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_member`
#[derive(Clone, Debug, Default)]
pub struct FetchMemberParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to fetch the Member resource from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Member resource to fetch belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Member resource to fetch. This value can be either the Member's `sid` or its `identity` value.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_message`
#[derive(Clone, Debug, Default)]
pub struct FetchMessageParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to fetch the Message resource from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Message resource to fetch belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Message resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_role`
#[derive(Clone, Debug, Default)]
pub struct FetchRoleParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to fetch the Role resource from.
    pub service_sid: String,
    /// The SID of the Role resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_service`
#[derive(Clone, Debug, Default)]
pub struct FetchServiceParams {
    /// The SID of the Service resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_user`
#[derive(Clone, Debug, Default)]
pub struct FetchUserParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to fetch the User resource from.
    pub service_sid: String,
    /// The SID of the User resource to fetch. This value can be either the `sid` or the `identity` of the User resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_user_binding`
#[derive(Clone, Debug, Default)]
pub struct FetchUserBindingParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to fetch the User Binding resource from.
    pub service_sid: String,
    /// The SID of the [User](https://www.twilio.com/docs/chat/rest/user-resource) with the User Binding resource to fetch.  See [push notification configuration](https://www.twilio.com/docs/chat/push-notification-configuration) for more info.
    pub user_sid: String,
    /// The SID of the User Binding resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_user_channel`
#[derive(Clone, Debug, Default)]
pub struct FetchUserChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to fetch the User Channel resource from.
    pub service_sid: String,
    /// The SID of the [User](https://www.twilio.com/docs/chat/rest/user-resource) to fetch the User Channel resource from. This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) that has the User Channel to fetch. This value can be either the `sid` or the `unique_name` of the Channel to fetch.
    pub channel_sid: String
}

/// struct for passing parameters to the method `list_binding`
#[derive(Clone, Debug, Default)]
pub struct ListBindingParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to read the Binding resources from.
    pub service_sid: String,
    /// The push technology used by the Binding resources to read.  Can be: `apn`, `gcm`, or `fcm`.  See [push notification configuration](https://www.twilio.com/docs/chat/push-notification-configuration) for more info.
    pub binding_type: Option<Vec<String>>,
    /// The [User](https://www.twilio.com/docs/chat/rest/user-resource)'s `identity` value of the resources to read. See [access tokens](https://www.twilio.com/docs/chat/create-tokens) for more details.
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_channel`
#[derive(Clone, Debug, Default)]
pub struct ListChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to read the Channel resources from.
    pub service_sid: String,
    /// The visibility of the Channels to read. Can be: `public` or `private` and defaults to `public`.
    pub _type: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_channel_webhook`
#[derive(Clone, Debug, Default)]
pub struct ListChannelWebhookParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) with the Channel to read the resources from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Channel Webhook resources to read belong to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_credential`
#[derive(Clone, Debug, Default)]
pub struct ListCredentialParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_invite`
#[derive(Clone, Debug, Default)]
pub struct ListInviteParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to read the Invite resources from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Invite resources to read belong to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The [User](https://www.twilio.com/docs/chat/rest/user-resource)'s `identity` value of the resources to read. See [access tokens](https://www.twilio.com/docs/chat/create-tokens) for more details.
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_member`
#[derive(Clone, Debug, Default)]
pub struct ListMemberParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to read the Member resources from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Member resources to read belong to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The [User](https://www.twilio.com/docs/chat/rest/user-resource)'s `identity` value of the Member resources to read. See [access tokens](https://www.twilio.com/docs/chat/create-tokens) for more details.
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_message`
#[derive(Clone, Debug, Default)]
pub struct ListMessageParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to read the Message resources from.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Message resource to read belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The sort order of the returned messages. Can be: `asc` (ascending) or `desc` (descending) with `asc` as the default.
    pub order: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_role`
#[derive(Clone, Debug, Default)]
pub struct ListRoleParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to read the Role resources from.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_service`
#[derive(Clone, Debug, Default)]
pub struct ListServiceParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_user`
#[derive(Clone, Debug, Default)]
pub struct ListUserParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to read the User resources from.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_user_binding`
#[derive(Clone, Debug, Default)]
pub struct ListUserBindingParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to read the User Binding resources from.
    pub service_sid: String,
    /// The SID of the [User](https://www.twilio.com/docs/chat/rest/user-resource) with the User Binding resources to read.  See [push notification configuration](https://www.twilio.com/docs/chat/push-notification-configuration) for more info.
    pub user_sid: String,
    /// The push technology used by the User Binding resources to read. Can be: `apn`, `gcm`, or `fcm`.  See [push notification configuration](https://www.twilio.com/docs/chat/push-notification-configuration) for more info.
    pub binding_type: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_user_channel`
#[derive(Clone, Debug, Default)]
pub struct ListUserChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to read the User Channel resources from.
    pub service_sid: String,
    /// The SID of the [User](https://www.twilio.com/docs/chat/rest/user-resource) to read the User Channel resources from. This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_channel`
#[derive(Clone, Debug, Default)]
pub struct UpdateChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to update the Channel resource in.
    pub service_sid: String,
    /// The SID of the Channel resource to update. This value can be either the `sid` or the `unique_name` of the Channel resource to update.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// The `identity` of the User that created the channel. Default is: `system`.
    pub created_by: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was created. The default value is the current time set by the Chat service.  Note that this should only be used in cases where a Channel is being recreated from a backup/separate source.
    pub date_created: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was last updated.
    pub date_updated: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 256 characters long.
    pub friendly_name: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL. This value must be 256 characters or less in length and unique within the Service.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `update_channel_webhook`
#[derive(Clone, Debug, Default)]
pub struct UpdateChannelWebhookParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) with the Channel that has the Webhook resource to update.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Channel Webhook resource to update belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Channel Webhook resource to update.
    pub sid: String,
    /// The events that cause us to call the Channel Webhook. Used when `type` is `webhook`. This parameter takes only one event. To specify more than one event, repeat this parameter for each event. For the list of possible events, see [Webhook Event Triggers](https://www.twilio.com/docs/chat/webhook-events#webhook-event-trigger).
    pub configuration_filters: Option<Vec<String>>,
    /// The SID of the Studio [Flow](https://www.twilio.com/docs/studio/rest-api/flow) to call when an event in `configuration.filters` occurs. Used only when `type` = `studio`.
    pub configuration_flow_sid: Option<String>,
    /// The HTTP method used to call `configuration.url`. Can be: `GET` or `POST` and the default is `POST`.
    pub configuration_method: Option<String>,
    /// The number of times to retry the webhook if the first attempt fails. Can be an integer between 0 and 3, inclusive, and the default is 0.
    pub configuration_retry_count: Option<i32>,
    /// A string that will cause us to call the webhook when it is present in a message body. This parameter takes only one trigger string. To specify more than one, repeat this parameter for each trigger string up to a total of 5 trigger strings. Used only when `type` = `trigger`.
    pub configuration_triggers: Option<Vec<String>>,
    /// The URL of the webhook to call using the `configuration.method`.
    pub configuration_url: Option<String>
}

/// struct for passing parameters to the method `update_credential`
#[derive(Clone, Debug, Default)]
pub struct UpdateCredentialParams {
    /// The SID of the Credential resource to update.
    pub sid: String,
    /// [GCM only] The API key for the project that was obtained from the Google Developer console for your GCM Service application credential.
    pub api_key: Option<String>,
    /// [APN only] The URL encoded representation of the certificate. For example,  `-----BEGIN CERTIFICATE----- MIIFnTCCBIWgAwIBAgIIAjy9H849+E8wDQYJKoZIhvcNAQEF.....A== -----END CERTIFICATE-----`
    pub certificate: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// [APN only] The URL encoded representation of the private key. For example, `-----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEAuyf/lNrH9ck8DmNyo3fG... -----END RSA PRIVATE KEY-----`
    pub private_key: Option<String>,
    /// [APN only] Whether to send the credential to sandbox APNs. Can be `true` to send to sandbox APNs or `false` to send to production.
    pub sandbox: Option<bool>,
    /// [FCM only] The **Server key** of your project from the Firebase console, found under Settings / Cloud messaging.
    pub secret: Option<String>
}

/// struct for passing parameters to the method `update_member`
#[derive(Clone, Debug, Default)]
pub struct UpdateMemberParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to update the Member resource in.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Member resource to update belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Member resource to update. This value can be either the Member's `sid` or its `identity` value.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was created. The default value is the current time set by the Chat service.  Note that this parameter should only be used when a Member is being recreated from a backup/separate source.
    pub date_created: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was last updated.
    pub date_updated: Option<String>,
    /// The index of the last [Message](https://www.twilio.com/docs/chat/rest/message-resource) that the Member has read within the [Channel](https://www.twilio.com/docs/chat/channels).
    pub last_consumed_message_index: Option<i32>,
    /// The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp of the last [Message](https://www.twilio.com/docs/chat/rest/message-resource) read event for the Member within the [Channel](https://www.twilio.com/docs/chat/channels).
    pub last_consumption_timestamp: Option<String>,
    /// The SID of the [Role](https://www.twilio.com/docs/chat/rest/role-resource) to assign to the member. The default roles are those specified on the [Service](https://www.twilio.com/docs/chat/rest/service-resource).
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method `update_message`
#[derive(Clone, Debug, Default)]
pub struct UpdateMessageParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to update the Message resource in.
    pub service_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Message resource to update belongs to. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The SID of the Message resource to update.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// The message to send to the channel. Can be an empty string or `null`, which sets the value as an empty string. You can send structured data in the body by serializing it as a string.
    pub body: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was created. The default value is the current time set by the Chat service. This parameter should only be used when a Chat's history is being recreated from a backup/separate source.
    pub date_created: Option<String>,
    /// The date, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format, to assign to the resource as the date it was last updated.
    pub date_updated: Option<String>,
    /// The [Identity](https://www.twilio.com/docs/chat/identity) of the message's author.
    pub from: Option<String>,
    /// The [Identity](https://www.twilio.com/docs/chat/identity) of the User who last updated the Message, if applicable.
    pub last_updated_by: Option<String>
}

/// struct for passing parameters to the method `update_role`
#[derive(Clone, Debug, Default)]
pub struct UpdateRoleParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to update the Role resource in.
    pub service_sid: String,
    /// The SID of the Role resource to update.
    pub sid: String,
    /// A permission that you grant to the role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. Note that the update action replaces all previously assigned permissions with those defined in the update action. To remove a permission, do not include it in the subsequent update action. The values for this parameter depend on the role's `type`.
    pub permission: Vec<String>
}

/// struct for passing parameters to the method `update_service`
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceParams {
    /// The SID of the Service resource to update.
    pub sid: String,
    /// DEPRECATED. The interval in seconds between consumption reports submission batches from client endpoints.
    pub consumption_report_interval: Option<i32>,
    /// The channel role assigned to a channel creator when they join a new channel. See the [Role resource](https://www.twilio.com/docs/chat/rest/role-resource) for more info about roles.
    pub default_channel_creator_role_sid: Option<String>,
    /// The channel role assigned to users when they are added to a channel. See the [Role resource](https://www.twilio.com/docs/chat/rest/role-resource) for more info about roles.
    pub default_channel_role_sid: Option<String>,
    /// The service role assigned to users when they are added to the service. See the [Role resource](https://www.twilio.com/docs/chat/rest/role-resource) for more info about roles.
    pub default_service_role_sid: Option<String>,
    /// A descriptive string that you create to describe the resource.
    pub friendly_name: Option<String>,
    /// The maximum number of Members that can be added to Channels within this Service. Can be up to 1,000.
    pub limits_channel_members: Option<i32>,
    /// The maximum number of Channels Users can be a Member of within this Service. Can be up to 1,000.
    pub limits_user_channels: Option<i32>,
    /// The message to send when a media message has no text. Can be used as placeholder message.
    pub media_compatibility_message: Option<String>,
    /// Whether to send a notification when a member is added to a channel. The default is `false`.
    pub notifications_added_to_channel_enabled: Option<bool>,
    /// The name of the sound to play when a member is added to a channel and `notifications.added_to_channel.enabled` is `true`.
    pub notifications_added_to_channel_sound: Option<String>,
    /// The template to use to create the notification text displayed when a member is added to a channel and `notifications.added_to_channel.enabled` is `true`.
    pub notifications_added_to_channel_template: Option<String>,
    /// Whether to send a notification when a user is invited to a channel. The default is `false`.
    pub notifications_invited_to_channel_enabled: Option<bool>,
    /// The name of the sound to play when a user is invited to a channel and `notifications.invited_to_channel.enabled` is `true`.
    pub notifications_invited_to_channel_sound: Option<String>,
    /// The template to use to create the notification text displayed when a user is invited to a channel and `notifications.invited_to_channel.enabled` is `true`.
    pub notifications_invited_to_channel_template: Option<String>,
    /// Whether to log notifications. The default is `false`.
    pub notifications_log_enabled: Option<bool>,
    /// Whether the new message badge is enabled. The default is `false`.
    pub notifications_new_message_badge_count_enabled: Option<bool>,
    /// Whether to send a notification when a new message is added to a channel. The default is `false`.
    pub notifications_new_message_enabled: Option<bool>,
    /// The name of the sound to play when a new message is added to a channel and `notifications.new_message.enabled` is `true`.
    pub notifications_new_message_sound: Option<String>,
    /// The template to use to create the notification text displayed when a new message is added to a channel and `notifications.new_message.enabled` is `true`.
    pub notifications_new_message_template: Option<String>,
    /// Whether to send a notification to a user when they are removed from a channel. The default is `false`.
    pub notifications_removed_from_channel_enabled: Option<bool>,
    /// The name of the sound to play to a user when they are removed from a channel and `notifications.removed_from_channel.enabled` is `true`.
    pub notifications_removed_from_channel_sound: Option<String>,
    /// The template to use to create the notification text displayed to a user when they are removed from a channel and `notifications.removed_from_channel.enabled` is `true`.
    pub notifications_removed_from_channel_template: Option<String>,
    /// The number of times to retry a call to the `post_webhook_url` if the request times out (after 5 seconds) or it receives a 429, 503, or 504 HTTP response. The default is 0, which means the call won't be retried.
    pub post_webhook_retry_count: Option<i32>,
    /// The URL for post-event webhooks, which are called by using the `webhook_method`. See [Webhook Events](https://www.twilio.com/docs/chat/webhook-events) for more details.
    pub post_webhook_url: Option<String>,
    /// The number of times to retry a call to the `pre_webhook_url` if the request times out (after 5 seconds) or it receives a 429, 503, or 504 HTTP response. Default retry count is 0 times, which means the call won't be retried.
    pub pre_webhook_retry_count: Option<i32>,
    /// The URL for pre-event webhooks, which are called by using the `webhook_method`. See [Webhook Events](https://www.twilio.com/docs/chat/webhook-events) for more details.
    pub pre_webhook_url: Option<String>,
    /// Whether to enable the [Reachability Indicator](https://www.twilio.com/docs/chat/reachability-indicator) for this Service instance. The default is `false`.
    pub reachability_enabled: Option<bool>,
    /// Whether to enable the [Message Consumption Horizon](https://www.twilio.com/docs/chat/consumption-horizon) feature. The default is `true`.
    pub read_status_enabled: Option<bool>,
    /// How long in seconds after a `started typing` event until clients should assume that user is no longer typing, even if no `ended typing` message was received.  The default is 5 seconds.
    pub typing_indicator_timeout: Option<i32>,
    /// The list of webhook events that are enabled for this Service instance. See [Webhook Events](https://www.twilio.com/docs/chat/webhook-events) for more details.
    pub webhook_filters: Option<Vec<String>>,
    /// The HTTP method to use for calls to the `pre_webhook_url` and `post_webhook_url` webhooks.  Can be: `POST` or `GET` and the default is `POST`. See [Webhook Events](https://www.twilio.com/docs/chat/webhook-events) for more details.
    pub webhook_method: Option<String>
}

/// struct for passing parameters to the method `update_user`
#[derive(Clone, Debug, Default)]
pub struct UpdateUserParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to update the User resource in.
    pub service_sid: String,
    /// The SID of the User resource to update. This value can be either the `sid` or the `identity` of the User resource to update.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A valid JSON string that contains application-specific data.
    pub attributes: Option<String>,
    /// A descriptive string that you create to describe the resource. It is often used for display purposes.
    pub friendly_name: Option<String>,
    /// The SID of the [Role](https://www.twilio.com/docs/chat/rest/role-resource) to assign to the User.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method `update_user_channel`
#[derive(Clone, Debug, Default)]
pub struct UpdateUserChannelParams {
    /// The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) to update the User Channel resource in.
    pub service_sid: String,
    /// The SID of the [User](https://www.twilio.com/docs/chat/rest/user-resource) to update the User Channel resource from. This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// The SID of the [Channel](https://www.twilio.com/docs/chat/channels) with the User Channel resource to update. This value can be the Channel resource's `sid` or `unique_name`.
    pub channel_sid: String,
    /// The index of the last [Message](https://www.twilio.com/docs/chat/rest/message-resource) in the [Channel](https://www.twilio.com/docs/chat/channels) that the Member has read.
    pub last_consumed_message_index: Option<i32>,
    /// The [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp of the last [Message](https://www.twilio.com/docs/chat/rest/message-resource) read event for the Member within the [Channel](https://www.twilio.com/docs/chat/channels).
    pub last_consumption_timestamp: Option<String>,
    /// The push notification level to assign to the User Channel. Can be: `default` or `muted`.
    pub notification_level: Option<String>
}


/// struct for typed successes of method `create_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelSuccess {
    Status201(crate::models::ChatV2ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_channel_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelWebhookSuccess {
    Status201(crate::models::ChatV2ServiceChannelChannelWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialSuccess {
    Status201(crate::models::ChatV2Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInviteSuccess {
    Status201(crate::models::ChatV2ServiceChannelInvite),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMemberSuccess {
    Status201(crate::models::ChatV2ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageSuccess {
    Status201(crate::models::ChatV2ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleSuccess {
    Status201(crate::models::ChatV2ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceSuccess {
    Status201(crate::models::ChatV2Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserSuccess {
    Status201(crate::models::ChatV2ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBindingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_channel_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelWebhookSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInviteSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMemberSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_user_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserBindingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_user_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBindingSuccess {
    Status200(crate::models::ChatV2ServiceBinding),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelSuccess {
    Status200(crate::models::ChatV2ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_channel_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelWebhookSuccess {
    Status200(crate::models::ChatV2ServiceChannelChannelWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialSuccess {
    Status200(crate::models::ChatV2Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInviteSuccess {
    Status200(crate::models::ChatV2ServiceChannelInvite),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMemberSuccess {
    Status200(crate::models::ChatV2ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessageSuccess {
    Status200(crate::models::ChatV2ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoleSuccess {
    Status200(crate::models::ChatV2ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceSuccess {
    Status200(crate::models::ChatV2Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserSuccess {
    Status200(crate::models::ChatV2ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_user_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserBindingSuccess {
    Status200(crate::models::ChatV2ServiceUserUserBinding),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_user_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserChannelSuccess {
    Status200(crate::models::ChatV2ServiceUserUserChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBindingSuccess {
    Status200(crate::models::ListBindingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelSuccess {
    Status200(crate::models::ListChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_channel_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelWebhookSuccess {
    Status200(crate::models::ListChannelWebhookResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialSuccess {
    Status200(crate::models::ListCredentialResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInviteSuccess {
    Status200(crate::models::ListInviteResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMemberSuccess {
    Status200(crate::models::ListMemberResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessageSuccess {
    Status200(crate::models::ListMessageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoleSuccess {
    Status200(crate::models::ListRoleResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceSuccess {
    Status200(crate::models::ListServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserSuccess {
    Status200(crate::models::ListUserResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_user_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserBindingSuccess {
    Status200(crate::models::ListUserBindingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_user_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserChannelSuccess {
    Status200(crate::models::ListUserChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelSuccess {
    Status200(crate::models::ChatV2ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_channel_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelWebhookSuccess {
    Status200(crate::models::ChatV2ServiceChannelChannelWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialSuccess {
    Status200(crate::models::ChatV2Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMemberSuccess {
    Status200(crate::models::ChatV2ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageSuccess {
    Status200(crate::models::ChatV2ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleSuccess {
    Status200(crate::models::ChatV2ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceSuccess {
    Status200(crate::models::ChatV2Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserSuccess {
    Status200(crate::models::ChatV2ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_user_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserChannelSuccess {
    Status200(crate::models::ChatV2ServiceUserUserChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_channel_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_channel_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_user_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_user_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_channel_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_user_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_user_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_channel_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_user_binding`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_user_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_channel_webhook`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_user_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserChannelError {
    UnknownValue(serde_json::Value),
}


pub async fn create_channel(configuration: &configuration::Configuration, params: CreateChannelParams) -> Result<ResponseContent<CreateChannelSuccess>, Error<CreateChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let created_by = params.created_by;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let friendly_name = params.friendly_name;
    let _type = params._type;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = created_by {
        local_var_form_params.insert("CreatedBy", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = _type {
        local_var_form_params.insert("Type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_channel_webhook(configuration: &configuration::Configuration, params: CreateChannelWebhookParams) -> Result<ResponseContent<CreateChannelWebhookSuccess>, Error<CreateChannelWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let _type = params._type;
    let configuration_filters = params.configuration_filters;
    let configuration_flow_sid = params.configuration_flow_sid;
    let configuration_method = params.configuration_method;
    let configuration_retry_count = params.configuration_retry_count;
    let configuration_triggers = params.configuration_triggers;
    let configuration_url = params.configuration_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = configuration_filters {
        local_var_form_params.insert("Configuration.Filters", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_flow_sid {
        local_var_form_params.insert("Configuration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_method {
        local_var_form_params.insert("Configuration.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_retry_count {
        local_var_form_params.insert("Configuration.RetryCount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_triggers {
        local_var_form_params.insert("Configuration.Triggers", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_url {
        local_var_form_params.insert("Configuration.Url", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateChannelWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateChannelWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_credential(configuration: &configuration::Configuration, params: CreateCredentialParams) -> Result<ResponseContent<CreateCredentialSuccess>, Error<CreateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let _type = params._type;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_invite(configuration: &configuration::Configuration, params: CreateInviteParams) -> Result<ResponseContent<CreateInviteSuccess>, Error<CreateInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_member(configuration: &configuration::Configuration, params: CreateMemberParams) -> Result<ResponseContent<CreateMemberSuccess>, Error<CreateMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let last_consumed_message_index = params.last_consumed_message_index;
    let last_consumption_timestamp = params.last_consumption_timestamp;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = last_consumed_message_index {
        local_var_form_params.insert("LastConsumedMessageIndex", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_consumption_timestamp {
        local_var_form_params.insert("LastConsumptionTimestamp", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_message(configuration: &configuration::Configuration, params: CreateMessageParams) -> Result<ResponseContent<CreateMessageSuccess>, Error<CreateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let body = params.body;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let from = params.from;
    let last_updated_by = params.last_updated_by;
    let media_sid = params.media_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = from {
        local_var_form_params.insert("From", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_updated_by {
        local_var_form_params.insert("LastUpdatedBy", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = media_sid {
        local_var_form_params.insert("MediaSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_role(configuration: &configuration::Configuration, params: CreateRoleParams) -> Result<ResponseContent<CreateRoleSuccess>, Error<CreateRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let friendly_name = params.friendly_name;
    let permission = params.permission;
    let _type = params._type;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Roles", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("Permission", permission.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_service(configuration: &configuration::Configuration, params: CreateServiceParams) -> Result<ResponseContent<CreateServiceSuccess>, Error<CreateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_user(configuration: &configuration::Configuration, params: CreateUserParams) -> Result<ResponseContent<CreateUserSuccess>, Error<CreateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_binding(configuration: &configuration::Configuration, params: DeleteBindingParams) -> Result<ResponseContent<DeleteBindingSuccess>, Error<DeleteBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Bindings/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_channel(configuration: &configuration::Configuration, params: DeleteChannelParams) -> Result<ResponseContent<DeleteChannelSuccess>, Error<DeleteChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_channel_webhook(configuration: &configuration::Configuration, params: DeleteChannelWebhookParams) -> Result<ResponseContent<DeleteChannelWebhookSuccess>, Error<DeleteChannelWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteChannelWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteChannelWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_credential(configuration: &configuration::Configuration, params: DeleteCredentialParams) -> Result<ResponseContent<DeleteCredentialSuccess>, Error<DeleteCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_invite(configuration: &configuration::Configuration, params: DeleteInviteParams) -> Result<ResponseContent<DeleteInviteSuccess>, Error<DeleteInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_member(configuration: &configuration::Configuration, params: DeleteMemberParams) -> Result<ResponseContent<DeleteMemberSuccess>, Error<DeleteMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_message(configuration: &configuration::Configuration, params: DeleteMessageParams) -> Result<ResponseContent<DeleteMessageSuccess>, Error<DeleteMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_role(configuration: &configuration::Configuration, params: DeleteRoleParams) -> Result<ResponseContent<DeleteRoleSuccess>, Error<DeleteRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<ResponseContent<DeleteServiceSuccess>, Error<DeleteServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_user(configuration: &configuration::Configuration, params: DeleteUserParams) -> Result<ResponseContent<DeleteUserSuccess>, Error<DeleteUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_user_binding(configuration: &configuration::Configuration, params: DeleteUserBindingParams) -> Result<ResponseContent<DeleteUserBindingSuccess>, Error<DeleteUserBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users/{UserSid}/Bindings/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), UserSid=crate::apis::urlencode(user_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUserBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUserBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes User from selected Channel.
pub async fn delete_user_channel(configuration: &configuration::Configuration, params: DeleteUserChannelParams) -> Result<ResponseContent<DeleteUserChannelSuccess>, Error<DeleteUserChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let channel_sid = params.channel_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), UserSid=crate::apis::urlencode(user_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUserChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUserChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_binding(configuration: &configuration::Configuration, params: FetchBindingParams) -> Result<ResponseContent<FetchBindingSuccess>, Error<FetchBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Bindings/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_channel(configuration: &configuration::Configuration, params: FetchChannelParams) -> Result<ResponseContent<FetchChannelSuccess>, Error<FetchChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_channel_webhook(configuration: &configuration::Configuration, params: FetchChannelWebhookParams) -> Result<ResponseContent<FetchChannelWebhookSuccess>, Error<FetchChannelWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchChannelWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchChannelWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_credential(configuration: &configuration::Configuration, params: FetchCredentialParams) -> Result<ResponseContent<FetchCredentialSuccess>, Error<FetchCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_invite(configuration: &configuration::Configuration, params: FetchInviteParams) -> Result<ResponseContent<FetchInviteSuccess>, Error<FetchInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_member(configuration: &configuration::Configuration, params: FetchMemberParams) -> Result<ResponseContent<FetchMemberSuccess>, Error<FetchMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_message(configuration: &configuration::Configuration, params: FetchMessageParams) -> Result<ResponseContent<FetchMessageSuccess>, Error<FetchMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_role(configuration: &configuration::Configuration, params: FetchRoleParams) -> Result<ResponseContent<FetchRoleSuccess>, Error<FetchRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_service(configuration: &configuration::Configuration, params: FetchServiceParams) -> Result<ResponseContent<FetchServiceSuccess>, Error<FetchServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user(configuration: &configuration::Configuration, params: FetchUserParams) -> Result<ResponseContent<FetchUserSuccess>, Error<FetchUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user_binding(configuration: &configuration::Configuration, params: FetchUserBindingParams) -> Result<ResponseContent<FetchUserBindingSuccess>, Error<FetchUserBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users/{UserSid}/Bindings/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), UserSid=crate::apis::urlencode(user_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUserBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUserBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user_channel(configuration: &configuration::Configuration, params: FetchUserChannelParams) -> Result<ResponseContent<FetchUserChannelSuccess>, Error<FetchUserChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let channel_sid = params.channel_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), UserSid=crate::apis::urlencode(user_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUserChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUserChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_binding(configuration: &configuration::Configuration, params: ListBindingParams) -> Result<ResponseContent<ListBindingSuccess>, Error<ListBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let binding_type = params.binding_type;
    let identity = params.identity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Bindings", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = binding_type {
        local_var_req_builder = local_var_req_builder.query(&[("BindingType", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_channel(configuration: &configuration::Configuration, params: ListChannelParams) -> Result<ResponseContent<ListChannelSuccess>, Error<ListChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let _type = params._type;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = _type {
        local_var_req_builder = local_var_req_builder.query(&[("Type", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_channel_webhook(configuration: &configuration::Configuration, params: ListChannelWebhookParams) -> Result<ResponseContent<ListChannelWebhookSuccess>, Error<ListChannelWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListChannelWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListChannelWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_credential(configuration: &configuration::Configuration, params: ListCredentialParams) -> Result<ResponseContent<ListCredentialSuccess>, Error<ListCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_invite(configuration: &configuration::Configuration, params: ListInviteParams) -> Result<ResponseContent<ListInviteSuccess>, Error<ListInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_member(configuration: &configuration::Configuration, params: ListMemberParams) -> Result<ResponseContent<ListMemberSuccess>, Error<ListMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_message(configuration: &configuration::Configuration, params: ListMessageParams) -> Result<ResponseContent<ListMessageSuccess>, Error<ListMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let order = params.order;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_role(configuration: &configuration::Configuration, params: ListRoleParams) -> Result<ResponseContent<ListRoleSuccess>, Error<ListRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Roles", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_service(configuration: &configuration::Configuration, params: ListServiceParams) -> Result<ResponseContent<ListServiceSuccess>, Error<ListServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_user(configuration: &configuration::Configuration, params: ListUserParams) -> Result<ResponseContent<ListUserSuccess>, Error<ListUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_user_binding(configuration: &configuration::Configuration, params: ListUserBindingParams) -> Result<ResponseContent<ListUserBindingSuccess>, Error<ListUserBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let binding_type = params.binding_type;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users/{UserSid}/Bindings", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), UserSid=crate::apis::urlencode(user_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = binding_type {
        local_var_req_builder = local_var_req_builder.query(&[("BindingType", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all Channels for a given User.
pub async fn list_user_channel(configuration: &configuration::Configuration, params: ListUserChannelParams) -> Result<ResponseContent<ListUserChannelSuccess>, Error<ListUserChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users/{UserSid}/Channels", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), UserSid=crate::apis::urlencode(user_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_channel(configuration: &configuration::Configuration, params: UpdateChannelParams) -> Result<ResponseContent<UpdateChannelSuccess>, Error<UpdateChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let created_by = params.created_by;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let friendly_name = params.friendly_name;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = created_by {
        local_var_form_params.insert("CreatedBy", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_channel_webhook(configuration: &configuration::Configuration, params: UpdateChannelWebhookParams) -> Result<ResponseContent<UpdateChannelWebhookSuccess>, Error<UpdateChannelWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let configuration_filters = params.configuration_filters;
    let configuration_flow_sid = params.configuration_flow_sid;
    let configuration_method = params.configuration_method;
    let configuration_retry_count = params.configuration_retry_count;
    let configuration_triggers = params.configuration_triggers;
    let configuration_url = params.configuration_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = configuration_filters {
        local_var_form_params.insert("Configuration.Filters", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_flow_sid {
        local_var_form_params.insert("Configuration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_method {
        local_var_form_params.insert("Configuration.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_retry_count {
        local_var_form_params.insert("Configuration.RetryCount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_triggers {
        local_var_form_params.insert("Configuration.Triggers", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_url {
        local_var_form_params.insert("Configuration.Url", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateChannelWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateChannelWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_credential(configuration: &configuration::Configuration, params: UpdateCredentialParams) -> Result<ResponseContent<UpdateCredentialSuccess>, Error<UpdateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_member(configuration: &configuration::Configuration, params: UpdateMemberParams) -> Result<ResponseContent<UpdateMemberSuccess>, Error<UpdateMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let last_consumed_message_index = params.last_consumed_message_index;
    let last_consumption_timestamp = params.last_consumption_timestamp;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_consumed_message_index {
        local_var_form_params.insert("LastConsumedMessageIndex", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_consumption_timestamp {
        local_var_form_params.insert("LastConsumptionTimestamp", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_message(configuration: &configuration::Configuration, params: UpdateMessageParams) -> Result<ResponseContent<UpdateMessageSuccess>, Error<UpdateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let body = params.body;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let from = params.from;
    let last_updated_by = params.last_updated_by;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = from {
        local_var_form_params.insert("From", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_updated_by {
        local_var_form_params.insert("LastUpdatedBy", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_role(configuration: &configuration::Configuration, params: UpdateRoleParams) -> Result<ResponseContent<UpdateRoleSuccess>, Error<UpdateRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let permission = params.permission;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Permission", permission.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_service(configuration: &configuration::Configuration, params: UpdateServiceParams) -> Result<ResponseContent<UpdateServiceSuccess>, Error<UpdateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let consumption_report_interval = params.consumption_report_interval;
    let default_channel_creator_role_sid = params.default_channel_creator_role_sid;
    let default_channel_role_sid = params.default_channel_role_sid;
    let default_service_role_sid = params.default_service_role_sid;
    let friendly_name = params.friendly_name;
    let limits_channel_members = params.limits_channel_members;
    let limits_user_channels = params.limits_user_channels;
    let media_compatibility_message = params.media_compatibility_message;
    let notifications_added_to_channel_enabled = params.notifications_added_to_channel_enabled;
    let notifications_added_to_channel_sound = params.notifications_added_to_channel_sound;
    let notifications_added_to_channel_template = params.notifications_added_to_channel_template;
    let notifications_invited_to_channel_enabled = params.notifications_invited_to_channel_enabled;
    let notifications_invited_to_channel_sound = params.notifications_invited_to_channel_sound;
    let notifications_invited_to_channel_template = params.notifications_invited_to_channel_template;
    let notifications_log_enabled = params.notifications_log_enabled;
    let notifications_new_message_badge_count_enabled = params.notifications_new_message_badge_count_enabled;
    let notifications_new_message_enabled = params.notifications_new_message_enabled;
    let notifications_new_message_sound = params.notifications_new_message_sound;
    let notifications_new_message_template = params.notifications_new_message_template;
    let notifications_removed_from_channel_enabled = params.notifications_removed_from_channel_enabled;
    let notifications_removed_from_channel_sound = params.notifications_removed_from_channel_sound;
    let notifications_removed_from_channel_template = params.notifications_removed_from_channel_template;
    let post_webhook_retry_count = params.post_webhook_retry_count;
    let post_webhook_url = params.post_webhook_url;
    let pre_webhook_retry_count = params.pre_webhook_retry_count;
    let pre_webhook_url = params.pre_webhook_url;
    let reachability_enabled = params.reachability_enabled;
    let read_status_enabled = params.read_status_enabled;
    let typing_indicator_timeout = params.typing_indicator_timeout;
    let webhook_filters = params.webhook_filters;
    let webhook_method = params.webhook_method;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = consumption_report_interval {
        local_var_form_params.insert("ConsumptionReportInterval", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_channel_creator_role_sid {
        local_var_form_params.insert("DefaultChannelCreatorRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_channel_role_sid {
        local_var_form_params.insert("DefaultChannelRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_service_role_sid {
        local_var_form_params.insert("DefaultServiceRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = limits_channel_members {
        local_var_form_params.insert("Limits.ChannelMembers", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = limits_user_channels {
        local_var_form_params.insert("Limits.UserChannels", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = media_compatibility_message {
        local_var_form_params.insert("Media.CompatibilityMessage", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_added_to_channel_enabled {
        local_var_form_params.insert("Notifications.AddedToChannel.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_added_to_channel_sound {
        local_var_form_params.insert("Notifications.AddedToChannel.Sound", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_added_to_channel_template {
        local_var_form_params.insert("Notifications.AddedToChannel.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_invited_to_channel_enabled {
        local_var_form_params.insert("Notifications.InvitedToChannel.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_invited_to_channel_sound {
        local_var_form_params.insert("Notifications.InvitedToChannel.Sound", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_invited_to_channel_template {
        local_var_form_params.insert("Notifications.InvitedToChannel.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_log_enabled {
        local_var_form_params.insert("Notifications.LogEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_new_message_badge_count_enabled {
        local_var_form_params.insert("Notifications.NewMessage.BadgeCountEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_new_message_enabled {
        local_var_form_params.insert("Notifications.NewMessage.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_new_message_sound {
        local_var_form_params.insert("Notifications.NewMessage.Sound", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_new_message_template {
        local_var_form_params.insert("Notifications.NewMessage.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_removed_from_channel_enabled {
        local_var_form_params.insert("Notifications.RemovedFromChannel.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_removed_from_channel_sound {
        local_var_form_params.insert("Notifications.RemovedFromChannel.Sound", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_removed_from_channel_template {
        local_var_form_params.insert("Notifications.RemovedFromChannel.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = post_webhook_retry_count {
        local_var_form_params.insert("PostWebhookRetryCount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = post_webhook_url {
        local_var_form_params.insert("PostWebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = pre_webhook_retry_count {
        local_var_form_params.insert("PreWebhookRetryCount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = pre_webhook_url {
        local_var_form_params.insert("PreWebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_enabled {
        local_var_form_params.insert("ReachabilityEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = read_status_enabled {
        local_var_form_params.insert("ReadStatusEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = typing_indicator_timeout {
        local_var_form_params.insert("TypingIndicatorTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_filters {
        local_var_form_params.insert("WebhookFilters", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = webhook_method {
        local_var_form_params.insert("WebhookMethod", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_user(configuration: &configuration::Configuration, params: UpdateUserParams) -> Result<ResponseContent<UpdateUserSuccess>, Error<UpdateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_user_channel(configuration: &configuration::Configuration, params: UpdateUserChannelParams) -> Result<ResponseContent<UpdateUserChannelSuccess>, Error<UpdateUserChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let channel_sid = params.channel_sid;
    let last_consumed_message_index = params.last_consumed_message_index;
    let last_consumption_timestamp = params.last_consumption_timestamp;
    let notification_level = params.notification_level;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), UserSid=crate::apis::urlencode(user_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = last_consumed_message_index {
        local_var_form_params.insert("LastConsumedMessageIndex", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_consumption_timestamp {
        local_var_form_params.insert("LastConsumptionTimestamp", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notification_level {
        local_var_form_params.insert("NotificationLevel", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateUserChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateUserChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

