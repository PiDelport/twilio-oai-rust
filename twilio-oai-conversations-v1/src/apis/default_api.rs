/*
 * Twilio - Conversations
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_conversation`]
#[derive(Clone, Debug, Default)]
pub struct CreateConversationParams {
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated.
    pub date_updated: Option<String>,
    /// The human-readable name of this conversation, limited to 256 characters. Optional.
    pub friendly_name: Option<String>,
    /// The unique ID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) this conversation belongs to.
    pub messaging_service_sid: Option<String>,
    /// Current state of this conversation. Can be either `active`, `inactive` or `closed` and defaults to `active`
    pub state: Option<String>,
    /// ISO8601 duration when conversation will be switched to `closed` state. Minimum value for this timer is 10 minutes.
    pub timers_closed: Option<String>,
    /// ISO8601 duration when conversation will be switched to `inactive` state. Minimum value for this timer is 1 minute.
    pub timers_inactive: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method [`create_conversation_message`]
#[derive(Clone, Debug, Default)]
pub struct CreateConversationMessageParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The channel specific identifier of the message's author. Defaults to `system`.
    pub author: Option<String>,
    /// The content of the message, can be up to 1,600 characters long.
    pub body: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated. `null` if the message has not been edited.
    pub date_updated: Option<String>,
    /// The Media SID to be attached to the new Message.
    pub media_sid: Option<String>
}

/// struct for passing parameters to the method [`create_conversation_participant`]
#[derive(Clone, Debug, Default)]
pub struct CreateConversationParticipantParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this participant.
    pub conversation_sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated.
    pub date_updated: Option<String>,
    /// A unique string identifier for the conversation participant as [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource). This parameter is non-null if (and only if) the participant is using the Conversations SDK to communicate. Limited to 256 characters.
    pub identity: Option<String>,
    /// The address of the participant's device, e.g. a phone or WhatsApp number. Together with the Proxy address, this determines a participant uniquely. This field (with proxy_address) is only null when the participant is interacting from an SDK endpoint (see the 'identity' field).
    pub messaging_binding_address: Option<String>,
    /// The address of the Twilio phone number that is used in Group MMS. Communication mask for the Conversation participant with Identity.
    pub messaging_binding_projected_address: Option<String>,
    /// The address of the Twilio phone number (or WhatsApp number) that the participant is in contact with. This field, together with participant address, is only null when the participant is interacting from an SDK endpoint (see the 'identity' field).
    pub messaging_binding_proxy_address: Option<String>,
    /// The SID of a conversation-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the participant.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`create_conversation_scoped_webhook`]
#[derive(Clone, Debug, Default)]
pub struct CreateConversationScopedWebhookParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this webhook.
    pub conversation_sid: String,
    /// The target of this webhook: `webhook`, `studio`, `trigger`
    pub target: String,
    /// The list of events, firing webhook event for this Conversation.
    pub configuration_filters: Option<Vec<String>>,
    /// The studio flow SID, where the webhook should be sent to.
    pub configuration_flow_sid: Option<String>,
    /// The HTTP method to be used when sending a webhook request.
    pub configuration_method: Option<String>,
    /// The message index for which and it's successors the webhook will be replayed. Not set by default
    pub configuration_replay_after: Option<i32>,
    /// The list of keywords, firing webhook event for this Conversation.
    pub configuration_triggers: Option<Vec<String>>,
    /// The absolute url the webhook request should be sent to.
    pub configuration_url: Option<String>
}

/// struct for passing parameters to the method [`create_credential`]
#[derive(Clone, Debug, Default)]
pub struct CreateCredentialParams {
    /// The type of push-notification service the credential is for. Can be: `fcm`, `gcm`, or `apn`.
    pub _type: String,
    /// [GCM only] The API key for the project that was obtained from the Google Developer console for your GCM Service application credential.
    pub api_key: Option<String>,
    /// [APN only] The URL encoded representation of the certificate. For example,  `-----BEGIN CERTIFICATE----- MIIFnTCCBIWgAwIBAgIIAjy9H849+E8wDQYJKoZIhvcNAQEF.....A== -----END CERTIFICATE-----`.
    pub certificate: Option<String>,
    /// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// [APN only] The URL encoded representation of the private key. For example, `-----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEAuyf/lNrH9ck8DmNyo3fG... -----END RSA PRIVATE KEY-----`.
    pub private_key: Option<String>,
    /// [APN only] Whether to send the credential to sandbox APNs. Can be `true` to send to sandbox APNs or `false` to send to production.
    pub sandbox: Option<bool>,
    /// [FCM only] The **Server key** of your project from the Firebase console, found under Settings / Cloud messaging.
    pub secret: Option<String>
}

/// struct for passing parameters to the method [`create_role`]
#[derive(Clone, Debug, Default)]
pub struct CreateRoleParams {
    /// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
    pub friendly_name: String,
    /// A permission that you grant to the new role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. The values for this parameter depend on the role's `type`.
    pub permission: Vec<String>,
    /// The type of role. Can be: `conversation` for [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) roles or `service` for [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) roles.
    pub _type: String
}

/// struct for passing parameters to the method [`create_service`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceParams {
    /// The human-readable name of this service, limited to 256 characters. Optional.
    pub friendly_name: String
}

/// struct for passing parameters to the method [`create_service_conversation`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceConversationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Conversation resource is associated with.
    pub chat_service_sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated.
    pub date_updated: Option<String>,
    /// The human-readable name of this conversation, limited to 256 characters. Optional.
    pub friendly_name: Option<String>,
    /// The unique ID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) this conversation belongs to.
    pub messaging_service_sid: Option<String>,
    /// Current state of this conversation. Can be either `active`, `inactive` or `closed` and defaults to `active`
    pub state: Option<String>,
    /// ISO8601 duration when conversation will be switched to `closed` state. Minimum value for this timer is 10 minutes.
    pub timers_closed: Option<String>,
    /// ISO8601 duration when conversation will be switched to `inactive` state. Minimum value for this timer is 1 minute.
    pub timers_inactive: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method [`create_service_conversation_message`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceConversationMessageParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The channel specific identifier of the message's author. Defaults to `system`.
    pub author: Option<String>,
    /// The content of the message, can be up to 1,600 characters long.
    pub body: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated. `null` if the message has not been edited.
    pub date_updated: Option<String>,
    /// The Media SID to be attached to the new Message.
    pub media_sid: Option<String>
}

/// struct for passing parameters to the method [`create_service_conversation_participant`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceConversationParticipantParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this participant.
    pub conversation_sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated.
    pub date_updated: Option<String>,
    /// A unique string identifier for the conversation participant as [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource). This parameter is non-null if (and only if) the participant is using the Conversation SDK to communicate. Limited to 256 characters.
    pub identity: Option<String>,
    /// The address of the participant's device, e.g. a phone or WhatsApp number. Together with the Proxy address, this determines a participant uniquely. This field (with proxy_address) is only null when the participant is interacting from an SDK endpoint (see the 'identity' field).
    pub messaging_binding_address: Option<String>,
    /// The address of the Twilio phone number that is used in Group MMS. Communication mask for the Conversation participant with Identity.
    pub messaging_binding_projected_address: Option<String>,
    /// The address of the Twilio phone number (or WhatsApp number) that the participant is in contact with. This field, together with participant address, is only null when the participant is interacting from an SDK endpoint (see the 'identity' field).
    pub messaging_binding_proxy_address: Option<String>,
    /// The SID of a conversation-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the participant.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`create_service_conversation_scoped_webhook`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceConversationScopedWebhookParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this webhook.
    pub conversation_sid: String,
    /// The target of this webhook: `webhook`, `studio`, `trigger`
    pub target: String,
    /// The list of events, firing webhook event for this Conversation.
    pub configuration_filters: Option<Vec<String>>,
    /// The studio flow SID, where the webhook should be sent to.
    pub configuration_flow_sid: Option<String>,
    /// The HTTP method to be used when sending a webhook request.
    pub configuration_method: Option<String>,
    /// The message index for which and it's successors the webhook will be replayed. Not set by default
    pub configuration_replay_after: Option<i32>,
    /// The list of keywords, firing webhook event for this Conversation.
    pub configuration_triggers: Option<Vec<String>>,
    /// The absolute url the webhook request should be sent to.
    pub configuration_url: Option<String>
}

/// struct for passing parameters to the method [`create_service_role`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceRoleParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to create the Role resource under.
    pub chat_service_sid: String,
    /// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
    pub friendly_name: String,
    /// A permission that you grant to the new role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. The values for this parameter depend on the role's `type`.
    pub permission: Vec<String>,
    /// The type of role. Can be: `conversation` for [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) roles or `service` for [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) roles.
    pub _type: String
}

/// struct for passing parameters to the method [`create_service_user`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceUserParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the User resource is associated with.
    pub chat_service_sid: String,
    /// The application-defined string that uniquely identifies the resource's User within the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource). This value is often a username or an email address, and is case-sensitive.
    pub identity: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// The JSON Object string that stores application-specific data. If attributes have not been set, `{}` is returned.
    pub attributes: Option<String>,
    /// The string that you assigned to describe the resource.
    pub friendly_name: Option<String>,
    /// The SID of a service-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the user.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`create_user`]
#[derive(Clone, Debug, Default)]
pub struct CreateUserParams {
    /// The application-defined string that uniquely identifies the resource's User within the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource). This value is often a username or an email address, and is case-sensitive.
    pub identity: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// The JSON Object string that stores application-specific data. If attributes have not been set, `{}` is returned.
    pub attributes: Option<String>,
    /// The string that you assigned to describe the resource.
    pub friendly_name: Option<String>,
    /// The SID of a service-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the user.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`delete_conversation`]
#[derive(Clone, Debug, Default)]
pub struct DeleteConversationParams {
    /// A 34 character string that uniquely identifies this resource. Can also be the `unique_name` of the Conversation.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method [`delete_conversation_message`]
#[derive(Clone, Debug, Default)]
pub struct DeleteConversationMessageParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method [`delete_conversation_participant`]
#[derive(Clone, Debug, Default)]
pub struct DeleteConversationParticipantParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this participant.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method [`delete_conversation_scoped_webhook`]
#[derive(Clone, Debug, Default)]
pub struct DeleteConversationScopedWebhookParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this webhook.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_credential`]
#[derive(Clone, Debug, Default)]
pub struct DeleteCredentialParams {
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_role`]
#[derive(Clone, Debug, Default)]
pub struct DeleteRoleParams {
    /// The SID of the Role resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_service`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_service_binding`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceBindingParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to delete the Binding resource from.
    pub chat_service_sid: String,
    /// The SID of the Binding resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_service_conversation`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceConversationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Conversation resource is associated with.
    pub chat_service_sid: String,
    /// A 34 character string that uniquely identifies this resource. Can also be the `unique_name` of the Conversation.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method [`delete_service_conversation_message`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceConversationMessageParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method [`delete_service_conversation_participant`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceConversationParticipantParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this participant.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method [`delete_service_conversation_scoped_webhook`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceConversationScopedWebhookParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this webhook.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_service_role`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceRoleParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to delete the Role resource from.
    pub chat_service_sid: String,
    /// The SID of the Role resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_service_user`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceUserParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to delete the User resource from.
    pub chat_service_sid: String,
    /// The SID of the User resource to delete. This value can be either the `sid` or the `identity` of the User resource to delete.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method [`delete_service_user_conversation`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceUserConversationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Conversation resource is associated with.
    pub chat_service_sid: String,
    /// The unique SID identifier of the [User resource](https://www.twilio.com/docs/conversations/api/user-resource). This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// The unique SID identifier of the Conversation. This value can be either the `sid` or the `unique_name` of the [Conversation resource](https://www.twilio.com/docs/conversations/api/conversation-resource).
    pub conversation_sid: String
}

/// struct for passing parameters to the method [`delete_user`]
#[derive(Clone, Debug, Default)]
pub struct DeleteUserParams {
    /// The SID of the User resource to delete. This value can be either the `sid` or the `identity` of the User resource to delete.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>
}

/// struct for passing parameters to the method [`delete_user_conversation`]
#[derive(Clone, Debug, Default)]
pub struct DeleteUserConversationParams {
    /// The unique SID identifier of the [User resource](https://www.twilio.com/docs/conversations/api/user-resource). This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// The unique SID identifier of the Conversation. This value can be either the `sid` or the `unique_name` of the [Conversation resource](https://www.twilio.com/docs/conversations/api/conversation-resource).
    pub conversation_sid: String
}

/// struct for passing parameters to the method [`fetch_conversation`]
#[derive(Clone, Debug, Default)]
pub struct FetchConversationParams {
    /// A 34 character string that uniquely identifies this resource. Can also be the `unique_name` of the Conversation.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_conversation_message`]
#[derive(Clone, Debug, Default)]
pub struct FetchConversationMessageParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_conversation_message_receipt`]
#[derive(Clone, Debug, Default)]
pub struct FetchConversationMessageReceiptParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// The SID of the message within a [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) the delivery receipt belongs to.
    pub message_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_conversation_participant`]
#[derive(Clone, Debug, Default)]
pub struct FetchConversationParticipantParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this participant.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_conversation_scoped_webhook`]
#[derive(Clone, Debug, Default)]
pub struct FetchConversationScopedWebhookParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this webhook.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_credential`]
#[derive(Clone, Debug, Default)]
pub struct FetchCredentialParams {
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_role`]
#[derive(Clone, Debug, Default)]
pub struct FetchRoleParams {
    /// The SID of the Role resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceParams {
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service_binding`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceBindingParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Binding resource is associated with.
    pub chat_service_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service_configuration`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceConfigurationParams {
    /// The SID of the Service configuration resource to fetch.
    pub chat_service_sid: String
}

/// struct for passing parameters to the method [`fetch_service_conversation`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceConversationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Conversation resource is associated with.
    pub chat_service_sid: String,
    /// A 34 character string that uniquely identifies this resource. Can also be the `unique_name` of the Conversation.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service_conversation_message`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceConversationMessageParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service_conversation_message_receipt`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceConversationMessageReceiptParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Message resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// The SID of the message within a [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) the delivery receipt belongs to.
    pub message_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service_conversation_participant`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceConversationParticipantParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this participant.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service_conversation_scoped_webhook`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceConversationScopedWebhookParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this webhook.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service_notification`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceNotificationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Configuration applies to.
    pub chat_service_sid: String
}

/// struct for passing parameters to the method [`fetch_service_role`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceRoleParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to fetch the Role resource from.
    pub chat_service_sid: String,
    /// The SID of the Role resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service_user`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceUserParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to fetch the User resource from.
    pub chat_service_sid: String,
    /// The SID of the User resource to fetch. This value can be either the `sid` or the `identity` of the User resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service_user_conversation`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceUserConversationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Conversation resource is associated with.
    pub chat_service_sid: String,
    /// The unique SID identifier of the [User resource](https://www.twilio.com/docs/conversations/api/user-resource). This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// The unique SID identifier of the Conversation. This value can be either the `sid` or the `unique_name` of the [Conversation resource](https://www.twilio.com/docs/conversations/api/conversation-resource).
    pub conversation_sid: String
}

/// struct for passing parameters to the method [`fetch_user`]
#[derive(Clone, Debug, Default)]
pub struct FetchUserParams {
    /// The SID of the User resource to fetch. This value can be either the `sid` or the `identity` of the User resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_user_conversation`]
#[derive(Clone, Debug, Default)]
pub struct FetchUserConversationParams {
    /// The unique SID identifier of the [User resource](https://www.twilio.com/docs/conversations/api/user-resource). This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// The unique SID identifier of the Conversation. This value can be either the `sid` or the `unique_name` of the [Conversation resource](https://www.twilio.com/docs/conversations/api/conversation-resource).
    pub conversation_sid: String
}

/// struct for passing parameters to the method [`list_conversation`]
#[derive(Clone, Debug, Default)]
pub struct ListConversationParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_conversation_message`]
#[derive(Clone, Debug, Default)]
pub struct ListConversationMessageParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for messages.
    pub conversation_sid: String,
    /// The sort order of the returned messages. Can be: `asc` (ascending) or `desc` (descending), with `asc` as the default.
    pub order: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_conversation_message_receipt`]
#[derive(Clone, Debug, Default)]
pub struct ListConversationMessageReceiptParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// The SID of the message within a [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) the delivery receipt belongs to.
    pub message_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_conversation_participant`]
#[derive(Clone, Debug, Default)]
pub struct ListConversationParticipantParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for participants.
    pub conversation_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_conversation_scoped_webhook`]
#[derive(Clone, Debug, Default)]
pub struct ListConversationScopedWebhookParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this webhook.
    pub conversation_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_credential`]
#[derive(Clone, Debug, Default)]
pub struct ListCredentialParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_participant_conversation`]
#[derive(Clone, Debug, Default)]
pub struct ListParticipantConversationParams {
    /// A unique string identifier for the conversation participant as [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource). This parameter is non-null if (and only if) the participant is using the Conversations SDK to communicate. Limited to 256 characters.
    pub identity: Option<String>,
    /// A unique string identifier for the conversation participant who's not a Conversation User. This parameter could be found in messaging_binding.address field of Participant resource. It should be url-encoded.
    pub address: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_role`]
#[derive(Clone, Debug, Default)]
pub struct ListRoleParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service_binding`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceBindingParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Binding resource is associated with.
    pub chat_service_sid: String,
    /// The push technology used by the Binding resources to read.  Can be: `apn`, `gcm`, or `fcm`.  See [push notification configuration](https://www.twilio.com/docs/chat/push-notification-configuration) for more info.
    pub binding_type: Option<Vec<String>>,
    /// The identity of a [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource) this binding belongs to. See [access tokens](https://www.twilio.com/docs/conversations/create-tokens) for more details.
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service_conversation`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceConversationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Conversation resource is associated with.
    pub chat_service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service_conversation_message`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceConversationMessageParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for messages.
    pub conversation_sid: String,
    /// The sort order of the returned messages. Can be: `asc` (ascending) or `desc` (descending), with `asc` as the default.
    pub order: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service_conversation_message_receipt`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceConversationMessageReceiptParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Message resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// The SID of the message within a [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) the delivery receipt belongs to.
    pub message_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service_conversation_participant`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceConversationParticipantParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for participants.
    pub conversation_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service_conversation_scoped_webhook`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceConversationScopedWebhookParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this webhook.
    pub conversation_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service_participant_conversation`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceParticipantConversationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant Conversations resource is associated with.
    pub chat_service_sid: String,
    /// A unique string identifier for the conversation participant as [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource). This parameter is non-null if (and only if) the participant is using the Conversations SDK to communicate. Limited to 256 characters.
    pub identity: Option<String>,
    /// A unique string identifier for the conversation participant who's not a Conversation User. This parameter could be found in messaging_binding.address field of Participant resource. It should be url-encoded.
    pub address: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service_role`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceRoleParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to read the Role resources from.
    pub chat_service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service_user`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceUserParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to read the User resources from.
    pub chat_service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service_user_conversation`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceUserConversationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Conversation resource is associated with.
    pub chat_service_sid: String,
    /// The unique SID identifier of the [User resource](https://www.twilio.com/docs/conversations/api/user-resource). This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_user`]
#[derive(Clone, Debug, Default)]
pub struct ListUserParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_user_conversation`]
#[derive(Clone, Debug, Default)]
pub struct ListUserConversationParams {
    /// The unique SID identifier of the [User resource](https://www.twilio.com/docs/conversations/api/user-resource). This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`update_configuration`]
#[derive(Clone, Debug, Default)]
pub struct UpdateConfigurationParams {
    /// The SID of the default [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to use when creating a conversation.
    pub default_chat_service_sid: Option<String>,
    /// Default ISO8601 duration when conversation will be switched to `closed` state. Minimum value for this timer is 10 minutes.
    pub default_closed_timer: Option<String>,
    /// Default ISO8601 duration when conversation will be switched to `inactive` state. Minimum value for this timer is 1 minute.
    pub default_inactive_timer: Option<String>,
    /// The SID of the default [Messaging Service](https://www.twilio.com/docs/sms/services/api) to use when creating a conversation.
    pub default_messaging_service_sid: Option<String>
}

/// struct for passing parameters to the method [`update_configuration_webhook`]
#[derive(Clone, Debug, Default)]
pub struct UpdateConfigurationWebhookParams {
    /// The list of webhook event triggers that are enabled for this Service: `onMessageAdded`, `onMessageUpdated`, `onMessageRemoved`, `onConversationUpdated`, `onConversationRemoved`, `onParticipantAdded`, `onParticipantUpdated`, `onParticipantRemoved`
    pub filters: Option<Vec<String>>,
    /// The HTTP method to be used when sending a webhook request.
    pub method: Option<String>,
    /// The absolute url the post-event webhook request should be sent to.
    pub post_webhook_url: Option<String>,
    /// The absolute url the pre-event webhook request should be sent to.
    pub pre_webhook_url: Option<String>,
    /// The routing target of the webhook.
    pub target: Option<String>
}

/// struct for passing parameters to the method [`update_conversation`]
#[derive(Clone, Debug, Default)]
pub struct UpdateConversationParams {
    /// A 34 character string that uniquely identifies this resource. Can also be the `unique_name` of the Conversation.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated.
    pub date_updated: Option<String>,
    /// The human-readable name of this conversation, limited to 256 characters. Optional.
    pub friendly_name: Option<String>,
    /// The unique ID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) this conversation belongs to.
    pub messaging_service_sid: Option<String>,
    /// Current state of this conversation. Can be either `active`, `inactive` or `closed` and defaults to `active`
    pub state: Option<String>,
    /// ISO8601 duration when conversation will be switched to `closed` state. Minimum value for this timer is 10 minutes.
    pub timers_closed: Option<String>,
    /// ISO8601 duration when conversation will be switched to `inactive` state. Minimum value for this timer is 1 minute.
    pub timers_inactive: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method [`update_conversation_message`]
#[derive(Clone, Debug, Default)]
pub struct UpdateConversationMessageParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The channel specific identifier of the message's author. Defaults to `system`.
    pub author: Option<String>,
    /// The content of the message, can be up to 1,600 characters long.
    pub body: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated. `null` if the message has not been edited.
    pub date_updated: Option<String>
}

/// struct for passing parameters to the method [`update_conversation_participant`]
#[derive(Clone, Debug, Default)]
pub struct UpdateConversationParticipantParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this participant.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated.
    pub date_updated: Option<String>,
    /// A unique string identifier for the conversation participant as [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource). This parameter is non-null if (and only if) the participant is using the Conversations SDK to communicate. Limited to 256 characters.
    pub identity: Option<String>,
    /// Index of last “read” message in the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for the Participant.
    pub last_read_message_index: Option<i32>,
    /// Timestamp of last “read” message in the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for the Participant.
    pub last_read_timestamp: Option<String>,
    /// The address of the Twilio phone number that is used in Group MMS. 'null' value will remove it.
    pub messaging_binding_projected_address: Option<String>,
    /// The address of the Twilio phone number that the participant is in contact with. 'null' value will remove it.
    pub messaging_binding_proxy_address: Option<String>,
    /// The SID of a conversation-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the participant.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`update_conversation_scoped_webhook`]
#[derive(Clone, Debug, Default)]
pub struct UpdateConversationScopedWebhookParams {
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this webhook.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// The list of events, firing webhook event for this Conversation.
    pub configuration_filters: Option<Vec<String>>,
    /// The studio flow SID, where the webhook should be sent to.
    pub configuration_flow_sid: Option<String>,
    /// The HTTP method to be used when sending a webhook request.
    pub configuration_method: Option<String>,
    /// The list of keywords, firing webhook event for this Conversation.
    pub configuration_triggers: Option<Vec<String>>,
    /// The absolute url the webhook request should be sent to.
    pub configuration_url: Option<String>
}

/// struct for passing parameters to the method [`update_credential`]
#[derive(Clone, Debug, Default)]
pub struct UpdateCredentialParams {
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// [GCM only] The API key for the project that was obtained from the Google Developer console for your GCM Service application credential.
    pub api_key: Option<String>,
    /// [APN only] The URL encoded representation of the certificate. For example,  `-----BEGIN CERTIFICATE----- MIIFnTCCBIWgAwIBAgIIAjy9H849+E8wDQYJKoZIhvcNAQEF.....A== -----END CERTIFICATE-----`.
    pub certificate: Option<String>,
    /// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// [APN only] The URL encoded representation of the private key. For example, `-----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEAuyf/lNrH9ck8DmNyo3fG... -----END RSA PRIVATE KEY-----`.
    pub private_key: Option<String>,
    /// [APN only] Whether to send the credential to sandbox APNs. Can be `true` to send to sandbox APNs or `false` to send to production.
    pub sandbox: Option<bool>,
    /// [FCM only] The **Server key** of your project from the Firebase console, found under Settings / Cloud messaging.
    pub secret: Option<String>,
    /// The type of push-notification service the credential is for. Can be: `fcm`, `gcm`, or `apn`.
    pub _type: Option<String>
}

/// struct for passing parameters to the method [`update_role`]
#[derive(Clone, Debug, Default)]
pub struct UpdateRoleParams {
    /// The SID of the Role resource to update.
    pub sid: String,
    /// A permission that you grant to the role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. Note that the update action replaces all previously assigned permissions with those defined in the update action. To remove a permission, do not include it in the subsequent update action. The values for this parameter depend on the role's `type`.
    pub permission: Vec<String>
}

/// struct for passing parameters to the method [`update_service_configuration`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceConfigurationParams {
    /// The SID of the Service configuration resource to update.
    pub chat_service_sid: String,
    /// The service-level role assigned to users when they are added to the service. See the [Conversation Role](https://www.twilio.com/docs/conversations/api/role-resource) for more info about roles.
    pub default_chat_service_role_sid: Option<String>,
    /// The conversation-level role assigned to a conversation creator when they join a new conversation. See the [Conversation Role](https://www.twilio.com/docs/conversations/api/role-resource) for more info about roles.
    pub default_conversation_creator_role_sid: Option<String>,
    /// The conversation-level role assigned to users when they are added to a conversation. See the [Conversation Role](https://www.twilio.com/docs/conversations/api/role-resource) for more info about roles.
    pub default_conversation_role_sid: Option<String>,
    /// Whether the [Reachability Indicator](https://www.twilio.com/docs/chat/reachability-indicator) is enabled for this Conversations Service. The default is `false`.
    pub reachability_enabled: Option<bool>
}

/// struct for passing parameters to the method [`update_service_conversation`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceConversationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Conversation resource is associated with.
    pub chat_service_sid: String,
    /// A 34 character string that uniquely identifies this resource. Can also be the `unique_name` of the Conversation.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated.
    pub date_updated: Option<String>,
    /// The human-readable name of this conversation, limited to 256 characters. Optional.
    pub friendly_name: Option<String>,
    /// The unique ID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) this conversation belongs to.
    pub messaging_service_sid: Option<String>,
    /// Current state of this conversation. Can be either `active`, `inactive` or `closed` and defaults to `active`
    pub state: Option<String>,
    /// ISO8601 duration when conversation will be switched to `closed` state. Minimum value for this timer is 10 minutes.
    pub timers_closed: Option<String>,
    /// ISO8601 duration when conversation will be switched to `inactive` state. Minimum value for this timer is 1 minute.
    pub timers_inactive: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method [`update_service_conversation_message`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceConversationMessageParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this message.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// A string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The channel specific identifier of the message's author. Defaults to `system`.
    pub author: Option<String>,
    /// The content of the message, can be up to 1,600 characters long.
    pub body: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated. `null` if the message has not been edited.
    pub date_updated: Option<String>
}

/// struct for passing parameters to the method [`update_service_conversation_participant`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceConversationParticipantParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this participant.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
    pub attributes: Option<String>,
    /// The date that this resource was created.
    pub date_created: Option<String>,
    /// The date that this resource was last updated.
    pub date_updated: Option<String>,
    /// A unique string identifier for the conversation participant as [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource). This parameter is non-null if (and only if) the participant is using the Conversation SDK to communicate. Limited to 256 characters.
    pub identity: Option<String>,
    /// Index of last “read” message in the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for the Participant.
    pub last_read_message_index: Option<i32>,
    /// Timestamp of last “read” message in the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for the Participant.
    pub last_read_timestamp: Option<String>,
    /// The address of the Twilio phone number that is used in Group MMS. 'null' value will remove it.
    pub messaging_binding_projected_address: Option<String>,
    /// The address of the Twilio phone number that the participant is in contact with. 'null' value will remove it.
    pub messaging_binding_proxy_address: Option<String>,
    /// The SID of a conversation-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the participant.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`update_service_conversation_scoped_webhook`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceConversationScopedWebhookParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Participant resource is associated with.
    pub chat_service_sid: String,
    /// The unique ID of the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for this webhook.
    pub conversation_sid: String,
    /// A 34 character string that uniquely identifies this resource.
    pub sid: String,
    /// The list of events, firing webhook event for this Conversation.
    pub configuration_filters: Option<Vec<String>>,
    /// The studio flow SID, where the webhook should be sent to.
    pub configuration_flow_sid: Option<String>,
    /// The HTTP method to be used when sending a webhook request.
    pub configuration_method: Option<String>,
    /// The list of keywords, firing webhook event for this Conversation.
    pub configuration_triggers: Option<Vec<String>>,
    /// The absolute url the webhook request should be sent to.
    pub configuration_url: Option<String>
}

/// struct for passing parameters to the method [`update_service_notification`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceNotificationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Configuration applies to.
    pub chat_service_sid: String,
    /// Whether to send a notification when a participant is added to a conversation. The default is `false`.
    pub added_to_conversation_enabled: Option<bool>,
    /// The name of the sound to play when a participant is added to a conversation and `added_to_conversation.enabled` is `true`.
    pub added_to_conversation_sound: Option<String>,
    /// The template to use to create the notification text displayed when a participant is added to a conversation and `added_to_conversation.enabled` is `true`.
    pub added_to_conversation_template: Option<String>,
    /// Weather the notification logging is enabled.
    pub log_enabled: Option<bool>,
    /// Whether the new message badge is enabled. The default is `false`.
    pub new_message_badge_count_enabled: Option<bool>,
    /// Whether to send a notification when a new message is added to a conversation. The default is `false`.
    pub new_message_enabled: Option<bool>,
    /// The name of the sound to play when a new message is added to a conversation and `new_message.enabled` is `true`.
    pub new_message_sound: Option<String>,
    /// The template to use to create the notification text displayed when a new message is added to a conversation and `new_message.enabled` is `true`.
    pub new_message_template: Option<String>,
    /// Whether to send a notification to a user when they are removed from a conversation. The default is `false`.
    pub removed_from_conversation_enabled: Option<bool>,
    /// The name of the sound to play to a user when they are removed from a conversation and `removed_from_conversation.enabled` is `true`.
    pub removed_from_conversation_sound: Option<String>,
    /// The template to use to create the notification text displayed to a user when they are removed from a conversation and `removed_from_conversation.enabled` is `true`.
    pub removed_from_conversation_template: Option<String>
}

/// struct for passing parameters to the method [`update_service_role`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceRoleParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to update the Role resource in.
    pub chat_service_sid: String,
    /// The SID of the Role resource to update.
    pub sid: String,
    /// A permission that you grant to the role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. Note that the update action replaces all previously assigned permissions with those defined in the update action. To remove a permission, do not include it in the subsequent update action. The values for this parameter depend on the role's `type`.
    pub permission: Vec<String>
}

/// struct for passing parameters to the method [`update_service_user`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceUserParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the User resource is associated with.
    pub chat_service_sid: String,
    /// The SID of the User resource to update. This value can be either the `sid` or the `identity` of the User resource to update.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// The JSON Object string that stores application-specific data. If attributes have not been set, `{}` is returned.
    pub attributes: Option<String>,
    /// The string that you assigned to describe the resource.
    pub friendly_name: Option<String>,
    /// The SID of a service-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the user.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`update_service_user_conversation`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceUserConversationParams {
    /// The SID of the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) the Conversation resource is associated with.
    pub chat_service_sid: String,
    /// The unique SID identifier of the [User resource](https://www.twilio.com/docs/conversations/api/user-resource). This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// The unique SID identifier of the Conversation. This value can be either the `sid` or the `unique_name` of the [Conversation resource](https://www.twilio.com/docs/conversations/api/conversation-resource).
    pub conversation_sid: String,
    /// The index of the last Message in the Conversation that the Participant has read.
    pub last_read_message_index: Option<i32>,
    /// The date of the last message read in conversation by the user, given in ISO 8601 format.
    pub last_read_timestamp: Option<String>,
    /// The Notification Level of this User Conversation. One of `default` or `muted`.
    pub notification_level: Option<String>
}

/// struct for passing parameters to the method [`update_user`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserParams {
    /// The SID of the User resource to update. This value can be either the `sid` or the `identity` of the User resource to update.
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    /// The JSON Object string that stores application-specific data. If attributes have not been set, `{}` is returned.
    pub attributes: Option<String>,
    /// The string that you assigned to describe the resource.
    pub friendly_name: Option<String>,
    /// The SID of a service-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the user.
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method [`update_user_conversation`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserConversationParams {
    /// The unique SID identifier of the [User resource](https://www.twilio.com/docs/conversations/api/user-resource). This value can be either the `sid` or the `identity` of the User resource.
    pub user_sid: String,
    /// The unique SID identifier of the Conversation. This value can be either the `sid` or the `unique_name` of the [Conversation resource](https://www.twilio.com/docs/conversations/api/conversation-resource).
    pub conversation_sid: String,
    /// The index of the last Message in the Conversation that the Participant has read.
    pub last_read_message_index: Option<i32>,
    /// The date of the last message read in conversation by the user, given in ISO 8601 format.
    pub last_read_timestamp: Option<String>,
    /// The Notification Level of this User Conversation. One of `default` or `muted`.
    pub notification_level: Option<String>
}


/// struct for typed successes of method [`create_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConversationSuccess {
    Status201(crate::models::ConversationsV1Conversation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConversationMessageSuccess {
    Status201(crate::models::ConversationsV1ConversationConversationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConversationParticipantSuccess {
    Status201(crate::models::ConversationsV1ConversationConversationParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConversationScopedWebhookSuccess {
    Status201(crate::models::ConversationsV1ConversationConversationScopedWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialSuccess {
    Status201(crate::models::ConversationsV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleSuccess {
    Status201(crate::models::ConversationsV1Role),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceSuccess {
    Status201(crate::models::ConversationsV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceConversationSuccess {
    Status201(crate::models::ConversationsV1ServiceServiceConversation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceConversationMessageSuccess {
    Status201(crate::models::ConversationsV1ServiceServiceConversationServiceConversationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceConversationParticipantSuccess {
    Status201(crate::models::ConversationsV1ServiceServiceConversationServiceConversationParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceConversationScopedWebhookSuccess {
    Status201(crate::models::ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceRoleSuccess {
    Status201(crate::models::ConversationsV1ServiceServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceUserSuccess {
    Status201(crate::models::ConversationsV1ServiceServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserSuccess {
    Status201(crate::models::ConversationsV1User),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConversationSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConversationMessageSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConversationParticipantSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConversationScopedWebhookSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceBindingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceConversationSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceConversationMessageSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceConversationParticipantSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceConversationScopedWebhookSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceRoleSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceUserSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceUserConversationSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserConversationSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConfigurationSuccess {
    Status200(crate::models::ConversationsV1Configuration),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_configuration_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConfigurationWebhookSuccess {
    Status200(crate::models::ConversationsV1ConfigurationConfigurationWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConversationSuccess {
    Status200(crate::models::ConversationsV1Conversation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConversationMessageSuccess {
    Status200(crate::models::ConversationsV1ConversationConversationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_conversation_message_receipt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConversationMessageReceiptSuccess {
    Status200(crate::models::ConversationsV1ConversationConversationMessageConversationMessageReceipt),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConversationParticipantSuccess {
    Status200(crate::models::ConversationsV1ConversationConversationParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConversationScopedWebhookSuccess {
    Status200(crate::models::ConversationsV1ConversationConversationScopedWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialSuccess {
    Status200(crate::models::ConversationsV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoleSuccess {
    Status200(crate::models::ConversationsV1Role),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceSuccess {
    Status200(crate::models::ConversationsV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceBindingSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceBinding),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConfigurationSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConfiguration),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConversationSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConversation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConversationMessageSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConversationServiceConversationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_conversation_message_receipt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConversationMessageReceiptSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConversationParticipantSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConversationServiceConversationParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConversationScopedWebhookSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceNotificationSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConfigurationServiceNotification),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceRoleSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceUserSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceUserConversationSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceUserServiceUserConversation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserSuccess {
    Status200(crate::models::ConversationsV1User),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserConversationSuccess {
    Status200(crate::models::ConversationsV1UserUserConversation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConversationSuccess {
    Status200(crate::models::ListConversationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConversationMessageSuccess {
    Status200(crate::models::ListConversationMessageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_conversation_message_receipt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConversationMessageReceiptSuccess {
    Status200(crate::models::ListConversationMessageReceiptResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConversationParticipantSuccess {
    Status200(crate::models::ListConversationParticipantResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConversationScopedWebhookSuccess {
    Status200(crate::models::ListConversationScopedWebhookResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialSuccess {
    Status200(crate::models::ListCredentialResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_participant_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListParticipantConversationSuccess {
    Status200(crate::models::ListParticipantConversationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoleSuccess {
    Status200(crate::models::ListRoleResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceSuccess {
    Status200(crate::models::ListServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceBindingSuccess {
    Status200(crate::models::ListServiceBindingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceConversationSuccess {
    Status200(crate::models::ListServiceConversationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceConversationMessageSuccess {
    Status200(crate::models::ListServiceConversationMessageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service_conversation_message_receipt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceConversationMessageReceiptSuccess {
    Status200(crate::models::ListServiceConversationMessageReceiptResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceConversationParticipantSuccess {
    Status200(crate::models::ListServiceConversationParticipantResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceConversationScopedWebhookSuccess {
    Status200(crate::models::ListServiceConversationScopedWebhookResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service_participant_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceParticipantConversationSuccess {
    Status200(crate::models::ListServiceParticipantConversationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceRoleSuccess {
    Status200(crate::models::ListServiceRoleResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceUserSuccess {
    Status200(crate::models::ListServiceUserResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceUserConversationSuccess {
    Status200(crate::models::ListServiceUserConversationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserSuccess {
    Status200(crate::models::ListUserResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserConversationSuccess {
    Status200(crate::models::ListUserConversationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConfigurationSuccess {
    Status200(crate::models::ConversationsV1Configuration),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_configuration_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConfigurationWebhookSuccess {
    Status200(crate::models::ConversationsV1ConfigurationConfigurationWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConversationSuccess {
    Status200(crate::models::ConversationsV1Conversation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConversationMessageSuccess {
    Status200(crate::models::ConversationsV1ConversationConversationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConversationParticipantSuccess {
    Status200(crate::models::ConversationsV1ConversationConversationParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConversationScopedWebhookSuccess {
    Status200(crate::models::ConversationsV1ConversationConversationScopedWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialSuccess {
    Status200(crate::models::ConversationsV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleSuccess {
    Status200(crate::models::ConversationsV1Role),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceConfigurationSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConfiguration),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceConversationSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConversation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceConversationMessageSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConversationServiceConversationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceConversationParticipantSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConversationServiceConversationParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceConversationScopedWebhookSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceNotificationSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceConfigurationServiceNotification),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceRoleSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceUserSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceUserConversationSuccess {
    Status200(crate::models::ConversationsV1ServiceServiceUserServiceUserConversation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserSuccess {
    Status200(crate::models::ConversationsV1User),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserConversationSuccess {
    Status200(crate::models::ConversationsV1UserUserConversation),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConversationMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConversationParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConversationScopedWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceConversationMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceConversationParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceConversationScopedWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConversationMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConversationParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConversationScopedWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceConversationMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceConversationParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceConversationScopedWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceUserConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_configuration_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConfigurationWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConversationMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_conversation_message_receipt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConversationMessageReceiptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConversationParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConversationScopedWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConversationMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_conversation_message_receipt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConversationMessageReceiptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConversationParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceConversationScopedWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceUserConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConversationMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_conversation_message_receipt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConversationMessageReceiptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConversationParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConversationScopedWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_participant_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListParticipantConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceConversationMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service_conversation_message_receipt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceConversationMessageReceiptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceConversationParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceConversationScopedWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service_participant_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceParticipantConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceUserConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_configuration_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConfigurationWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConversationMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConversationParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConversationScopedWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service_conversation_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceConversationMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service_conversation_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceConversationParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service_conversation_scoped_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceConversationScopedWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceUserConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserConversationError {
    UnknownValue(serde_json::Value),
}


/// Create a new conversation in your account's default service
pub async fn create_conversation(configuration: &configuration::Configuration, params: CreateConversationParams) -> Result<ResponseContent<CreateConversationSuccess>, Error<CreateConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let friendly_name = params.friendly_name;
    let messaging_service_sid = params.messaging_service_sid;
    let state = params.state;
    let timers_closed = params.timers_closed;
    let timers_inactive = params.timers_inactive;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_service_sid {
        local_var_form_params.insert("MessagingServiceSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = state {
        local_var_form_params.insert("State", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timers_closed {
        local_var_form_params.insert("Timers.Closed", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timers_inactive {
        local_var_form_params.insert("Timers.Inactive", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a new message to the conversation
pub async fn create_conversation_message(configuration: &configuration::Configuration, params: CreateConversationMessageParams) -> Result<ResponseContent<CreateConversationMessageSuccess>, Error<CreateConversationMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let author = params.author;
    let body = params.body;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let media_sid = params.media_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Messages", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = author {
        local_var_form_params.insert("Author", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = media_sid {
        local_var_form_params.insert("MediaSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateConversationMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateConversationMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a new participant to the conversation
pub async fn create_conversation_participant(configuration: &configuration::Configuration, params: CreateConversationParticipantParams) -> Result<ResponseContent<CreateConversationParticipantSuccess>, Error<CreateConversationParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let identity = params.identity;
    let messaging_binding_address = params.messaging_binding_address;
    let messaging_binding_projected_address = params.messaging_binding_projected_address;
    let messaging_binding_proxy_address = params.messaging_binding_proxy_address;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Participants", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = identity {
        local_var_form_params.insert("Identity", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_binding_address {
        local_var_form_params.insert("MessagingBinding.Address", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_binding_projected_address {
        local_var_form_params.insert("MessagingBinding.ProjectedAddress", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_binding_proxy_address {
        local_var_form_params.insert("MessagingBinding.ProxyAddress", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateConversationParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateConversationParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new webhook scoped to the conversation
pub async fn create_conversation_scoped_webhook(configuration: &configuration::Configuration, params: CreateConversationScopedWebhookParams) -> Result<ResponseContent<CreateConversationScopedWebhookSuccess>, Error<CreateConversationScopedWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let target = params.target;
    let configuration_filters = params.configuration_filters;
    let configuration_flow_sid = params.configuration_flow_sid;
    let configuration_method = params.configuration_method;
    let configuration_replay_after = params.configuration_replay_after;
    let configuration_triggers = params.configuration_triggers;
    let configuration_url = params.configuration_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Webhooks", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = configuration_filters {
        local_var_form_params.insert("Configuration.Filters", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_flow_sid {
        local_var_form_params.insert("Configuration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_method {
        local_var_form_params.insert("Configuration.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_replay_after {
        local_var_form_params.insert("Configuration.ReplayAfter", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_triggers {
        local_var_form_params.insert("Configuration.Triggers", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_url {
        local_var_form_params.insert("Configuration.Url", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Target", target.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateConversationScopedWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateConversationScopedWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a new push notification credential to your account
pub async fn create_credential(configuration: &configuration::Configuration, params: CreateCredentialParams) -> Result<ResponseContent<CreateCredentialSuccess>, Error<CreateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let _type = params._type;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new user role in your account's default service
pub async fn create_role(configuration: &configuration::Configuration, params: CreateRoleParams) -> Result<ResponseContent<CreateRoleSuccess>, Error<CreateRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let permission = params.permission;
    let _type = params._type;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Roles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("Permission", permission.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new conversation service on your account
pub async fn create_service(configuration: &configuration::Configuration, params: CreateServiceParams) -> Result<ResponseContent<CreateServiceSuccess>, Error<CreateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new conversation in your service
pub async fn create_service_conversation(configuration: &configuration::Configuration, params: CreateServiceConversationParams) -> Result<ResponseContent<CreateServiceConversationSuccess>, Error<CreateServiceConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let friendly_name = params.friendly_name;
    let messaging_service_sid = params.messaging_service_sid;
    let state = params.state;
    let timers_closed = params.timers_closed;
    let timers_inactive = params.timers_inactive;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_service_sid {
        local_var_form_params.insert("MessagingServiceSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = state {
        local_var_form_params.insert("State", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timers_closed {
        local_var_form_params.insert("Timers.Closed", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timers_inactive {
        local_var_form_params.insert("Timers.Inactive", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a new message to the conversation in a specific service
pub async fn create_service_conversation_message(configuration: &configuration::Configuration, params: CreateServiceConversationMessageParams) -> Result<ResponseContent<CreateServiceConversationMessageSuccess>, Error<CreateServiceConversationMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let author = params.author;
    let body = params.body;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let media_sid = params.media_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = author {
        local_var_form_params.insert("Author", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = media_sid {
        local_var_form_params.insert("MediaSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceConversationMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceConversationMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a new participant to the conversation in a specific service
pub async fn create_service_conversation_participant(configuration: &configuration::Configuration, params: CreateServiceConversationParticipantParams) -> Result<ResponseContent<CreateServiceConversationParticipantSuccess>, Error<CreateServiceConversationParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let identity = params.identity;
    let messaging_binding_address = params.messaging_binding_address;
    let messaging_binding_projected_address = params.messaging_binding_projected_address;
    let messaging_binding_proxy_address = params.messaging_binding_proxy_address;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = identity {
        local_var_form_params.insert("Identity", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_binding_address {
        local_var_form_params.insert("MessagingBinding.Address", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_binding_projected_address {
        local_var_form_params.insert("MessagingBinding.ProjectedAddress", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_binding_proxy_address {
        local_var_form_params.insert("MessagingBinding.ProxyAddress", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceConversationParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceConversationParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new webhook scoped to the conversation in a specific service
pub async fn create_service_conversation_scoped_webhook(configuration: &configuration::Configuration, params: CreateServiceConversationScopedWebhookParams) -> Result<ResponseContent<CreateServiceConversationScopedWebhookSuccess>, Error<CreateServiceConversationScopedWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let target = params.target;
    let configuration_filters = params.configuration_filters;
    let configuration_flow_sid = params.configuration_flow_sid;
    let configuration_method = params.configuration_method;
    let configuration_replay_after = params.configuration_replay_after;
    let configuration_triggers = params.configuration_triggers;
    let configuration_url = params.configuration_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = configuration_filters {
        local_var_form_params.insert("Configuration.Filters", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_flow_sid {
        local_var_form_params.insert("Configuration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_method {
        local_var_form_params.insert("Configuration.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_replay_after {
        local_var_form_params.insert("Configuration.ReplayAfter", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_triggers {
        local_var_form_params.insert("Configuration.Triggers", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_url {
        local_var_form_params.insert("Configuration.Url", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Target", target.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceConversationScopedWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceConversationScopedWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new user role in your service
pub async fn create_service_role(configuration: &configuration::Configuration, params: CreateServiceRoleParams) -> Result<ResponseContent<CreateServiceRoleSuccess>, Error<CreateServiceRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let friendly_name = params.friendly_name;
    let permission = params.permission;
    let _type = params._type;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Roles", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("Permission", permission.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a new conversation user to your service
pub async fn create_service_user(configuration: &configuration::Configuration, params: CreateServiceUserParams) -> Result<ResponseContent<CreateServiceUserSuccess>, Error<CreateServiceUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let identity = params.identity;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Users", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a new conversation user to your account's default service
pub async fn create_user(configuration: &configuration::Configuration, params: CreateUserParams) -> Result<ResponseContent<CreateUserSuccess>, Error<CreateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let identity = params.identity;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Users", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a conversation from your account's default service
pub async fn delete_conversation(configuration: &configuration::Configuration, params: DeleteConversationParams) -> Result<ResponseContent<DeleteConversationSuccess>, Error<DeleteConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a message from the conversation
pub async fn delete_conversation_message(configuration: &configuration::Configuration, params: DeleteConversationMessageParams) -> Result<ResponseContent<DeleteConversationMessageSuccess>, Error<DeleteConversationMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Messages/{Sid}", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteConversationMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteConversationMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a participant from the conversation
pub async fn delete_conversation_participant(configuration: &configuration::Configuration, params: DeleteConversationParticipantParams) -> Result<ResponseContent<DeleteConversationParticipantSuccess>, Error<DeleteConversationParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Participants/{Sid}", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteConversationParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteConversationParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an existing webhook scoped to the conversation
pub async fn delete_conversation_scoped_webhook(configuration: &configuration::Configuration, params: DeleteConversationScopedWebhookParams) -> Result<ResponseContent<DeleteConversationScopedWebhookSuccess>, Error<DeleteConversationScopedWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Webhooks/{Sid}", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteConversationScopedWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteConversationScopedWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a push notification credential from your account
pub async fn delete_credential(configuration: &configuration::Configuration, params: DeleteCredentialParams) -> Result<ResponseContent<DeleteCredentialSuccess>, Error<DeleteCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a user role from your account's default service
pub async fn delete_role(configuration: &configuration::Configuration, params: DeleteRoleParams) -> Result<ResponseContent<DeleteRoleSuccess>, Error<DeleteRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Roles/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a conversation service with all its nested resources from your account
pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<ResponseContent<DeleteServiceSuccess>, Error<DeleteServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a push notification binding from the conversation service
pub async fn delete_service_binding(configuration: &configuration::Configuration, params: DeleteServiceBindingParams) -> Result<ResponseContent<DeleteServiceBindingSuccess>, Error<DeleteServiceBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Bindings/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a conversation from your service
pub async fn delete_service_conversation(configuration: &configuration::Configuration, params: DeleteServiceConversationParams) -> Result<ResponseContent<DeleteServiceConversationSuccess>, Error<DeleteServiceConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a message from the conversation
pub async fn delete_service_conversation_message(configuration: &configuration::Configuration, params: DeleteServiceConversationMessageParams) -> Result<ResponseContent<DeleteServiceConversationMessageSuccess>, Error<DeleteServiceConversationMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceConversationMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceConversationMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a participant from the conversation
pub async fn delete_service_conversation_participant(configuration: &configuration::Configuration, params: DeleteServiceConversationParticipantParams) -> Result<ResponseContent<DeleteServiceConversationParticipantSuccess>, Error<DeleteServiceConversationParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceConversationParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceConversationParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an existing webhook scoped to the conversation
pub async fn delete_service_conversation_scoped_webhook(configuration: &configuration::Configuration, params: DeleteServiceConversationScopedWebhookParams) -> Result<ResponseContent<DeleteServiceConversationScopedWebhookSuccess>, Error<DeleteServiceConversationScopedWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceConversationScopedWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceConversationScopedWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a user role from your service
pub async fn delete_service_role(configuration: &configuration::Configuration, params: DeleteServiceRoleParams) -> Result<ResponseContent<DeleteServiceRoleSuccess>, Error<DeleteServiceRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a conversation user from your service
pub async fn delete_service_user(configuration: &configuration::Configuration, params: DeleteServiceUserParams) -> Result<ResponseContent<DeleteServiceUserSuccess>, Error<DeleteServiceUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Users/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific User Conversation.
pub async fn delete_service_user_conversation(configuration: &configuration::Configuration, params: DeleteServiceUserConversationParams) -> Result<ResponseContent<DeleteServiceUserConversationSuccess>, Error<DeleteServiceUserConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let user_sid = params.user_sid;
    let conversation_sid = params.conversation_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), UserSid=crate::apis::urlencode(user_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceUserConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceUserConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a conversation user from your account's default service
pub async fn delete_user(configuration: &configuration::Configuration, params: DeleteUserParams) -> Result<ResponseContent<DeleteUserSuccess>, Error<DeleteUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Users/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific User Conversation.
pub async fn delete_user_conversation(configuration: &configuration::Configuration, params: DeleteUserConversationParams) -> Result<ResponseContent<DeleteUserConversationSuccess>, Error<DeleteUserConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_sid = params.user_sid;
    let conversation_sid = params.conversation_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Users/{UserSid}/Conversations/{ConversationSid}", local_var_configuration.base_path, UserSid=crate::apis::urlencode(user_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUserConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUserConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the global configuration of conversations on your account
pub async fn fetch_configuration(configuration: &configuration::Configuration) -> Result<ResponseContent<FetchConfigurationSuccess>, Error<FetchConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Configuration", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_configuration_webhook(configuration: &configuration::Configuration) -> Result<ResponseContent<FetchConfigurationWebhookSuccess>, Error<FetchConfigurationWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Configuration/Webhooks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConfigurationWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConfigurationWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a conversation from your account's default service
pub async fn fetch_conversation(configuration: &configuration::Configuration, params: FetchConversationParams) -> Result<ResponseContent<FetchConversationSuccess>, Error<FetchConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a message from the conversation
pub async fn fetch_conversation_message(configuration: &configuration::Configuration, params: FetchConversationMessageParams) -> Result<ResponseContent<FetchConversationMessageSuccess>, Error<FetchConversationMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Messages/{Sid}", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConversationMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConversationMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the delivery and read receipts of the conversation message
pub async fn fetch_conversation_message_receipt(configuration: &configuration::Configuration, params: FetchConversationMessageReceiptParams) -> Result<ResponseContent<FetchConversationMessageReceiptSuccess>, Error<FetchConversationMessageReceiptError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let message_sid = params.message_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), MessageSid=crate::apis::urlencode(message_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConversationMessageReceiptSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConversationMessageReceiptError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a participant of the conversation
pub async fn fetch_conversation_participant(configuration: &configuration::Configuration, params: FetchConversationParticipantParams) -> Result<ResponseContent<FetchConversationParticipantSuccess>, Error<FetchConversationParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Participants/{Sid}", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConversationParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConversationParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the configuration of a conversation-scoped webhook
pub async fn fetch_conversation_scoped_webhook(configuration: &configuration::Configuration, params: FetchConversationScopedWebhookParams) -> Result<ResponseContent<FetchConversationScopedWebhookSuccess>, Error<FetchConversationScopedWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Webhooks/{Sid}", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConversationScopedWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConversationScopedWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a push notification credential from your account
pub async fn fetch_credential(configuration: &configuration::Configuration, params: FetchCredentialParams) -> Result<ResponseContent<FetchCredentialSuccess>, Error<FetchCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a user role from your account's default service
pub async fn fetch_role(configuration: &configuration::Configuration, params: FetchRoleParams) -> Result<ResponseContent<FetchRoleSuccess>, Error<FetchRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Roles/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a conversation service from your account
pub async fn fetch_service(configuration: &configuration::Configuration, params: FetchServiceParams) -> Result<ResponseContent<FetchServiceSuccess>, Error<FetchServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a push notification binding from the conversation service
pub async fn fetch_service_binding(configuration: &configuration::Configuration, params: FetchServiceBindingParams) -> Result<ResponseContent<FetchServiceBindingSuccess>, Error<FetchServiceBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Bindings/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the configuration of a conversation service
pub async fn fetch_service_configuration(configuration: &configuration::Configuration, params: FetchServiceConfigurationParams) -> Result<ResponseContent<FetchServiceConfigurationSuccess>, Error<FetchServiceConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Configuration", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a conversation from your service
pub async fn fetch_service_conversation(configuration: &configuration::Configuration, params: FetchServiceConversationParams) -> Result<ResponseContent<FetchServiceConversationSuccess>, Error<FetchServiceConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a message from the conversation
pub async fn fetch_service_conversation_message(configuration: &configuration::Configuration, params: FetchServiceConversationMessageParams) -> Result<ResponseContent<FetchServiceConversationMessageSuccess>, Error<FetchServiceConversationMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceConversationMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceConversationMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the delivery and read receipts of the conversation message
pub async fn fetch_service_conversation_message_receipt(configuration: &configuration::Configuration, params: FetchServiceConversationMessageReceiptParams) -> Result<ResponseContent<FetchServiceConversationMessageReceiptSuccess>, Error<FetchServiceConversationMessageReceiptError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let message_sid = params.message_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), MessageSid=crate::apis::urlencode(message_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceConversationMessageReceiptSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceConversationMessageReceiptError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a participant of the conversation
pub async fn fetch_service_conversation_participant(configuration: &configuration::Configuration, params: FetchServiceConversationParticipantParams) -> Result<ResponseContent<FetchServiceConversationParticipantSuccess>, Error<FetchServiceConversationParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceConversationParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceConversationParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the configuration of a conversation-scoped webhook
pub async fn fetch_service_conversation_scoped_webhook(configuration: &configuration::Configuration, params: FetchServiceConversationScopedWebhookParams) -> Result<ResponseContent<FetchServiceConversationScopedWebhookSuccess>, Error<FetchServiceConversationScopedWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceConversationScopedWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceConversationScopedWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch push notification service settings
pub async fn fetch_service_notification(configuration: &configuration::Configuration, params: FetchServiceNotificationParams) -> Result<ResponseContent<FetchServiceNotificationSuccess>, Error<FetchServiceNotificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Configuration/Notifications", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceNotificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceNotificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a user role from your service
pub async fn fetch_service_role(configuration: &configuration::Configuration, params: FetchServiceRoleParams) -> Result<ResponseContent<FetchServiceRoleSuccess>, Error<FetchServiceRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a conversation user from your service
pub async fn fetch_service_user(configuration: &configuration::Configuration, params: FetchServiceUserParams) -> Result<ResponseContent<FetchServiceUserSuccess>, Error<FetchServiceUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Users/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific User Conversation.
pub async fn fetch_service_user_conversation(configuration: &configuration::Configuration, params: FetchServiceUserConversationParams) -> Result<ResponseContent<FetchServiceUserConversationSuccess>, Error<FetchServiceUserConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let user_sid = params.user_sid;
    let conversation_sid = params.conversation_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), UserSid=crate::apis::urlencode(user_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceUserConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceUserConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a conversation user from your account's default service
pub async fn fetch_user(configuration: &configuration::Configuration, params: FetchUserParams) -> Result<ResponseContent<FetchUserSuccess>, Error<FetchUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Users/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific User Conversation.
pub async fn fetch_user_conversation(configuration: &configuration::Configuration, params: FetchUserConversationParams) -> Result<ResponseContent<FetchUserConversationSuccess>, Error<FetchUserConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_sid = params.user_sid;
    let conversation_sid = params.conversation_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Users/{UserSid}/Conversations/{ConversationSid}", local_var_configuration.base_path, UserSid=crate::apis::urlencode(user_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUserConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUserConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of conversations in your account's default service
pub async fn list_conversation(configuration: &configuration::Configuration, params: ListConversationParams) -> Result<ResponseContent<ListConversationSuccess>, Error<ListConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all messages in the conversation
pub async fn list_conversation_message(configuration: &configuration::Configuration, params: ListConversationMessageParams) -> Result<ResponseContent<ListConversationMessageSuccess>, Error<ListConversationMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let order = params.order;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Messages", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListConversationMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListConversationMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all delivery and read receipts of the conversation message
pub async fn list_conversation_message_receipt(configuration: &configuration::Configuration, params: ListConversationMessageReceiptParams) -> Result<ResponseContent<ListConversationMessageReceiptSuccess>, Error<ListConversationMessageReceiptError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let message_sid = params.message_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), MessageSid=crate::apis::urlencode(message_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListConversationMessageReceiptSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListConversationMessageReceiptError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all participants of the conversation
pub async fn list_conversation_participant(configuration: &configuration::Configuration, params: ListConversationParticipantParams) -> Result<ResponseContent<ListConversationParticipantSuccess>, Error<ListConversationParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Participants", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListConversationParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListConversationParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all webhooks scoped to the conversation
pub async fn list_conversation_scoped_webhook(configuration: &configuration::Configuration, params: ListConversationScopedWebhookParams) -> Result<ResponseContent<ListConversationScopedWebhookSuccess>, Error<ListConversationScopedWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Webhooks", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListConversationScopedWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListConversationScopedWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all push notification credentials on your account
pub async fn list_credential(configuration: &configuration::Configuration, params: ListCredentialParams) -> Result<ResponseContent<ListCredentialSuccess>, Error<ListCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified.
pub async fn list_participant_conversation(configuration: &configuration::Configuration, params: ListParticipantConversationParams) -> Result<ResponseContent<ListParticipantConversationSuccess>, Error<ListParticipantConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let identity = params.identity;
    let address = params.address;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ParticipantConversations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = address {
        local_var_req_builder = local_var_req_builder.query(&[("Address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListParticipantConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListParticipantConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all user roles in your account's default service
pub async fn list_role(configuration: &configuration::Configuration, params: ListRoleParams) -> Result<ResponseContent<ListRoleSuccess>, Error<ListRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Roles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all conversation services on your account
pub async fn list_service(configuration: &configuration::Configuration, params: ListServiceParams) -> Result<ResponseContent<ListServiceSuccess>, Error<ListServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all push notification bindings in the conversation service
pub async fn list_service_binding(configuration: &configuration::Configuration, params: ListServiceBindingParams) -> Result<ResponseContent<ListServiceBindingSuccess>, Error<ListServiceBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let binding_type = params.binding_type;
    let identity = params.identity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Bindings", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = binding_type {
        local_var_req_builder = local_var_req_builder.query(&[("BindingType", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of conversations in your service
pub async fn list_service_conversation(configuration: &configuration::Configuration, params: ListServiceConversationParams) -> Result<ResponseContent<ListServiceConversationSuccess>, Error<ListServiceConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all messages in the conversation
pub async fn list_service_conversation_message(configuration: &configuration::Configuration, params: ListServiceConversationMessageParams) -> Result<ResponseContent<ListServiceConversationMessageSuccess>, Error<ListServiceConversationMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let order = params.order;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceConversationMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceConversationMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all delivery and read receipts of the conversation message
pub async fn list_service_conversation_message_receipt(configuration: &configuration::Configuration, params: ListServiceConversationMessageReceiptParams) -> Result<ResponseContent<ListServiceConversationMessageReceiptSuccess>, Error<ListServiceConversationMessageReceiptError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let message_sid = params.message_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), MessageSid=crate::apis::urlencode(message_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceConversationMessageReceiptSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceConversationMessageReceiptError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all participants of the conversation
pub async fn list_service_conversation_participant(configuration: &configuration::Configuration, params: ListServiceConversationParticipantParams) -> Result<ResponseContent<ListServiceConversationParticipantSuccess>, Error<ListServiceConversationParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceConversationParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceConversationParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all webhooks scoped to the conversation
pub async fn list_service_conversation_scoped_webhook(configuration: &configuration::Configuration, params: ListServiceConversationScopedWebhookParams) -> Result<ResponseContent<ListServiceConversationScopedWebhookSuccess>, Error<ListServiceConversationScopedWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceConversationScopedWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceConversationScopedWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified.
pub async fn list_service_participant_conversation(configuration: &configuration::Configuration, params: ListServiceParticipantConversationParams) -> Result<ResponseContent<ListServiceParticipantConversationSuccess>, Error<ListServiceParticipantConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let identity = params.identity;
    let address = params.address;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/ParticipantConversations", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = address {
        local_var_req_builder = local_var_req_builder.query(&[("Address", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceParticipantConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceParticipantConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all user roles in your service
pub async fn list_service_role(configuration: &configuration::Configuration, params: ListServiceRoleParams) -> Result<ResponseContent<ListServiceRoleSuccess>, Error<ListServiceRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Roles", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all conversation users in your service
pub async fn list_service_user(configuration: &configuration::Configuration, params: ListServiceUserParams) -> Result<ResponseContent<ListServiceUserSuccess>, Error<ListServiceUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Users", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all User Conversations for the User.
pub async fn list_service_user_conversation(configuration: &configuration::Configuration, params: ListServiceUserConversationParams) -> Result<ResponseContent<ListServiceUserConversationSuccess>, Error<ListServiceUserConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let user_sid = params.user_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), UserSid=crate::apis::urlencode(user_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceUserConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceUserConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all conversation users in your account's default service
pub async fn list_user(configuration: &configuration::Configuration, params: ListUserParams) -> Result<ResponseContent<ListUserSuccess>, Error<ListUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Users", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all User Conversations for the User.
pub async fn list_user_conversation(configuration: &configuration::Configuration, params: ListUserConversationParams) -> Result<ResponseContent<ListUserConversationSuccess>, Error<ListUserConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_sid = params.user_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Users/{UserSid}/Conversations", local_var_configuration.base_path, UserSid=crate::apis::urlencode(user_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the global configuration of conversations on your account
pub async fn update_configuration(configuration: &configuration::Configuration, params: UpdateConfigurationParams) -> Result<ResponseContent<UpdateConfigurationSuccess>, Error<UpdateConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let default_chat_service_sid = params.default_chat_service_sid;
    let default_closed_timer = params.default_closed_timer;
    let default_inactive_timer = params.default_inactive_timer;
    let default_messaging_service_sid = params.default_messaging_service_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Configuration", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = default_chat_service_sid {
        local_var_form_params.insert("DefaultChatServiceSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_closed_timer {
        local_var_form_params.insert("DefaultClosedTimer", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_inactive_timer {
        local_var_form_params.insert("DefaultInactiveTimer", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_messaging_service_sid {
        local_var_form_params.insert("DefaultMessagingServiceSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_configuration_webhook(configuration: &configuration::Configuration, params: UpdateConfigurationWebhookParams) -> Result<ResponseContent<UpdateConfigurationWebhookSuccess>, Error<UpdateConfigurationWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let filters = params.filters;
    let method = params.method;
    let post_webhook_url = params.post_webhook_url;
    let pre_webhook_url = params.pre_webhook_url;
    let target = params.target;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Configuration/Webhooks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = filters {
        local_var_form_params.insert("Filters", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = method {
        local_var_form_params.insert("Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = post_webhook_url {
        local_var_form_params.insert("PostWebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = pre_webhook_url {
        local_var_form_params.insert("PreWebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = target {
        local_var_form_params.insert("Target", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConfigurationWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConfigurationWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing conversation in your account's default service
pub async fn update_conversation(configuration: &configuration::Configuration, params: UpdateConversationParams) -> Result<ResponseContent<UpdateConversationSuccess>, Error<UpdateConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let friendly_name = params.friendly_name;
    let messaging_service_sid = params.messaging_service_sid;
    let state = params.state;
    let timers_closed = params.timers_closed;
    let timers_inactive = params.timers_inactive;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_service_sid {
        local_var_form_params.insert("MessagingServiceSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = state {
        local_var_form_params.insert("State", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timers_closed {
        local_var_form_params.insert("Timers.Closed", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timers_inactive {
        local_var_form_params.insert("Timers.Inactive", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing message in the conversation
pub async fn update_conversation_message(configuration: &configuration::Configuration, params: UpdateConversationMessageParams) -> Result<ResponseContent<UpdateConversationMessageSuccess>, Error<UpdateConversationMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let author = params.author;
    let body = params.body;
    let date_created = params.date_created;
    let date_updated = params.date_updated;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Messages/{Sid}", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = author {
        local_var_form_params.insert("Author", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConversationMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConversationMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing participant in the conversation
pub async fn update_conversation_participant(configuration: &configuration::Configuration, params: UpdateConversationParticipantParams) -> Result<ResponseContent<UpdateConversationParticipantSuccess>, Error<UpdateConversationParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let identity = params.identity;
    let last_read_message_index = params.last_read_message_index;
    let last_read_timestamp = params.last_read_timestamp;
    let messaging_binding_projected_address = params.messaging_binding_projected_address;
    let messaging_binding_proxy_address = params.messaging_binding_proxy_address;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Participants/{Sid}", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = identity {
        local_var_form_params.insert("Identity", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_read_message_index {
        local_var_form_params.insert("LastReadMessageIndex", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_read_timestamp {
        local_var_form_params.insert("LastReadTimestamp", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_binding_projected_address {
        local_var_form_params.insert("MessagingBinding.ProjectedAddress", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_binding_proxy_address {
        local_var_form_params.insert("MessagingBinding.ProxyAddress", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConversationParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConversationParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing conversation-scoped webhook
pub async fn update_conversation_scoped_webhook(configuration: &configuration::Configuration, params: UpdateConversationScopedWebhookParams) -> Result<ResponseContent<UpdateConversationScopedWebhookSuccess>, Error<UpdateConversationScopedWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;
    let configuration_filters = params.configuration_filters;
    let configuration_flow_sid = params.configuration_flow_sid;
    let configuration_method = params.configuration_method;
    let configuration_triggers = params.configuration_triggers;
    let configuration_url = params.configuration_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Conversations/{ConversationSid}/Webhooks/{Sid}", local_var_configuration.base_path, ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = configuration_filters {
        local_var_form_params.insert("Configuration.Filters", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_flow_sid {
        local_var_form_params.insert("Configuration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_method {
        local_var_form_params.insert("Configuration.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_triggers {
        local_var_form_params.insert("Configuration.Triggers", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_url {
        local_var_form_params.insert("Configuration.Url", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConversationScopedWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConversationScopedWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing push notification credential on your account
pub async fn update_credential(configuration: &configuration::Configuration, params: UpdateCredentialParams) -> Result<ResponseContent<UpdateCredentialSuccess>, Error<UpdateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;
    let _type = params._type;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = _type {
        local_var_form_params.insert("Type", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing user role in your account's default service
pub async fn update_role(configuration: &configuration::Configuration, params: UpdateRoleParams) -> Result<ResponseContent<UpdateRoleSuccess>, Error<UpdateRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let permission = params.permission;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Roles/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Permission", permission.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update configuration settings of a conversation service
pub async fn update_service_configuration(configuration: &configuration::Configuration, params: UpdateServiceConfigurationParams) -> Result<ResponseContent<UpdateServiceConfigurationSuccess>, Error<UpdateServiceConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let default_chat_service_role_sid = params.default_chat_service_role_sid;
    let default_conversation_creator_role_sid = params.default_conversation_creator_role_sid;
    let default_conversation_role_sid = params.default_conversation_role_sid;
    let reachability_enabled = params.reachability_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Configuration", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = default_chat_service_role_sid {
        local_var_form_params.insert("DefaultChatServiceRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_conversation_creator_role_sid {
        local_var_form_params.insert("DefaultConversationCreatorRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_conversation_role_sid {
        local_var_form_params.insert("DefaultConversationRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_enabled {
        local_var_form_params.insert("ReachabilityEnabled", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing conversation in your service
pub async fn update_service_conversation(configuration: &configuration::Configuration, params: UpdateServiceConversationParams) -> Result<ResponseContent<UpdateServiceConversationSuccess>, Error<UpdateServiceConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let friendly_name = params.friendly_name;
    let messaging_service_sid = params.messaging_service_sid;
    let state = params.state;
    let timers_closed = params.timers_closed;
    let timers_inactive = params.timers_inactive;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_service_sid {
        local_var_form_params.insert("MessagingServiceSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = state {
        local_var_form_params.insert("State", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timers_closed {
        local_var_form_params.insert("Timers.Closed", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timers_inactive {
        local_var_form_params.insert("Timers.Inactive", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing message in the conversation
pub async fn update_service_conversation_message(configuration: &configuration::Configuration, params: UpdateServiceConversationMessageParams) -> Result<ResponseContent<UpdateServiceConversationMessageSuccess>, Error<UpdateServiceConversationMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let author = params.author;
    let body = params.body;
    let date_created = params.date_created;
    let date_updated = params.date_updated;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = author {
        local_var_form_params.insert("Author", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceConversationMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceConversationMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing participant in the conversation
pub async fn update_service_conversation_participant(configuration: &configuration::Configuration, params: UpdateServiceConversationParticipantParams) -> Result<ResponseContent<UpdateServiceConversationParticipantSuccess>, Error<UpdateServiceConversationParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let identity = params.identity;
    let last_read_message_index = params.last_read_message_index;
    let last_read_timestamp = params.last_read_timestamp;
    let messaging_binding_projected_address = params.messaging_binding_projected_address;
    let messaging_binding_proxy_address = params.messaging_binding_proxy_address;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = identity {
        local_var_form_params.insert("Identity", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_read_message_index {
        local_var_form_params.insert("LastReadMessageIndex", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_read_timestamp {
        local_var_form_params.insert("LastReadTimestamp", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_binding_projected_address {
        local_var_form_params.insert("MessagingBinding.ProjectedAddress", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_binding_proxy_address {
        local_var_form_params.insert("MessagingBinding.ProxyAddress", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceConversationParticipantSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceConversationParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing conversation-scoped webhook
pub async fn update_service_conversation_scoped_webhook(configuration: &configuration::Configuration, params: UpdateServiceConversationScopedWebhookParams) -> Result<ResponseContent<UpdateServiceConversationScopedWebhookSuccess>, Error<UpdateServiceConversationScopedWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let conversation_sid = params.conversation_sid;
    let sid = params.sid;
    let configuration_filters = params.configuration_filters;
    let configuration_flow_sid = params.configuration_flow_sid;
    let configuration_method = params.configuration_method;
    let configuration_triggers = params.configuration_triggers;
    let configuration_url = params.configuration_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), ConversationSid=crate::apis::urlencode(conversation_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = configuration_filters {
        local_var_form_params.insert("Configuration.Filters", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_flow_sid {
        local_var_form_params.insert("Configuration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_method {
        local_var_form_params.insert("Configuration.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_triggers {
        local_var_form_params.insert("Configuration.Triggers", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = configuration_url {
        local_var_form_params.insert("Configuration.Url", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceConversationScopedWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceConversationScopedWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update push notification service settings
pub async fn update_service_notification(configuration: &configuration::Configuration, params: UpdateServiceNotificationParams) -> Result<ResponseContent<UpdateServiceNotificationSuccess>, Error<UpdateServiceNotificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let added_to_conversation_enabled = params.added_to_conversation_enabled;
    let added_to_conversation_sound = params.added_to_conversation_sound;
    let added_to_conversation_template = params.added_to_conversation_template;
    let log_enabled = params.log_enabled;
    let new_message_badge_count_enabled = params.new_message_badge_count_enabled;
    let new_message_enabled = params.new_message_enabled;
    let new_message_sound = params.new_message_sound;
    let new_message_template = params.new_message_template;
    let removed_from_conversation_enabled = params.removed_from_conversation_enabled;
    let removed_from_conversation_sound = params.removed_from_conversation_sound;
    let removed_from_conversation_template = params.removed_from_conversation_template;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Configuration/Notifications", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = added_to_conversation_enabled {
        local_var_form_params.insert("AddedToConversation.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = added_to_conversation_sound {
        local_var_form_params.insert("AddedToConversation.Sound", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = added_to_conversation_template {
        local_var_form_params.insert("AddedToConversation.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = log_enabled {
        local_var_form_params.insert("LogEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = new_message_badge_count_enabled {
        local_var_form_params.insert("NewMessage.BadgeCountEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = new_message_enabled {
        local_var_form_params.insert("NewMessage.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = new_message_sound {
        local_var_form_params.insert("NewMessage.Sound", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = new_message_template {
        local_var_form_params.insert("NewMessage.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = removed_from_conversation_enabled {
        local_var_form_params.insert("RemovedFromConversation.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = removed_from_conversation_sound {
        local_var_form_params.insert("RemovedFromConversation.Sound", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = removed_from_conversation_template {
        local_var_form_params.insert("RemovedFromConversation.Template", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceNotificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceNotificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing user role in your service
pub async fn update_service_role(configuration: &configuration::Configuration, params: UpdateServiceRoleParams) -> Result<ResponseContent<UpdateServiceRoleSuccess>, Error<UpdateServiceRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;
    let permission = params.permission;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Permission", permission.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing conversation user in your service
pub async fn update_service_user(configuration: &configuration::Configuration, params: UpdateServiceUserParams) -> Result<ResponseContent<UpdateServiceUserSuccess>, Error<UpdateServiceUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Users/{Sid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific User Conversation.
pub async fn update_service_user_conversation(configuration: &configuration::Configuration, params: UpdateServiceUserConversationParams) -> Result<ResponseContent<UpdateServiceUserConversationSuccess>, Error<UpdateServiceUserConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_service_sid = params.chat_service_sid;
    let user_sid = params.user_sid;
    let conversation_sid = params.conversation_sid;
    let last_read_message_index = params.last_read_message_index;
    let last_read_timestamp = params.last_read_timestamp;
    let notification_level = params.notification_level;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}", local_var_configuration.base_path, ChatServiceSid=crate::apis::urlencode(chat_service_sid), UserSid=crate::apis::urlencode(user_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = last_read_message_index {
        local_var_form_params.insert("LastReadMessageIndex", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_read_timestamp {
        local_var_form_params.insert("LastReadTimestamp", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notification_level {
        local_var_form_params.insert("NotificationLevel", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceUserConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceUserConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing conversation user in your account's default service
pub async fn update_user(configuration: &configuration::Configuration, params: UpdateUserParams) -> Result<ResponseContent<UpdateUserSuccess>, Error<UpdateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Users/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header("X-Twilio-Webhook-Enabled", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific User Conversation.
pub async fn update_user_conversation(configuration: &configuration::Configuration, params: UpdateUserConversationParams) -> Result<ResponseContent<UpdateUserConversationSuccess>, Error<UpdateUserConversationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_sid = params.user_sid;
    let conversation_sid = params.conversation_sid;
    let last_read_message_index = params.last_read_message_index;
    let last_read_timestamp = params.last_read_timestamp;
    let notification_level = params.notification_level;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Users/{UserSid}/Conversations/{ConversationSid}", local_var_configuration.base_path, UserSid=crate::apis::urlencode(user_sid), ConversationSid=crate::apis::urlencode(conversation_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = last_read_message_index {
        local_var_form_params.insert("LastReadMessageIndex", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_read_timestamp {
        local_var_form_params.insert("LastReadTimestamp", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notification_level {
        local_var_form_params.insert("NotificationLevel", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateUserConversationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateUserConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

