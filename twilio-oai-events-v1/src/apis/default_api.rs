/*
 * Twilio - Events
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method [`create_sink`]
#[derive(Clone, Debug, Default)]
pub struct CreateSinkParams {
    /// A human readable description for the Sink **This value should not contain PII.**
    pub description: String,
    /// The information required for Twilio to connect to the provided Sink encoded as JSON.
    pub sink_configuration: serde_json::Value,
    /// The Sink type. Can only be \\\"kinesis\\\" or \\\"webhook\\\" currently.
    pub sink_type: String,
}

/// struct for passing parameters to the method [`create_sink_test`]
#[derive(Clone, Debug, Default)]
pub struct CreateSinkTestParams {
    /// A 34 character string that uniquely identifies the Sink to be Tested.
    pub sid: String,
}

/// struct for passing parameters to the method [`create_sink_validate`]
#[derive(Clone, Debug, Default)]
pub struct CreateSinkValidateParams {
    /// A 34 character string that uniquely identifies the Sink being validated.
    pub sid: String,
    /// A 34 character string that uniquely identifies the test event for a Sink being validated.
    pub test_id: String,
}

/// struct for passing parameters to the method [`create_subscribed_event`]
#[derive(Clone, Debug, Default)]
pub struct CreateSubscribedEventParams {
    /// The unique SID identifier of the Subscription.
    pub subscription_sid: String,
    /// Type of event being subscribed to.
    pub type_: String,
    /// The schema version that the subscription should use.
    pub schema_version: Option<i32>,
}

/// struct for passing parameters to the method [`create_subscription`]
#[derive(Clone, Debug, Default)]
pub struct CreateSubscriptionParams {
    /// A human readable description for the Subscription **This value should not contain PII.**
    pub description: String,
    /// The SID of the sink that events selected by this subscription should be sent to. Sink must be active for the subscription to be created.
    pub sink_sid: String,
    /// An array of objects containing the subscribed Event Types
    pub types: Vec<serde_json::Value>,
}

/// struct for passing parameters to the method [`delete_sink`]
#[derive(Clone, Debug, Default)]
pub struct DeleteSinkParams {
    /// A 34 character string that uniquely identifies this Sink.
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_subscribed_event`]
#[derive(Clone, Debug, Default)]
pub struct DeleteSubscribedEventParams {
    /// The unique SID identifier of the Subscription.
    pub subscription_sid: String,
    /// Type of event being subscribed to.
    pub type_: String,
}

/// struct for passing parameters to the method [`delete_subscription`]
#[derive(Clone, Debug, Default)]
pub struct DeleteSubscriptionParams {
    /// A 34 character string that uniquely identifies this Subscription.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_event_type`]
#[derive(Clone, Debug, Default)]
pub struct FetchEventTypeParams {
    /// A string that uniquely identifies this Event Type.
    pub type_: String,
}

/// struct for passing parameters to the method [`fetch_schema`]
#[derive(Clone, Debug, Default)]
pub struct FetchSchemaParams {
    /// The unique identifier of the schema. Each schema can have multiple versions, that share the same id.
    pub id: String,
}

/// struct for passing parameters to the method [`fetch_schema_version`]
#[derive(Clone, Debug, Default)]
pub struct FetchSchemaVersionParams {
    /// The unique identifier of the schema. Each schema can have multiple versions, that share the same id.
    pub id: String,
    /// The version of the schema
    pub schema_version: i32,
}

/// struct for passing parameters to the method [`fetch_sink`]
#[derive(Clone, Debug, Default)]
pub struct FetchSinkParams {
    /// A 34 character string that uniquely identifies this Sink.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_subscribed_event`]
#[derive(Clone, Debug, Default)]
pub struct FetchSubscribedEventParams {
    /// The unique SID identifier of the Subscription.
    pub subscription_sid: String,
    /// Type of event being subscribed to.
    pub type_: String,
}

/// struct for passing parameters to the method [`fetch_subscription`]
#[derive(Clone, Debug, Default)]
pub struct FetchSubscriptionParams {
    /// A 34 character string that uniquely identifies this Subscription.
    pub sid: String,
}

/// struct for passing parameters to the method [`list_event_type`]
#[derive(Clone, Debug, Default)]
pub struct ListEventTypeParams {
    /// A string parameter filtering the results to return only the Event Types using a given schema.
    pub schema_id: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_schema_version`]
#[derive(Clone, Debug, Default)]
pub struct ListSchemaVersionParams {
    /// The unique identifier of the schema. Each schema can have multiple versions, that share the same id.
    pub id: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_sink`]
#[derive(Clone, Debug, Default)]
pub struct ListSinkParams {
    /// A boolean query parameter filtering the results to return sinks used/not used by a subscription.
    pub in_use: Option<bool>,
    /// A String query parameter filtering the results by status `initialized`, `validating`, `active` or `failed`.
    pub status: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_subscribed_event`]
#[derive(Clone, Debug, Default)]
pub struct ListSubscribedEventParams {
    /// The unique SID identifier of the Subscription.
    pub subscription_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_subscription`]
#[derive(Clone, Debug, Default)]
pub struct ListSubscriptionParams {
    /// The SID of the sink that the list of Subscriptions should be filtered by.
    pub sink_sid: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`update_sink`]
#[derive(Clone, Debug, Default)]
pub struct UpdateSinkParams {
    /// A 34 character string that uniquely identifies this Sink.
    pub sid: String,
    /// A human readable description for the Sink **This value should not contain PII.**
    pub description: String,
}

/// struct for passing parameters to the method [`update_subscribed_event`]
#[derive(Clone, Debug, Default)]
pub struct UpdateSubscribedEventParams {
    /// The unique SID identifier of the Subscription.
    pub subscription_sid: String,
    /// Type of event being subscribed to.
    pub type_: String,
    /// The schema version that the subscription should use.
    pub schema_version: Option<i32>,
}

/// struct for passing parameters to the method [`update_subscription`]
#[derive(Clone, Debug, Default)]
pub struct UpdateSubscriptionParams {
    /// A 34 character string that uniquely identifies this Subscription.
    pub sid: String,
    /// A human readable description for the Subscription.
    pub description: Option<String>,
    /// The SID of the sink that events selected by this subscription should be sent to. Sink must be active for the subscription to be created.
    pub sink_sid: Option<String>,
}

/// struct for typed successes of method [`create_sink`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSinkSuccess {
    Status201(crate::models::EventsV1Sink),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_sink_test`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSinkTestSuccess {
    Status201(crate::models::EventsV1SinkSinkTest),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_sink_validate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSinkValidateSuccess {
    Status201(crate::models::EventsV1SinkSinkValidate),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_subscribed_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubscribedEventSuccess {
    Status201(crate::models::EventsV1SubscriptionSubscribedEvent),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubscriptionSuccess {
    Status201(crate::models::EventsV1Subscription),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_sink`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSinkSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_subscribed_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubscribedEventSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubscriptionSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_event_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEventTypeSuccess {
    Status200(crate::models::EventsV1EventType),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSchemaSuccess {
    Status200(crate::models::EventsV1Schema),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_schema_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSchemaVersionSuccess {
    Status200(crate::models::EventsV1SchemaSchemaVersion),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_sink`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSinkSuccess {
    Status200(crate::models::EventsV1Sink),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_subscribed_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSubscribedEventSuccess {
    Status200(crate::models::EventsV1SubscriptionSubscribedEvent),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSubscriptionSuccess {
    Status200(crate::models::EventsV1Subscription),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_event_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEventTypeSuccess {
    Status200(crate::models::ListEventTypeResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_schema_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSchemaVersionSuccess {
    Status200(crate::models::ListSchemaVersionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_sink`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSinkSuccess {
    Status200(crate::models::ListSinkResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_subscribed_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSubscribedEventSuccess {
    Status200(crate::models::ListSubscribedEventResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSubscriptionSuccess {
    Status200(crate::models::ListSubscriptionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_sink`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSinkSuccess {
    Status200(crate::models::EventsV1Sink),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_subscribed_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSubscribedEventSuccess {
    Status200(crate::models::EventsV1SubscriptionSubscribedEvent),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSubscriptionSuccess {
    Status200(crate::models::EventsV1Subscription),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sink`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSinkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sink_test`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSinkTestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sink_validate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSinkValidateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_subscribed_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubscribedEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_sink`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSinkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_subscribed_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubscribedEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_event_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEventTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_schema`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSchemaError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_schema_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSchemaVersionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_sink`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSinkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_subscribed_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSubscribedEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_event_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEventTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_schema_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSchemaVersionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_sink`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSinkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_subscribed_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSubscribedEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_sink`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSinkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_subscribed_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSubscribedEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// Create a new Sink
pub async fn create_sink(
    configuration: &configuration::Configuration,
    params: CreateSinkParams,
) -> Result<ResponseContent<CreateSinkSuccess>, Error<CreateSinkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let description = params.description;
    let sink_configuration = params.sink_configuration;
    let sink_type = params.sink_type;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sinks", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Description", description.to_string());
    local_var_form_params.insert("SinkConfiguration", sink_configuration.to_string());
    local_var_form_params.insert("SinkType", sink_type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSinkSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSinkError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Sink Test Event for the given Sink.
pub async fn create_sink_test(
    configuration: &configuration::Configuration,
    params: CreateSinkTestParams,
) -> Result<ResponseContent<CreateSinkTestSuccess>, Error<CreateSinkTestError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Sinks/{Sid}/Test",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSinkTestSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSinkTestError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Validate that a test event for a Sink was received.
pub async fn create_sink_validate(
    configuration: &configuration::Configuration,
    params: CreateSinkValidateParams,
) -> Result<ResponseContent<CreateSinkValidateSuccess>, Error<CreateSinkValidateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let test_id = params.test_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Sinks/{Sid}/Validate",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("TestId", test_id.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSinkValidateSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSinkValidateError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Subscribed Event type for the subscription
pub async fn create_subscribed_event(
    configuration: &configuration::Configuration,
    params: CreateSubscribedEventParams,
) -> Result<ResponseContent<CreateSubscribedEventSuccess>, Error<CreateSubscribedEventError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let subscription_sid = params.subscription_sid;
    let type_ = params.type_;
    let schema_version = params.schema_version;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents",
        local_var_configuration.base_path,
        SubscriptionSid = crate::apis::urlencode(subscription_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = schema_version {
        local_var_form_params.insert("SchemaVersion", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Type", type_.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSubscribedEventSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSubscribedEventError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Subscription.
pub async fn create_subscription(
    configuration: &configuration::Configuration,
    params: CreateSubscriptionParams,
) -> Result<ResponseContent<CreateSubscriptionSuccess>, Error<CreateSubscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let description = params.description;
    let sink_sid = params.sink_sid;
    let types = params.types;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Subscriptions", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Description", description.to_string());
    local_var_form_params.insert("SinkSid", sink_sid.to_string());
    local_var_form_params.insert(
        "Types",
        types
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
    );
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSubscriptionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSubscriptionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Sink.
pub async fn delete_sink(
    configuration: &configuration::Configuration,
    params: DeleteSinkParams,
) -> Result<ResponseContent<DeleteSinkSuccess>, Error<DeleteSinkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Sinks/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSinkSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSinkError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an event type from a subscription.
pub async fn delete_subscribed_event(
    configuration: &configuration::Configuration,
    params: DeleteSubscribedEventParams,
) -> Result<ResponseContent<DeleteSubscribedEventSuccess>, Error<DeleteSubscribedEventError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let subscription_sid = params.subscription_sid;
    let type_ = params.type_;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}",
        local_var_configuration.base_path,
        SubscriptionSid = crate::apis::urlencode(subscription_sid),
        Type = crate::apis::urlencode(type_)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSubscribedEventSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSubscribedEventError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Subscription.
pub async fn delete_subscription(
    configuration: &configuration::Configuration,
    params: DeleteSubscriptionParams,
) -> Result<ResponseContent<DeleteSubscriptionSuccess>, Error<DeleteSubscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Subscriptions/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSubscriptionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSubscriptionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Event Type.
pub async fn fetch_event_type(
    configuration: &configuration::Configuration,
    params: FetchEventTypeParams,
) -> Result<ResponseContent<FetchEventTypeSuccess>, Error<FetchEventTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let type_ = params.type_;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Types/{Type}",
        local_var_configuration.base_path,
        Type = crate::apis::urlencode(type_)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchEventTypeSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchEventTypeError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific schema with its nested versions.
pub async fn fetch_schema(
    configuration: &configuration::Configuration,
    params: FetchSchemaParams,
) -> Result<ResponseContent<FetchSchemaSuccess>, Error<FetchSchemaError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Schemas/{Id}",
        local_var_configuration.base_path,
        Id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSchemaSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSchemaError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific schema and version.
pub async fn fetch_schema_version(
    configuration: &configuration::Configuration,
    params: FetchSchemaVersionParams,
) -> Result<ResponseContent<FetchSchemaVersionSuccess>, Error<FetchSchemaVersionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let schema_version = params.schema_version;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Schemas/{Id}/Versions/{SchemaVersion}",
        local_var_configuration.base_path,
        Id = crate::apis::urlencode(id),
        SchemaVersion = schema_version
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSchemaVersionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSchemaVersionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Sink.
pub async fn fetch_sink(
    configuration: &configuration::Configuration,
    params: FetchSinkParams,
) -> Result<ResponseContent<FetchSinkSuccess>, Error<FetchSinkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Sinks/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSinkSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSinkError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Read an Event for a Subscription.
pub async fn fetch_subscribed_event(
    configuration: &configuration::Configuration,
    params: FetchSubscribedEventParams,
) -> Result<ResponseContent<FetchSubscribedEventSuccess>, Error<FetchSubscribedEventError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let subscription_sid = params.subscription_sid;
    let type_ = params.type_;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}",
        local_var_configuration.base_path,
        SubscriptionSid = crate::apis::urlencode(subscription_sid),
        Type = crate::apis::urlencode(type_)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSubscribedEventSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSubscribedEventError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Subscription.
pub async fn fetch_subscription(
    configuration: &configuration::Configuration,
    params: FetchSubscriptionParams,
) -> Result<ResponseContent<FetchSubscriptionSuccess>, Error<FetchSubscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Subscriptions/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSubscriptionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSubscriptionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a paginated list of all the available Event Types.
pub async fn list_event_type(
    configuration: &configuration::Configuration,
    params: ListEventTypeParams,
) -> Result<ResponseContent<ListEventTypeSuccess>, Error<ListEventTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let schema_id = params.schema_id;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Types", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = schema_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("SchemaId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListEventTypeSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListEventTypeError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a paginated list of versions of the schema.
pub async fn list_schema_version(
    configuration: &configuration::Configuration,
    params: ListSchemaVersionParams,
) -> Result<ResponseContent<ListSchemaVersionSuccess>, Error<ListSchemaVersionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let id = params.id;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Schemas/{Id}/Versions",
        local_var_configuration.base_path,
        Id = crate::apis::urlencode(id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSchemaVersionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSchemaVersionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a paginated list of Sinks belonging to the account used to make the request.
pub async fn list_sink(
    configuration: &configuration::Configuration,
    params: ListSinkParams,
) -> Result<ResponseContent<ListSinkSuccess>, Error<ListSinkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let in_use = params.in_use;
    let status = params.status;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sinks", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = in_use {
        local_var_req_builder =
            local_var_req_builder.query(&[("InUse", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSinkSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSinkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Subscribed Event types for a Subscription.
pub async fn list_subscribed_event(
    configuration: &configuration::Configuration,
    params: ListSubscribedEventParams,
) -> Result<ResponseContent<ListSubscribedEventSuccess>, Error<ListSubscribedEventError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let subscription_sid = params.subscription_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents",
        local_var_configuration.base_path,
        SubscriptionSid = crate::apis::urlencode(subscription_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSubscribedEventSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSubscribedEventError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a paginated list of Subscriptions belonging to the account used to make the request.
pub async fn list_subscription(
    configuration: &configuration::Configuration,
    params: ListSubscriptionParams,
) -> Result<ResponseContent<ListSubscriptionSuccess>, Error<ListSubscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sink_sid = params.sink_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Subscriptions", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sink_sid {
        local_var_req_builder =
            local_var_req_builder.query(&[("SinkSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSubscriptionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSubscriptionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Sink
pub async fn update_sink(
    configuration: &configuration::Configuration,
    params: UpdateSinkParams,
) -> Result<ResponseContent<UpdateSinkSuccess>, Error<UpdateSinkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let description = params.description;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Sinks/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Description", description.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSinkSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSinkError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an Event for a Subscription.
pub async fn update_subscribed_event(
    configuration: &configuration::Configuration,
    params: UpdateSubscribedEventParams,
) -> Result<ResponseContent<UpdateSubscribedEventSuccess>, Error<UpdateSubscribedEventError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let subscription_sid = params.subscription_sid;
    let type_ = params.type_;
    let schema_version = params.schema_version;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}",
        local_var_configuration.base_path,
        SubscriptionSid = crate::apis::urlencode(subscription_sid),
        Type = crate::apis::urlencode(type_)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = schema_version {
        local_var_form_params.insert("SchemaVersion", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSubscribedEventSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSubscribedEventError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a Subscription.
pub async fn update_subscription(
    configuration: &configuration::Configuration,
    params: UpdateSubscriptionParams,
) -> Result<ResponseContent<UpdateSubscriptionSuccess>, Error<UpdateSubscriptionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let description = params.description;
    let sink_sid = params.sink_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Subscriptions/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = description {
        local_var_form_params.insert("Description", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sink_sid {
        local_var_form_params.insert("SinkSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSubscriptionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSubscriptionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
