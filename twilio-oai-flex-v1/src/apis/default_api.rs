/*
 * Twilio - Flex
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_channel`]
#[derive(Clone, Debug, Default)]
pub struct CreateChannelParams {
    /// The chat channel's friendly name.
    pub chat_friendly_name: String,
    /// The chat participant's friendly name.
    pub chat_user_friendly_name: String,
    /// The SID of the Flex Flow.
    pub flex_flow_sid: String,
    /// The `identity` value that uniquely identifies the new resource's chat User.
    pub identity: String,
    /// The chat channel's unique name.
    pub chat_unique_name: Option<String>,
    /// Whether to create the channel as long-lived.
    pub long_lived: Option<bool>,
    /// The pre-engagement data.
    pub pre_engagement_data: Option<String>,
    /// The Target Contact Identity, for example the phone number of an SMS.
    pub target: Option<String>,
    /// The Task attributes to be added for the TaskRouter Task.
    pub task_attributes: Option<String>,
    /// The SID of the TaskRouter Task. Only valid when integration type is `task`. `null` for integration types `studio` & `external`
    pub task_sid: Option<String>
}

/// struct for passing parameters to the method [`create_flex_flow`]
#[derive(Clone, Debug, Default)]
pub struct CreateFlexFlowParams {
    /// The channel type. Can be: `web`, `facebook`, `sms`, `whatsapp`, `line` or `custom`.
    pub channel_type: String,
    /// The SID of the chat service.
    pub chat_service_sid: String,
    /// A descriptive string that you create to describe the Flex Flow resource.
    pub friendly_name: String,
    /// The channel contact's Identity.
    pub contact_identity: Option<String>,
    /// Whether the new Flex Flow is enabled.
    pub enabled: Option<bool>,
    /// The Task Channel SID (TCXXXX) or unique name (e.g., `sms`) to use for the Task that will be created. Applicable and required when `integrationType` is `task`. The default value is `default`.
    pub integration_channel: Option<String>,
    /// In the context of outbound messaging, defines whether to create a Task immediately (and therefore reserve the conversation to current agent), or delay Task creation until the customer sends the first response. Set to false to create immediately, true to delay Task creation. This setting is only applicable for outbound messaging.
    pub integration_creation_on_message: Option<bool>,
    /// The SID of the Studio Flow. Required when `integrationType` is `studio`.
    pub integration_flow_sid: Option<String>,
    /// The Task priority of a new Task. The default priority is 0. Optional when `integrationType` is `task`, not applicable otherwise.
    pub integration_priority: Option<i32>,
    /// The number of times to retry the webhook if the first attempt fails. Can be an integer between 0 and 3 (inclusive), default is 3. Optional when `integrationType` is `external`, not applicable otherwise.
    pub integration_retry_count: Option<i32>,
    /// The Task timeout in seconds for a new Task. Default is 86,400 seconds (24 hours). Optional when `integrationType` is `task`, not applicable otherwise.
    pub integration_timeout: Option<i32>,
    /// The URL of the external webhook. Required when `integrationType` is `external`.
    pub integration_url: Option<String>,
    /// The Workflow SID for a new Task. Required when `integrationType` is `task`.
    pub integration_workflow_sid: Option<String>,
    /// The Workspace SID for a new Task. Required when `integrationType` is `task`.
    pub integration_workspace_sid: Option<String>,
    /// The software that will handle inbound messages. [Integration Type](https://www.twilio.com/docs/flex/developer/messaging/manage-flows#integration-types) can be: `studio`, `external`, or `task`.
    pub integration_type: Option<String>,
    /// When enabled, the Messaging Channel Janitor will remove active Proxy sessions if the associated Task is deleted outside of the Flex UI. Defaults to `false`.
    pub janitor_enabled: Option<bool>,
    /// When enabled, Flex will keep the chat channel active so that it may be used for subsequent interactions with a contact identity. Defaults to `false`.
    pub long_lived: Option<bool>
}

/// struct for passing parameters to the method [`create_web_channel`]
#[derive(Clone, Debug, Default)]
pub struct CreateWebChannelParams {
    /// The chat channel's friendly name.
    pub chat_friendly_name: String,
    /// The chat participant's friendly name.
    pub customer_friendly_name: String,
    /// The SID of the Flex Flow.
    pub flex_flow_sid: String,
    /// The chat identity.
    pub identity: String,
    /// The chat channel's unique name.
    pub chat_unique_name: Option<String>,
    /// The pre-engagement data.
    pub pre_engagement_data: Option<String>
}

/// struct for passing parameters to the method [`delete_channel`]
#[derive(Clone, Debug, Default)]
pub struct DeleteChannelParams {
    /// The SID of the Flex chat channel resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_flex_flow`]
#[derive(Clone, Debug, Default)]
pub struct DeleteFlexFlowParams {
    /// The SID of the Flex Flow resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_web_channel`]
#[derive(Clone, Debug, Default)]
pub struct DeleteWebChannelParams {
    /// The SID of the WebChannel resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_channel`]
#[derive(Clone, Debug, Default)]
pub struct FetchChannelParams {
    /// The SID of the Flex chat channel resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_configuration`]
#[derive(Clone, Debug, Default)]
pub struct FetchConfigurationParams {
    /// The Pinned UI version of the Configuration resource to fetch.
    pub ui_version: Option<String>
}

/// struct for passing parameters to the method [`fetch_flex_flow`]
#[derive(Clone, Debug, Default)]
pub struct FetchFlexFlowParams {
    /// The SID of the Flex Flow resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_web_channel`]
#[derive(Clone, Debug, Default)]
pub struct FetchWebChannelParams {
    /// The SID of the WebChannel resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`list_channel`]
#[derive(Clone, Debug, Default)]
pub struct ListChannelParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_flex_flow`]
#[derive(Clone, Debug, Default)]
pub struct ListFlexFlowParams {
    /// The `friendly_name` of the Flex Flow resources to read.
    pub friendly_name: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_web_channel`]
#[derive(Clone, Debug, Default)]
pub struct ListWebChannelParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`update_flex_flow`]
#[derive(Clone, Debug, Default)]
pub struct UpdateFlexFlowParams {
    /// The SID of the Flex Flow resource to update.
    pub sid: String,
    /// The channel type. Can be: `web`, `facebook`, `sms`, `whatsapp`, `line` or `custom`.
    pub channel_type: Option<String>,
    /// The SID of the chat service.
    pub chat_service_sid: Option<String>,
    /// The channel contact's Identity.
    pub contact_identity: Option<String>,
    /// Whether the new Flex Flow is enabled.
    pub enabled: Option<bool>,
    /// A descriptive string that you create to describe the Flex Flow resource.
    pub friendly_name: Option<String>,
    /// The Task Channel SID (TCXXXX) or unique name (e.g., `sms`) to use for the Task that will be created. Applicable and required when `integrationType` is `task`. The default value is `default`.
    pub integration_channel: Option<String>,
    /// In the context of outbound messaging, defines whether to create a Task immediately (and therefore reserve the conversation to current agent), or delay Task creation until the customer sends the first response. Set to false to create immediately, true to delay Task creation. This setting is only applicable for outbound messaging.
    pub integration_creation_on_message: Option<bool>,
    /// The SID of the Studio Flow. Required when `integrationType` is `studio`.
    pub integration_flow_sid: Option<String>,
    /// The Task priority of a new Task. The default priority is 0. Optional when `integrationType` is `task`, not applicable otherwise.
    pub integration_priority: Option<i32>,
    /// The number of times to retry the webhook if the first attempt fails. Can be an integer between 0 and 3 (inclusive), default is 3. Optional when `integrationType` is `external`, not applicable otherwise.
    pub integration_retry_count: Option<i32>,
    /// The Task timeout in seconds for a new Task. Default is 86,400 seconds (24 hours). Optional when `integrationType` is `task`, not applicable otherwise.
    pub integration_timeout: Option<i32>,
    /// The URL of the external webhook. Required when `integrationType` is `external`.
    pub integration_url: Option<String>,
    /// The Workflow SID for a new Task. Required when `integrationType` is `task`.
    pub integration_workflow_sid: Option<String>,
    /// The Workspace SID for a new Task. Required when `integrationType` is `task`.
    pub integration_workspace_sid: Option<String>,
    /// The software that will handle inbound messages. [Integration Type](https://www.twilio.com/docs/flex/developer/messaging/manage-flows#integration-types) can be: `studio`, `external`, or `task`.
    pub integration_type: Option<String>,
    /// When enabled, the Messaging Channel Janitor will remove active Proxy sessions if the associated Task is deleted outside of the Flex UI. Defaults to `false`.
    pub janitor_enabled: Option<bool>,
    /// When enabled, Flex will keep the chat channel active so that it may be used for subsequent interactions with a contact identity. Defaults to `false`.
    pub long_lived: Option<bool>
}

/// struct for passing parameters to the method [`update_web_channel`]
#[derive(Clone, Debug, Default)]
pub struct UpdateWebChannelParams {
    /// The SID of the WebChannel resource to update.
    pub sid: String,
    /// The chat status. Can only be `inactive`.
    pub chat_status: Option<String>,
    /// The post-engagement data.
    pub post_engagement_data: Option<String>
}


/// struct for typed successes of method [`create_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelSuccess {
    Status201(crate::models::FlexV1Channel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFlexFlowSuccess {
    Status201(crate::models::FlexV1FlexFlow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebChannelSuccess {
    Status201(crate::models::FlexV1WebChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFlexFlowSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelSuccess {
    Status200(crate::models::FlexV1Channel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConfigurationSuccess {
    Status200(crate::models::FlexV1Configuration),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFlexFlowSuccess {
    Status200(crate::models::FlexV1FlexFlow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWebChannelSuccess {
    Status200(crate::models::FlexV1WebChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelSuccess {
    Status200(crate::models::ListChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFlexFlowSuccess {
    Status200(crate::models::ListFlexFlowResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWebChannelSuccess {
    Status200(crate::models::ListWebChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFlexFlowSuccess {
    Status200(crate::models::FlexV1FlexFlow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebChannelSuccess {
    Status200(crate::models::FlexV1WebChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFlexFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFlexFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFlexFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWebChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFlexFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWebChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_flex_flow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFlexFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_web_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebChannelError {
    UnknownValue(serde_json::Value),
}


pub async fn create_channel(configuration: &configuration::Configuration, params: CreateChannelParams) -> Result<ResponseContent<CreateChannelSuccess>, Error<CreateChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_friendly_name = params.chat_friendly_name;
    let chat_user_friendly_name = params.chat_user_friendly_name;
    let flex_flow_sid = params.flex_flow_sid;
    let identity = params.identity;
    let chat_unique_name = params.chat_unique_name;
    let long_lived = params.long_lived;
    let pre_engagement_data = params.pre_engagement_data;
    let target = params.target;
    let task_attributes = params.task_attributes;
    let task_sid = params.task_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Channels", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ChatFriendlyName", chat_friendly_name.to_string());
    if let Some(local_var_param_value) = chat_unique_name {
        local_var_form_params.insert("ChatUniqueName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("ChatUserFriendlyName", chat_user_friendly_name.to_string());
    local_var_form_params.insert("FlexFlowSid", flex_flow_sid.to_string());
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = long_lived {
        local_var_form_params.insert("LongLived", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = pre_engagement_data {
        local_var_form_params.insert("PreEngagementData", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = target {
        local_var_form_params.insert("Target", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = task_attributes {
        local_var_form_params.insert("TaskAttributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = task_sid {
        local_var_form_params.insert("TaskSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_flex_flow(configuration: &configuration::Configuration, params: CreateFlexFlowParams) -> Result<ResponseContent<CreateFlexFlowSuccess>, Error<CreateFlexFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let channel_type = params.channel_type;
    let chat_service_sid = params.chat_service_sid;
    let friendly_name = params.friendly_name;
    let contact_identity = params.contact_identity;
    let enabled = params.enabled;
    let integration_channel = params.integration_channel;
    let integration_creation_on_message = params.integration_creation_on_message;
    let integration_flow_sid = params.integration_flow_sid;
    let integration_priority = params.integration_priority;
    let integration_retry_count = params.integration_retry_count;
    let integration_timeout = params.integration_timeout;
    let integration_url = params.integration_url;
    let integration_workflow_sid = params.integration_workflow_sid;
    let integration_workspace_sid = params.integration_workspace_sid;
    let integration_type = params.integration_type;
    let janitor_enabled = params.janitor_enabled;
    let long_lived = params.long_lived;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/FlexFlows", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ChannelType", channel_type.to_string());
    local_var_form_params.insert("ChatServiceSid", chat_service_sid.to_string());
    if let Some(local_var_param_value) = contact_identity {
        local_var_form_params.insert("ContactIdentity", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = enabled {
        local_var_form_params.insert("Enabled", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = integration_channel {
        local_var_form_params.insert("Integration.Channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_creation_on_message {
        local_var_form_params.insert("Integration.CreationOnMessage", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_flow_sid {
        local_var_form_params.insert("Integration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_priority {
        local_var_form_params.insert("Integration.Priority", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_retry_count {
        local_var_form_params.insert("Integration.RetryCount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_timeout {
        local_var_form_params.insert("Integration.Timeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_url {
        local_var_form_params.insert("Integration.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_workflow_sid {
        local_var_form_params.insert("Integration.WorkflowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_workspace_sid {
        local_var_form_params.insert("Integration.WorkspaceSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_type {
        local_var_form_params.insert("IntegrationType", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = janitor_enabled {
        local_var_form_params.insert("JanitorEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = long_lived {
        local_var_form_params.insert("LongLived", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateFlexFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateFlexFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_web_channel(configuration: &configuration::Configuration, params: CreateWebChannelParams) -> Result<ResponseContent<CreateWebChannelSuccess>, Error<CreateWebChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chat_friendly_name = params.chat_friendly_name;
    let customer_friendly_name = params.customer_friendly_name;
    let flex_flow_sid = params.flex_flow_sid;
    let identity = params.identity;
    let chat_unique_name = params.chat_unique_name;
    let pre_engagement_data = params.pre_engagement_data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/WebChannels", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ChatFriendlyName", chat_friendly_name.to_string());
    if let Some(local_var_param_value) = chat_unique_name {
        local_var_form_params.insert("ChatUniqueName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("CustomerFriendlyName", customer_friendly_name.to_string());
    local_var_form_params.insert("FlexFlowSid", flex_flow_sid.to_string());
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = pre_engagement_data {
        local_var_form_params.insert("PreEngagementData", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateWebChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateWebChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_channel(configuration: &configuration::Configuration, params: DeleteChannelParams) -> Result<ResponseContent<DeleteChannelSuccess>, Error<DeleteChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Channels/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_flex_flow(configuration: &configuration::Configuration, params: DeleteFlexFlowParams) -> Result<ResponseContent<DeleteFlexFlowSuccess>, Error<DeleteFlexFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/FlexFlows/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteFlexFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteFlexFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_web_channel(configuration: &configuration::Configuration, params: DeleteWebChannelParams) -> Result<ResponseContent<DeleteWebChannelSuccess>, Error<DeleteWebChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/WebChannels/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteWebChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteWebChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_channel(configuration: &configuration::Configuration, params: FetchChannelParams) -> Result<ResponseContent<FetchChannelSuccess>, Error<FetchChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Channels/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_configuration(configuration: &configuration::Configuration, params: FetchConfigurationParams) -> Result<ResponseContent<FetchConfigurationSuccess>, Error<FetchConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ui_version = params.ui_version;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Configuration", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = ui_version {
        local_var_req_builder = local_var_req_builder.query(&[("UiVersion", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_flex_flow(configuration: &configuration::Configuration, params: FetchFlexFlowParams) -> Result<ResponseContent<FetchFlexFlowSuccess>, Error<FetchFlexFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/FlexFlows/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFlexFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFlexFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_web_channel(configuration: &configuration::Configuration, params: FetchWebChannelParams) -> Result<ResponseContent<FetchWebChannelSuccess>, Error<FetchWebChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/WebChannels/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWebChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWebChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_channel(configuration: &configuration::Configuration, params: ListChannelParams) -> Result<ResponseContent<ListChannelSuccess>, Error<ListChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Channels", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_flex_flow(configuration: &configuration::Configuration, params: ListFlexFlowParams) -> Result<ResponseContent<ListFlexFlowSuccess>, Error<ListFlexFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/FlexFlows", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFlexFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFlexFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_web_channel(configuration: &configuration::Configuration, params: ListWebChannelParams) -> Result<ResponseContent<ListWebChannelSuccess>, Error<ListWebChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/WebChannels", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListWebChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListWebChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_flex_flow(configuration: &configuration::Configuration, params: UpdateFlexFlowParams) -> Result<ResponseContent<UpdateFlexFlowSuccess>, Error<UpdateFlexFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let channel_type = params.channel_type;
    let chat_service_sid = params.chat_service_sid;
    let contact_identity = params.contact_identity;
    let enabled = params.enabled;
    let friendly_name = params.friendly_name;
    let integration_channel = params.integration_channel;
    let integration_creation_on_message = params.integration_creation_on_message;
    let integration_flow_sid = params.integration_flow_sid;
    let integration_priority = params.integration_priority;
    let integration_retry_count = params.integration_retry_count;
    let integration_timeout = params.integration_timeout;
    let integration_url = params.integration_url;
    let integration_workflow_sid = params.integration_workflow_sid;
    let integration_workspace_sid = params.integration_workspace_sid;
    let integration_type = params.integration_type;
    let janitor_enabled = params.janitor_enabled;
    let long_lived = params.long_lived;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/FlexFlows/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel_type {
        local_var_form_params.insert("ChannelType", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = chat_service_sid {
        local_var_form_params.insert("ChatServiceSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = contact_identity {
        local_var_form_params.insert("ContactIdentity", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = enabled {
        local_var_form_params.insert("Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_channel {
        local_var_form_params.insert("Integration.Channel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_creation_on_message {
        local_var_form_params.insert("Integration.CreationOnMessage", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_flow_sid {
        local_var_form_params.insert("Integration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_priority {
        local_var_form_params.insert("Integration.Priority", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_retry_count {
        local_var_form_params.insert("Integration.RetryCount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_timeout {
        local_var_form_params.insert("Integration.Timeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_url {
        local_var_form_params.insert("Integration.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_workflow_sid {
        local_var_form_params.insert("Integration.WorkflowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_workspace_sid {
        local_var_form_params.insert("Integration.WorkspaceSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = integration_type {
        local_var_form_params.insert("IntegrationType", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = janitor_enabled {
        local_var_form_params.insert("JanitorEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = long_lived {
        local_var_form_params.insert("LongLived", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateFlexFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateFlexFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_web_channel(configuration: &configuration::Configuration, params: UpdateWebChannelParams) -> Result<ResponseContent<UpdateWebChannelSuccess>, Error<UpdateWebChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let chat_status = params.chat_status;
    let post_engagement_data = params.post_engagement_data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/WebChannels/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = chat_status {
        local_var_form_params.insert("ChatStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = post_engagement_data {
        local_var_form_params.insert("PostEngagementData", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateWebChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateWebChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

