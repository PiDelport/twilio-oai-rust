/*
 * Twilio - Ip_messaging
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_channel`
#[derive(Clone, Debug, Default)]
pub struct CreateChannelParams {
    pub service_sid: String,
    pub attributes: Option<String>,
    pub friendly_name: Option<String>,
    pub _type: Option<String>,
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `create_credential`
#[derive(Clone, Debug, Default)]
pub struct CreateCredentialParams {
    pub _type: String,
    pub api_key: Option<String>,
    pub certificate: Option<String>,
    pub friendly_name: Option<String>,
    pub private_key: Option<String>,
    pub sandbox: Option<bool>,
    pub secret: Option<String>
}

/// struct for passing parameters to the method `create_invite`
#[derive(Clone, Debug, Default)]
pub struct CreateInviteParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub identity: String,
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method `create_member`
#[derive(Clone, Debug, Default)]
pub struct CreateMemberParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub identity: String,
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method `create_message`
#[derive(Clone, Debug, Default)]
pub struct CreateMessageParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub body: String,
    pub attributes: Option<String>,
    pub from: Option<String>
}

/// struct for passing parameters to the method `create_role`
#[derive(Clone, Debug, Default)]
pub struct CreateRoleParams {
    pub service_sid: String,
    pub friendly_name: String,
    pub permission: Vec<String>,
    pub _type: String
}

/// struct for passing parameters to the method `create_service`
#[derive(Clone, Debug, Default)]
pub struct CreateServiceParams {
    pub friendly_name: String
}

/// struct for passing parameters to the method `create_user`
#[derive(Clone, Debug, Default)]
pub struct CreateUserParams {
    pub service_sid: String,
    pub identity: String,
    pub attributes: Option<String>,
    pub friendly_name: Option<String>,
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method `delete_channel`
#[derive(Clone, Debug, Default)]
pub struct DeleteChannelParams {
    pub service_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `delete_credential`
#[derive(Clone, Debug, Default)]
pub struct DeleteCredentialParams {
    pub sid: String
}

/// struct for passing parameters to the method `delete_invite`
#[derive(Clone, Debug, Default)]
pub struct DeleteInviteParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `delete_member`
#[derive(Clone, Debug, Default)]
pub struct DeleteMemberParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `delete_message`
#[derive(Clone, Debug, Default)]
pub struct DeleteMessageParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `delete_role`
#[derive(Clone, Debug, Default)]
pub struct DeleteRoleParams {
    pub service_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `delete_service`
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    pub sid: String
}

/// struct for passing parameters to the method `delete_user`
#[derive(Clone, Debug, Default)]
pub struct DeleteUserParams {
    pub service_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `fetch_channel`
#[derive(Clone, Debug, Default)]
pub struct FetchChannelParams {
    pub service_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `fetch_credential`
#[derive(Clone, Debug, Default)]
pub struct FetchCredentialParams {
    pub sid: String
}

/// struct for passing parameters to the method `fetch_invite`
#[derive(Clone, Debug, Default)]
pub struct FetchInviteParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `fetch_member`
#[derive(Clone, Debug, Default)]
pub struct FetchMemberParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `fetch_message`
#[derive(Clone, Debug, Default)]
pub struct FetchMessageParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `fetch_role`
#[derive(Clone, Debug, Default)]
pub struct FetchRoleParams {
    pub service_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `fetch_service`
#[derive(Clone, Debug, Default)]
pub struct FetchServiceParams {
    pub sid: String
}

/// struct for passing parameters to the method `fetch_user`
#[derive(Clone, Debug, Default)]
pub struct FetchUserParams {
    pub service_sid: String,
    pub sid: String
}

/// struct for passing parameters to the method `list_channel`
#[derive(Clone, Debug, Default)]
pub struct ListChannelParams {
    pub service_sid: String,
    pub _type: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_credential`
#[derive(Clone, Debug, Default)]
pub struct ListCredentialParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_invite`
#[derive(Clone, Debug, Default)]
pub struct ListInviteParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_member`
#[derive(Clone, Debug, Default)]
pub struct ListMemberParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_message`
#[derive(Clone, Debug, Default)]
pub struct ListMessageParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub order: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_role`
#[derive(Clone, Debug, Default)]
pub struct ListRoleParams {
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_service`
#[derive(Clone, Debug, Default)]
pub struct ListServiceParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_user`
#[derive(Clone, Debug, Default)]
pub struct ListUserParams {
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_user_channel`
#[derive(Clone, Debug, Default)]
pub struct ListUserChannelParams {
    pub service_sid: String,
    pub user_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_channel`
#[derive(Clone, Debug, Default)]
pub struct UpdateChannelParams {
    pub service_sid: String,
    pub sid: String,
    pub attributes: Option<String>,
    pub friendly_name: Option<String>,
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `update_credential`
#[derive(Clone, Debug, Default)]
pub struct UpdateCredentialParams {
    pub sid: String,
    pub api_key: Option<String>,
    pub certificate: Option<String>,
    pub friendly_name: Option<String>,
    pub private_key: Option<String>,
    pub sandbox: Option<bool>,
    pub secret: Option<String>
}

/// struct for passing parameters to the method `update_member`
#[derive(Clone, Debug, Default)]
pub struct UpdateMemberParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
    pub last_consumed_message_index: Option<i32>,
    pub role_sid: Option<String>
}

/// struct for passing parameters to the method `update_message`
#[derive(Clone, Debug, Default)]
pub struct UpdateMessageParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
    pub attributes: Option<String>,
    pub body: Option<String>
}

/// struct for passing parameters to the method `update_role`
#[derive(Clone, Debug, Default)]
pub struct UpdateRoleParams {
    pub service_sid: String,
    pub sid: String,
    pub permission: Vec<String>
}

/// struct for passing parameters to the method `update_service`
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceParams {
    pub sid: String,
    pub consumption_report_interval: Option<i32>,
    pub default_channel_creator_role_sid: Option<String>,
    pub default_channel_role_sid: Option<String>,
    pub default_service_role_sid: Option<String>,
    pub friendly_name: Option<String>,
    pub limits_channel_members: Option<i32>,
    pub limits_user_channels: Option<i32>,
    pub notifications_added_to_channel_enabled: Option<bool>,
    pub notifications_added_to_channel_template: Option<String>,
    pub notifications_invited_to_channel_enabled: Option<bool>,
    pub notifications_invited_to_channel_template: Option<String>,
    pub notifications_new_message_enabled: Option<bool>,
    pub notifications_new_message_template: Option<String>,
    pub notifications_removed_from_channel_enabled: Option<bool>,
    pub notifications_removed_from_channel_template: Option<String>,
    pub post_webhook_url: Option<String>,
    pub pre_webhook_url: Option<String>,
    pub reachability_enabled: Option<bool>,
    pub read_status_enabled: Option<bool>,
    pub typing_indicator_timeout: Option<i32>,
    pub webhook_filters: Option<Vec<String>>,
    pub webhook_method: Option<String>,
    pub webhooks_on_channel_add_method: Option<String>,
    pub webhooks_on_channel_add_url: Option<String>,
    pub webhooks_on_channel_added_method: Option<String>,
    pub webhooks_on_channel_added_url: Option<String>,
    pub webhooks_on_channel_destroy_method: Option<String>,
    pub webhooks_on_channel_destroy_url: Option<String>,
    pub webhooks_on_channel_destroyed_method: Option<String>,
    pub webhooks_on_channel_destroyed_url: Option<String>,
    pub webhooks_on_channel_update_method: Option<String>,
    pub webhooks_on_channel_update_url: Option<String>,
    pub webhooks_on_channel_updated_method: Option<String>,
    pub webhooks_on_channel_updated_url: Option<String>,
    pub webhooks_on_member_add_method: Option<String>,
    pub webhooks_on_member_add_url: Option<String>,
    pub webhooks_on_member_added_method: Option<String>,
    pub webhooks_on_member_added_url: Option<String>,
    pub webhooks_on_member_remove_method: Option<String>,
    pub webhooks_on_member_remove_url: Option<String>,
    pub webhooks_on_member_removed_method: Option<String>,
    pub webhooks_on_member_removed_url: Option<String>,
    pub webhooks_on_message_remove_method: Option<String>,
    pub webhooks_on_message_remove_url: Option<String>,
    pub webhooks_on_message_removed_method: Option<String>,
    pub webhooks_on_message_removed_url: Option<String>,
    pub webhooks_on_message_send_method: Option<String>,
    pub webhooks_on_message_send_url: Option<String>,
    pub webhooks_on_message_sent_method: Option<String>,
    pub webhooks_on_message_sent_url: Option<String>,
    pub webhooks_on_message_update_method: Option<String>,
    pub webhooks_on_message_update_url: Option<String>,
    pub webhooks_on_message_updated_method: Option<String>,
    pub webhooks_on_message_updated_url: Option<String>
}

/// struct for passing parameters to the method `update_user`
#[derive(Clone, Debug, Default)]
pub struct UpdateUserParams {
    pub service_sid: String,
    pub sid: String,
    pub attributes: Option<String>,
    pub friendly_name: Option<String>,
    pub role_sid: Option<String>
}


/// struct for typed successes of method `create_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelSuccess {
    Status201(crate::models::IpMessagingV1ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialSuccess {
    Status201(crate::models::IpMessagingV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInviteSuccess {
    Status201(crate::models::IpMessagingV1ServiceChannelInvite),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMemberSuccess {
    Status201(crate::models::IpMessagingV1ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageSuccess {
    Status201(crate::models::IpMessagingV1ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleSuccess {
    Status201(crate::models::IpMessagingV1ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceSuccess {
    Status201(crate::models::IpMessagingV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserSuccess {
    Status201(crate::models::IpMessagingV1ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInviteSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMemberSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelSuccess {
    Status200(crate::models::IpMessagingV1ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialSuccess {
    Status200(crate::models::IpMessagingV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInviteSuccess {
    Status200(crate::models::IpMessagingV1ServiceChannelInvite),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMemberSuccess {
    Status200(crate::models::IpMessagingV1ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessageSuccess {
    Status200(crate::models::IpMessagingV1ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoleSuccess {
    Status200(crate::models::IpMessagingV1ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceSuccess {
    Status200(crate::models::IpMessagingV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserSuccess {
    Status200(crate::models::IpMessagingV1ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelSuccess {
    Status200(crate::models::ListChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialSuccess {
    Status200(crate::models::ListCredentialResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInviteSuccess {
    Status200(crate::models::ListInviteResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMemberSuccess {
    Status200(crate::models::ListMemberResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessageSuccess {
    Status200(crate::models::ListMessageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoleSuccess {
    Status200(crate::models::ListRoleResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceSuccess {
    Status200(crate::models::ListServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserSuccess {
    Status200(crate::models::ListUserResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_user_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserChannelSuccess {
    Status200(crate::models::ListUserChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelSuccess {
    Status200(crate::models::IpMessagingV1ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialSuccess {
    Status200(crate::models::IpMessagingV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMemberSuccess {
    Status200(crate::models::IpMessagingV1ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageSuccess {
    Status200(crate::models::IpMessagingV1ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleSuccess {
    Status200(crate::models::IpMessagingV1ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceSuccess {
    Status200(crate::models::IpMessagingV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserSuccess {
    Status200(crate::models::IpMessagingV1ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_invite`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_user_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_credential`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_member`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_role`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserError {
    UnknownValue(serde_json::Value),
}


pub async fn create_channel(configuration: &configuration::Configuration, params: CreateChannelParams) -> Result<ResponseContent<CreateChannelSuccess>, Error<CreateChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let _type = params._type;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = _type {
        local_var_form_params.insert("Type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_credential(configuration: &configuration::Configuration, params: CreateCredentialParams) -> Result<ResponseContent<CreateCredentialSuccess>, Error<CreateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let _type = params._type;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_invite(configuration: &configuration::Configuration, params: CreateInviteParams) -> Result<ResponseContent<CreateInviteSuccess>, Error<CreateInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_member(configuration: &configuration::Configuration, params: CreateMemberParams) -> Result<ResponseContent<CreateMemberSuccess>, Error<CreateMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_message(configuration: &configuration::Configuration, params: CreateMessageParams) -> Result<ResponseContent<CreateMessageSuccess>, Error<CreateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let body = params.body;
    let attributes = params.attributes;
    let from = params.from;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Body", body.to_string());
    if let Some(local_var_param_value) = from {
        local_var_form_params.insert("From", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_role(configuration: &configuration::Configuration, params: CreateRoleParams) -> Result<ResponseContent<CreateRoleSuccess>, Error<CreateRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let friendly_name = params.friendly_name;
    let permission = params.permission;
    let _type = params._type;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Roles", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("Permission", permission.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_service(configuration: &configuration::Configuration, params: CreateServiceParams) -> Result<ResponseContent<CreateServiceSuccess>, Error<CreateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_user(configuration: &configuration::Configuration, params: CreateUserParams) -> Result<ResponseContent<CreateUserSuccess>, Error<CreateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_channel(configuration: &configuration::Configuration, params: DeleteChannelParams) -> Result<ResponseContent<DeleteChannelSuccess>, Error<DeleteChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_credential(configuration: &configuration::Configuration, params: DeleteCredentialParams) -> Result<ResponseContent<DeleteCredentialSuccess>, Error<DeleteCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_invite(configuration: &configuration::Configuration, params: DeleteInviteParams) -> Result<ResponseContent<DeleteInviteSuccess>, Error<DeleteInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_member(configuration: &configuration::Configuration, params: DeleteMemberParams) -> Result<ResponseContent<DeleteMemberSuccess>, Error<DeleteMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_message(configuration: &configuration::Configuration, params: DeleteMessageParams) -> Result<ResponseContent<DeleteMessageSuccess>, Error<DeleteMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_role(configuration: &configuration::Configuration, params: DeleteRoleParams) -> Result<ResponseContent<DeleteRoleSuccess>, Error<DeleteRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<ResponseContent<DeleteServiceSuccess>, Error<DeleteServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_user(configuration: &configuration::Configuration, params: DeleteUserParams) -> Result<ResponseContent<DeleteUserSuccess>, Error<DeleteUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_channel(configuration: &configuration::Configuration, params: FetchChannelParams) -> Result<ResponseContent<FetchChannelSuccess>, Error<FetchChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_credential(configuration: &configuration::Configuration, params: FetchCredentialParams) -> Result<ResponseContent<FetchCredentialSuccess>, Error<FetchCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_invite(configuration: &configuration::Configuration, params: FetchInviteParams) -> Result<ResponseContent<FetchInviteSuccess>, Error<FetchInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_member(configuration: &configuration::Configuration, params: FetchMemberParams) -> Result<ResponseContent<FetchMemberSuccess>, Error<FetchMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_message(configuration: &configuration::Configuration, params: FetchMessageParams) -> Result<ResponseContent<FetchMessageSuccess>, Error<FetchMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_role(configuration: &configuration::Configuration, params: FetchRoleParams) -> Result<ResponseContent<FetchRoleSuccess>, Error<FetchRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_service(configuration: &configuration::Configuration, params: FetchServiceParams) -> Result<ResponseContent<FetchServiceSuccess>, Error<FetchServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user(configuration: &configuration::Configuration, params: FetchUserParams) -> Result<ResponseContent<FetchUserSuccess>, Error<FetchUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_channel(configuration: &configuration::Configuration, params: ListChannelParams) -> Result<ResponseContent<ListChannelSuccess>, Error<ListChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let _type = params._type;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = _type {
        local_var_req_builder = local_var_req_builder.query(&[("Type", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_credential(configuration: &configuration::Configuration, params: ListCredentialParams) -> Result<ResponseContent<ListCredentialSuccess>, Error<ListCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_invite(configuration: &configuration::Configuration, params: ListInviteParams) -> Result<ResponseContent<ListInviteSuccess>, Error<ListInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListInviteSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_member(configuration: &configuration::Configuration, params: ListMemberParams) -> Result<ResponseContent<ListMemberSuccess>, Error<ListMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_message(configuration: &configuration::Configuration, params: ListMessageParams) -> Result<ResponseContent<ListMessageSuccess>, Error<ListMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let order = params.order;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_role(configuration: &configuration::Configuration, params: ListRoleParams) -> Result<ResponseContent<ListRoleSuccess>, Error<ListRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Roles", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_service(configuration: &configuration::Configuration, params: ListServiceParams) -> Result<ResponseContent<ListServiceSuccess>, Error<ListServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_user(configuration: &configuration::Configuration, params: ListUserParams) -> Result<ResponseContent<ListUserSuccess>, Error<ListUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_user_channel(configuration: &configuration::Configuration, params: ListUserChannelParams) -> Result<ResponseContent<ListUserChannelSuccess>, Error<ListUserChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users/{UserSid}/Channels", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), UserSid=crate::apis::urlencode(user_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_channel(configuration: &configuration::Configuration, params: UpdateChannelParams) -> Result<ResponseContent<UpdateChannelSuccess>, Error<UpdateChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_credential(configuration: &configuration::Configuration, params: UpdateCredentialParams) -> Result<ResponseContent<UpdateCredentialSuccess>, Error<UpdateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_member(configuration: &configuration::Configuration, params: UpdateMemberParams) -> Result<ResponseContent<UpdateMemberSuccess>, Error<UpdateMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let last_consumed_message_index = params.last_consumed_message_index;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = last_consumed_message_index {
        local_var_form_params.insert("LastConsumedMessageIndex", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMemberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_message(configuration: &configuration::Configuration, params: UpdateMessageParams) -> Result<ResponseContent<UpdateMessageSuccess>, Error<UpdateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let attributes = params.attributes;
    let body = params.body;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ChannelSid=crate::apis::urlencode(channel_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_role(configuration: &configuration::Configuration, params: UpdateRoleParams) -> Result<ResponseContent<UpdateRoleSuccess>, Error<UpdateRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let permission = params.permission;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Roles/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Permission", permission.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRoleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_service(configuration: &configuration::Configuration, params: UpdateServiceParams) -> Result<ResponseContent<UpdateServiceSuccess>, Error<UpdateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let consumption_report_interval = params.consumption_report_interval;
    let default_channel_creator_role_sid = params.default_channel_creator_role_sid;
    let default_channel_role_sid = params.default_channel_role_sid;
    let default_service_role_sid = params.default_service_role_sid;
    let friendly_name = params.friendly_name;
    let limits_channel_members = params.limits_channel_members;
    let limits_user_channels = params.limits_user_channels;
    let notifications_added_to_channel_enabled = params.notifications_added_to_channel_enabled;
    let notifications_added_to_channel_template = params.notifications_added_to_channel_template;
    let notifications_invited_to_channel_enabled = params.notifications_invited_to_channel_enabled;
    let notifications_invited_to_channel_template = params.notifications_invited_to_channel_template;
    let notifications_new_message_enabled = params.notifications_new_message_enabled;
    let notifications_new_message_template = params.notifications_new_message_template;
    let notifications_removed_from_channel_enabled = params.notifications_removed_from_channel_enabled;
    let notifications_removed_from_channel_template = params.notifications_removed_from_channel_template;
    let post_webhook_url = params.post_webhook_url;
    let pre_webhook_url = params.pre_webhook_url;
    let reachability_enabled = params.reachability_enabled;
    let read_status_enabled = params.read_status_enabled;
    let typing_indicator_timeout = params.typing_indicator_timeout;
    let webhook_filters = params.webhook_filters;
    let webhook_method = params.webhook_method;
    let webhooks_on_channel_add_method = params.webhooks_on_channel_add_method;
    let webhooks_on_channel_add_url = params.webhooks_on_channel_add_url;
    let webhooks_on_channel_added_method = params.webhooks_on_channel_added_method;
    let webhooks_on_channel_added_url = params.webhooks_on_channel_added_url;
    let webhooks_on_channel_destroy_method = params.webhooks_on_channel_destroy_method;
    let webhooks_on_channel_destroy_url = params.webhooks_on_channel_destroy_url;
    let webhooks_on_channel_destroyed_method = params.webhooks_on_channel_destroyed_method;
    let webhooks_on_channel_destroyed_url = params.webhooks_on_channel_destroyed_url;
    let webhooks_on_channel_update_method = params.webhooks_on_channel_update_method;
    let webhooks_on_channel_update_url = params.webhooks_on_channel_update_url;
    let webhooks_on_channel_updated_method = params.webhooks_on_channel_updated_method;
    let webhooks_on_channel_updated_url = params.webhooks_on_channel_updated_url;
    let webhooks_on_member_add_method = params.webhooks_on_member_add_method;
    let webhooks_on_member_add_url = params.webhooks_on_member_add_url;
    let webhooks_on_member_added_method = params.webhooks_on_member_added_method;
    let webhooks_on_member_added_url = params.webhooks_on_member_added_url;
    let webhooks_on_member_remove_method = params.webhooks_on_member_remove_method;
    let webhooks_on_member_remove_url = params.webhooks_on_member_remove_url;
    let webhooks_on_member_removed_method = params.webhooks_on_member_removed_method;
    let webhooks_on_member_removed_url = params.webhooks_on_member_removed_url;
    let webhooks_on_message_remove_method = params.webhooks_on_message_remove_method;
    let webhooks_on_message_remove_url = params.webhooks_on_message_remove_url;
    let webhooks_on_message_removed_method = params.webhooks_on_message_removed_method;
    let webhooks_on_message_removed_url = params.webhooks_on_message_removed_url;
    let webhooks_on_message_send_method = params.webhooks_on_message_send_method;
    let webhooks_on_message_send_url = params.webhooks_on_message_send_url;
    let webhooks_on_message_sent_method = params.webhooks_on_message_sent_method;
    let webhooks_on_message_sent_url = params.webhooks_on_message_sent_url;
    let webhooks_on_message_update_method = params.webhooks_on_message_update_method;
    let webhooks_on_message_update_url = params.webhooks_on_message_update_url;
    let webhooks_on_message_updated_method = params.webhooks_on_message_updated_method;
    let webhooks_on_message_updated_url = params.webhooks_on_message_updated_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = consumption_report_interval {
        local_var_form_params.insert("ConsumptionReportInterval", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_channel_creator_role_sid {
        local_var_form_params.insert("DefaultChannelCreatorRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_channel_role_sid {
        local_var_form_params.insert("DefaultChannelRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_service_role_sid {
        local_var_form_params.insert("DefaultServiceRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = limits_channel_members {
        local_var_form_params.insert("Limits.ChannelMembers", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = limits_user_channels {
        local_var_form_params.insert("Limits.UserChannels", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_added_to_channel_enabled {
        local_var_form_params.insert("Notifications.AddedToChannel.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_added_to_channel_template {
        local_var_form_params.insert("Notifications.AddedToChannel.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_invited_to_channel_enabled {
        local_var_form_params.insert("Notifications.InvitedToChannel.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_invited_to_channel_template {
        local_var_form_params.insert("Notifications.InvitedToChannel.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_new_message_enabled {
        local_var_form_params.insert("Notifications.NewMessage.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_new_message_template {
        local_var_form_params.insert("Notifications.NewMessage.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_removed_from_channel_enabled {
        local_var_form_params.insert("Notifications.RemovedFromChannel.Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = notifications_removed_from_channel_template {
        local_var_form_params.insert("Notifications.RemovedFromChannel.Template", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = post_webhook_url {
        local_var_form_params.insert("PostWebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = pre_webhook_url {
        local_var_form_params.insert("PreWebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_enabled {
        local_var_form_params.insert("ReachabilityEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = read_status_enabled {
        local_var_form_params.insert("ReadStatusEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = typing_indicator_timeout {
        local_var_form_params.insert("TypingIndicatorTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_filters {
        local_var_form_params.insert("WebhookFilters", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = webhook_method {
        local_var_form_params.insert("WebhookMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_add_method {
        local_var_form_params.insert("Webhooks.OnChannelAdd.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_add_url {
        local_var_form_params.insert("Webhooks.OnChannelAdd.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_added_method {
        local_var_form_params.insert("Webhooks.OnChannelAdded.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_added_url {
        local_var_form_params.insert("Webhooks.OnChannelAdded.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_destroy_method {
        local_var_form_params.insert("Webhooks.OnChannelDestroy.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_destroy_url {
        local_var_form_params.insert("Webhooks.OnChannelDestroy.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_destroyed_method {
        local_var_form_params.insert("Webhooks.OnChannelDestroyed.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_destroyed_url {
        local_var_form_params.insert("Webhooks.OnChannelDestroyed.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_update_method {
        local_var_form_params.insert("Webhooks.OnChannelUpdate.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_update_url {
        local_var_form_params.insert("Webhooks.OnChannelUpdate.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_updated_method {
        local_var_form_params.insert("Webhooks.OnChannelUpdated.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_channel_updated_url {
        local_var_form_params.insert("Webhooks.OnChannelUpdated.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_add_method {
        local_var_form_params.insert("Webhooks.OnMemberAdd.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_add_url {
        local_var_form_params.insert("Webhooks.OnMemberAdd.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_added_method {
        local_var_form_params.insert("Webhooks.OnMemberAdded.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_added_url {
        local_var_form_params.insert("Webhooks.OnMemberAdded.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_remove_method {
        local_var_form_params.insert("Webhooks.OnMemberRemove.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_remove_url {
        local_var_form_params.insert("Webhooks.OnMemberRemove.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_removed_method {
        local_var_form_params.insert("Webhooks.OnMemberRemoved.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_member_removed_url {
        local_var_form_params.insert("Webhooks.OnMemberRemoved.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_remove_method {
        local_var_form_params.insert("Webhooks.OnMessageRemove.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_remove_url {
        local_var_form_params.insert("Webhooks.OnMessageRemove.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_removed_method {
        local_var_form_params.insert("Webhooks.OnMessageRemoved.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_removed_url {
        local_var_form_params.insert("Webhooks.OnMessageRemoved.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_send_method {
        local_var_form_params.insert("Webhooks.OnMessageSend.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_send_url {
        local_var_form_params.insert("Webhooks.OnMessageSend.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_sent_method {
        local_var_form_params.insert("Webhooks.OnMessageSent.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_sent_url {
        local_var_form_params.insert("Webhooks.OnMessageSent.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_update_method {
        local_var_form_params.insert("Webhooks.OnMessageUpdate.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_update_url {
        local_var_form_params.insert("Webhooks.OnMessageUpdate.Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_updated_method {
        local_var_form_params.insert("Webhooks.OnMessageUpdated.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_on_message_updated_url {
        local_var_form_params.insert("Webhooks.OnMessageUpdated.Url", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_user(configuration: &configuration::Configuration, params: UpdateUserParams) -> Result<ResponseContent<UpdateUserSuccess>, Error<UpdateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Users/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

