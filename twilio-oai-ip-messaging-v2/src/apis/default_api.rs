/*
 * Twilio - Ip_messaging
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method [`create_channel`]
#[derive(Clone, Debug, Default)]
pub struct CreateChannelParams {
    pub service_sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    pub attributes: Option<String>,
    pub created_by: Option<String>,
    pub date_created: Option<String>,
    pub date_updated: Option<String>,
    pub friendly_name: Option<String>,
    pub _type: Option<String>,
    pub unique_name: Option<String>,
}

/// struct for passing parameters to the method [`create_channel_webhook`]
#[derive(Clone, Debug, Default)]
pub struct CreateChannelWebhookParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub _type: String,
    pub configuration_filters: Option<Vec<String>>,
    pub configuration_flow_sid: Option<String>,
    pub configuration_method: Option<String>,
    pub configuration_retry_count: Option<i32>,
    pub configuration_triggers: Option<Vec<String>>,
    pub configuration_url: Option<String>,
}

/// struct for passing parameters to the method [`create_credential`]
#[derive(Clone, Debug, Default)]
pub struct CreateCredentialParams {
    pub _type: String,
    pub api_key: Option<String>,
    pub certificate: Option<String>,
    pub friendly_name: Option<String>,
    pub private_key: Option<String>,
    pub sandbox: Option<bool>,
    pub secret: Option<String>,
}

/// struct for passing parameters to the method [`create_invite`]
#[derive(Clone, Debug, Default)]
pub struct CreateInviteParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub identity: String,
    pub role_sid: Option<String>,
}

/// struct for passing parameters to the method [`create_member`]
#[derive(Clone, Debug, Default)]
pub struct CreateMemberParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub identity: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    pub attributes: Option<String>,
    pub date_created: Option<String>,
    pub date_updated: Option<String>,
    pub last_consumed_message_index: Option<i32>,
    pub last_consumption_timestamp: Option<String>,
    pub role_sid: Option<String>,
}

/// struct for passing parameters to the method [`create_message`]
#[derive(Clone, Debug, Default)]
pub struct CreateMessageParams {
    pub service_sid: String,
    pub channel_sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    pub attributes: Option<String>,
    pub body: Option<String>,
    pub date_created: Option<String>,
    pub date_updated: Option<String>,
    pub from: Option<String>,
    pub last_updated_by: Option<String>,
    pub media_sid: Option<String>,
}

/// struct for passing parameters to the method [`create_role`]
#[derive(Clone, Debug, Default)]
pub struct CreateRoleParams {
    pub service_sid: String,
    pub friendly_name: String,
    pub permission: Vec<String>,
    pub _type: String,
}

/// struct for passing parameters to the method [`create_service`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceParams {
    pub friendly_name: String,
}

/// struct for passing parameters to the method [`create_user`]
#[derive(Clone, Debug, Default)]
pub struct CreateUserParams {
    pub service_sid: String,
    pub identity: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    pub attributes: Option<String>,
    pub friendly_name: Option<String>,
    pub role_sid: Option<String>,
}

/// struct for passing parameters to the method [`delete_binding`]
#[derive(Clone, Debug, Default)]
pub struct DeleteBindingParams {
    pub service_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_channel`]
#[derive(Clone, Debug, Default)]
pub struct DeleteChannelParams {
    pub service_sid: String,
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
}

/// struct for passing parameters to the method [`delete_channel_webhook`]
#[derive(Clone, Debug, Default)]
pub struct DeleteChannelWebhookParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_credential`]
#[derive(Clone, Debug, Default)]
pub struct DeleteCredentialParams {
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_invite`]
#[derive(Clone, Debug, Default)]
pub struct DeleteInviteParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_member`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMemberParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
}

/// struct for passing parameters to the method [`delete_message`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMessageParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
}

/// struct for passing parameters to the method [`delete_role`]
#[derive(Clone, Debug, Default)]
pub struct DeleteRoleParams {
    pub service_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_service`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_user`]
#[derive(Clone, Debug, Default)]
pub struct DeleteUserParams {
    pub service_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_user_binding`]
#[derive(Clone, Debug, Default)]
pub struct DeleteUserBindingParams {
    pub service_sid: String,
    pub user_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_user_channel`]
#[derive(Clone, Debug, Default)]
pub struct DeleteUserChannelParams {
    pub service_sid: String,
    pub user_sid: String,
    pub channel_sid: String,
}

/// struct for passing parameters to the method [`fetch_binding`]
#[derive(Clone, Debug, Default)]
pub struct FetchBindingParams {
    pub service_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_channel`]
#[derive(Clone, Debug, Default)]
pub struct FetchChannelParams {
    pub service_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_channel_webhook`]
#[derive(Clone, Debug, Default)]
pub struct FetchChannelWebhookParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_credential`]
#[derive(Clone, Debug, Default)]
pub struct FetchCredentialParams {
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_invite`]
#[derive(Clone, Debug, Default)]
pub struct FetchInviteParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_member`]
#[derive(Clone, Debug, Default)]
pub struct FetchMemberParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_message`]
#[derive(Clone, Debug, Default)]
pub struct FetchMessageParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_role`]
#[derive(Clone, Debug, Default)]
pub struct FetchRoleParams {
    pub service_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_service`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceParams {
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_user`]
#[derive(Clone, Debug, Default)]
pub struct FetchUserParams {
    pub service_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_user_binding`]
#[derive(Clone, Debug, Default)]
pub struct FetchUserBindingParams {
    pub service_sid: String,
    pub user_sid: String,
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_user_channel`]
#[derive(Clone, Debug, Default)]
pub struct FetchUserChannelParams {
    pub service_sid: String,
    pub user_sid: String,
    pub channel_sid: String,
}

/// struct for passing parameters to the method [`list_binding`]
#[derive(Clone, Debug, Default)]
pub struct ListBindingParams {
    pub service_sid: String,
    pub binding_type: Option<Vec<String>>,
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_channel`]
#[derive(Clone, Debug, Default)]
pub struct ListChannelParams {
    pub service_sid: String,
    pub _type: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_channel_webhook`]
#[derive(Clone, Debug, Default)]
pub struct ListChannelWebhookParams {
    pub service_sid: String,
    pub channel_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_credential`]
#[derive(Clone, Debug, Default)]
pub struct ListCredentialParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_invite`]
#[derive(Clone, Debug, Default)]
pub struct ListInviteParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_member`]
#[derive(Clone, Debug, Default)]
pub struct ListMemberParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub identity: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_message`]
#[derive(Clone, Debug, Default)]
pub struct ListMessageParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub order: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_role`]
#[derive(Clone, Debug, Default)]
pub struct ListRoleParams {
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_service`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_user`]
#[derive(Clone, Debug, Default)]
pub struct ListUserParams {
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_user_binding`]
#[derive(Clone, Debug, Default)]
pub struct ListUserBindingParams {
    pub service_sid: String,
    pub user_sid: String,
    pub binding_type: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_user_channel`]
#[derive(Clone, Debug, Default)]
pub struct ListUserChannelParams {
    pub service_sid: String,
    pub user_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`update_channel`]
#[derive(Clone, Debug, Default)]
pub struct UpdateChannelParams {
    pub service_sid: String,
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    pub attributes: Option<String>,
    pub created_by: Option<String>,
    pub date_created: Option<String>,
    pub date_updated: Option<String>,
    pub friendly_name: Option<String>,
    pub unique_name: Option<String>,
}

/// struct for passing parameters to the method [`update_channel_webhook`]
#[derive(Clone, Debug, Default)]
pub struct UpdateChannelWebhookParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
    pub configuration_filters: Option<Vec<String>>,
    pub configuration_flow_sid: Option<String>,
    pub configuration_method: Option<String>,
    pub configuration_retry_count: Option<i32>,
    pub configuration_triggers: Option<Vec<String>>,
    pub configuration_url: Option<String>,
}

/// struct for passing parameters to the method [`update_credential`]
#[derive(Clone, Debug, Default)]
pub struct UpdateCredentialParams {
    pub sid: String,
    pub api_key: Option<String>,
    pub certificate: Option<String>,
    pub friendly_name: Option<String>,
    pub private_key: Option<String>,
    pub sandbox: Option<bool>,
    pub secret: Option<String>,
}

/// struct for passing parameters to the method [`update_member`]
#[derive(Clone, Debug, Default)]
pub struct UpdateMemberParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    pub attributes: Option<String>,
    pub date_created: Option<String>,
    pub date_updated: Option<String>,
    pub last_consumed_message_index: Option<i32>,
    pub last_consumption_timestamp: Option<String>,
    pub role_sid: Option<String>,
}

/// struct for passing parameters to the method [`update_message`]
#[derive(Clone, Debug, Default)]
pub struct UpdateMessageParams {
    pub service_sid: String,
    pub channel_sid: String,
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    pub attributes: Option<String>,
    pub body: Option<String>,
    pub date_created: Option<String>,
    pub date_updated: Option<String>,
    pub from: Option<String>,
    pub last_updated_by: Option<String>,
}

/// struct for passing parameters to the method [`update_role`]
#[derive(Clone, Debug, Default)]
pub struct UpdateRoleParams {
    pub service_sid: String,
    pub sid: String,
    pub permission: Vec<String>,
}

/// struct for passing parameters to the method [`update_service`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceParams {
    pub sid: String,
    pub consumption_report_interval: Option<i32>,
    pub default_channel_creator_role_sid: Option<String>,
    pub default_channel_role_sid: Option<String>,
    pub default_service_role_sid: Option<String>,
    pub friendly_name: Option<String>,
    pub limits_channel_members: Option<i32>,
    pub limits_user_channels: Option<i32>,
    pub media_compatibility_message: Option<String>,
    pub notifications_added_to_channel_enabled: Option<bool>,
    pub notifications_added_to_channel_sound: Option<String>,
    pub notifications_added_to_channel_template: Option<String>,
    pub notifications_invited_to_channel_enabled: Option<bool>,
    pub notifications_invited_to_channel_sound: Option<String>,
    pub notifications_invited_to_channel_template: Option<String>,
    pub notifications_log_enabled: Option<bool>,
    pub notifications_new_message_badge_count_enabled: Option<bool>,
    pub notifications_new_message_enabled: Option<bool>,
    pub notifications_new_message_sound: Option<String>,
    pub notifications_new_message_template: Option<String>,
    pub notifications_removed_from_channel_enabled: Option<bool>,
    pub notifications_removed_from_channel_sound: Option<String>,
    pub notifications_removed_from_channel_template: Option<String>,
    pub post_webhook_retry_count: Option<i32>,
    pub post_webhook_url: Option<String>,
    pub pre_webhook_retry_count: Option<i32>,
    pub pre_webhook_url: Option<String>,
    pub reachability_enabled: Option<bool>,
    pub read_status_enabled: Option<bool>,
    pub typing_indicator_timeout: Option<i32>,
    pub webhook_filters: Option<Vec<String>>,
    pub webhook_method: Option<String>,
}

/// struct for passing parameters to the method [`update_user`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserParams {
    pub service_sid: String,
    pub sid: String,
    /// The X-Twilio-Webhook-Enabled HTTP request header
    pub x_twilio_webhook_enabled: Option<String>,
    pub attributes: Option<String>,
    pub friendly_name: Option<String>,
    pub role_sid: Option<String>,
}

/// struct for passing parameters to the method [`update_user_channel`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserChannelParams {
    pub service_sid: String,
    pub user_sid: String,
    pub channel_sid: String,
    pub last_consumed_message_index: Option<i32>,
    pub last_consumption_timestamp: Option<String>,
    pub notification_level: Option<String>,
}

/// struct for typed successes of method [`create_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelSuccess {
    Status201(crate::models::IpMessagingV2ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_channel_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelWebhookSuccess {
    Status201(crate::models::IpMessagingV2ServiceChannelChannelWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialSuccess {
    Status201(crate::models::IpMessagingV2Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInviteSuccess {
    Status201(crate::models::IpMessagingV2ServiceChannelInvite),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMemberSuccess {
    Status201(crate::models::IpMessagingV2ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageSuccess {
    Status201(crate::models::IpMessagingV2ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleSuccess {
    Status201(crate::models::IpMessagingV2ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceSuccess {
    Status201(crate::models::IpMessagingV2Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserSuccess {
    Status201(crate::models::IpMessagingV2ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBindingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_channel_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelWebhookSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInviteSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMemberSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_user_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserBindingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_user_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBindingSuccess {
    Status200(crate::models::IpMessagingV2ServiceBinding),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelSuccess {
    Status200(crate::models::IpMessagingV2ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_channel_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelWebhookSuccess {
    Status200(crate::models::IpMessagingV2ServiceChannelChannelWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialSuccess {
    Status200(crate::models::IpMessagingV2Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInviteSuccess {
    Status200(crate::models::IpMessagingV2ServiceChannelInvite),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMemberSuccess {
    Status200(crate::models::IpMessagingV2ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessageSuccess {
    Status200(crate::models::IpMessagingV2ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoleSuccess {
    Status200(crate::models::IpMessagingV2ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceSuccess {
    Status200(crate::models::IpMessagingV2Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserSuccess {
    Status200(crate::models::IpMessagingV2ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_user_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserBindingSuccess {
    Status200(crate::models::IpMessagingV2ServiceUserUserBinding),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_user_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserChannelSuccess {
    Status200(crate::models::IpMessagingV2ServiceUserUserChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBindingSuccess {
    Status200(crate::models::ListBindingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelSuccess {
    Status200(crate::models::ListChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_channel_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelWebhookSuccess {
    Status200(crate::models::ListChannelWebhookResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialSuccess {
    Status200(crate::models::ListCredentialResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInviteSuccess {
    Status200(crate::models::ListInviteResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMemberSuccess {
    Status200(crate::models::ListMemberResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessageSuccess {
    Status200(crate::models::ListMessageResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoleSuccess {
    Status200(crate::models::ListRoleResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceSuccess {
    Status200(crate::models::ListServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserSuccess {
    Status200(crate::models::ListUserResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_user_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserBindingSuccess {
    Status200(crate::models::ListUserBindingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_user_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserChannelSuccess {
    Status200(crate::models::ListUserChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelSuccess {
    Status200(crate::models::IpMessagingV2ServiceChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_channel_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelWebhookSuccess {
    Status200(crate::models::IpMessagingV2ServiceChannelChannelWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialSuccess {
    Status200(crate::models::IpMessagingV2Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMemberSuccess {
    Status200(crate::models::IpMessagingV2ServiceChannelMember),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageSuccess {
    Status200(crate::models::IpMessagingV2ServiceChannelMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleSuccess {
    Status200(crate::models::IpMessagingV2ServiceRole),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceSuccess {
    Status200(crate::models::IpMessagingV2Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserSuccess {
    Status200(crate::models::IpMessagingV2ServiceUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_user_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserChannelSuccess {
    Status200(crate::models::IpMessagingV2ServiceUserUserChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_channel_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChannelWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_channel_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_channel_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChannelWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_channel_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_user_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_user_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUserChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_channel_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserChannelError {
    UnknownValue(serde_json::Value),
}

pub async fn create_channel(
    configuration: &configuration::Configuration,
    params: CreateChannelParams,
) -> Result<ResponseContent<CreateChannelSuccess>, Error<CreateChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let created_by = params.created_by;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let friendly_name = params.friendly_name;
    let _type = params._type;
    let unique_name = params.unique_name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = created_by {
        local_var_form_params.insert("CreatedBy", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = _type {
        local_var_form_params.insert("Type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_channel_webhook(
    configuration: &configuration::Configuration,
    params: CreateChannelWebhookParams,
) -> Result<ResponseContent<CreateChannelWebhookSuccess>, Error<CreateChannelWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let _type = params._type;
    let configuration_filters = params.configuration_filters;
    let configuration_flow_sid = params.configuration_flow_sid;
    let configuration_method = params.configuration_method;
    let configuration_retry_count = params.configuration_retry_count;
    let configuration_triggers = params.configuration_triggers;
    let configuration_url = params.configuration_url;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = configuration_filters {
        local_var_form_params.insert(
            "Configuration.Filters",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = configuration_flow_sid {
        local_var_form_params.insert("Configuration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_method {
        local_var_form_params.insert("Configuration.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_retry_count {
        local_var_form_params.insert(
            "Configuration.RetryCount",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = configuration_triggers {
        local_var_form_params.insert(
            "Configuration.Triggers",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = configuration_url {
        local_var_form_params.insert("Configuration.Url", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateChannelWebhookSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateChannelWebhookError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_credential(
    configuration: &configuration::Configuration,
    params: CreateCredentialParams,
) -> Result<ResponseContent<CreateCredentialSuccess>, Error<CreateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let _type = params._type;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCredentialSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCredentialError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_invite(
    configuration: &configuration::Configuration,
    params: CreateInviteParams,
) -> Result<ResponseContent<CreateInviteSuccess>, Error<CreateInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let role_sid = params.role_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateInviteSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateInviteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_member(
    configuration: &configuration::Configuration,
    params: CreateMemberParams,
) -> Result<ResponseContent<CreateMemberSuccess>, Error<CreateMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let last_consumed_message_index = params.last_consumed_message_index;
    let last_consumption_timestamp = params.last_consumption_timestamp;
    let role_sid = params.role_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = last_consumed_message_index {
        local_var_form_params.insert(
            "LastConsumedMessageIndex",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = last_consumption_timestamp {
        local_var_form_params.insert(
            "LastConsumptionTimestamp",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMemberSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMemberError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_message(
    configuration: &configuration::Configuration,
    params: CreateMessageParams,
) -> Result<ResponseContent<CreateMessageSuccess>, Error<CreateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let body = params.body;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let from = params.from;
    let last_updated_by = params.last_updated_by;
    let media_sid = params.media_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = from {
        local_var_form_params.insert("From", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_updated_by {
        local_var_form_params.insert("LastUpdatedBy", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = media_sid {
        local_var_form_params.insert("MediaSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMessageSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_role(
    configuration: &configuration::Configuration,
    params: CreateRoleParams,
) -> Result<ResponseContent<CreateRoleSuccess>, Error<CreateRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let friendly_name = params.friendly_name;
    let permission = params.permission;
    let _type = params._type;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Roles",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert(
        "Permission",
        permission
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
    );
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRoleSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRoleError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_service(
    configuration: &configuration::Configuration,
    params: CreateServiceParams,
) -> Result<ResponseContent<CreateServiceSuccess>, Error<CreateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_user(
    configuration: &configuration::Configuration,
    params: CreateUserParams,
) -> Result<ResponseContent<CreateUserSuccess>, Error<CreateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateUserSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_binding(
    configuration: &configuration::Configuration,
    params: DeleteBindingParams,
) -> Result<ResponseContent<DeleteBindingSuccess>, Error<DeleteBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Bindings/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteBindingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteBindingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_channel(
    configuration: &configuration::Configuration,
    params: DeleteChannelParams,
) -> Result<ResponseContent<DeleteChannelSuccess>, Error<DeleteChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_channel_webhook(
    configuration: &configuration::Configuration,
    params: DeleteChannelWebhookParams,
) -> Result<ResponseContent<DeleteChannelWebhookSuccess>, Error<DeleteChannelWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteChannelWebhookSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteChannelWebhookError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_credential(
    configuration: &configuration::Configuration,
    params: DeleteCredentialParams,
) -> Result<ResponseContent<DeleteCredentialSuccess>, Error<DeleteCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Credentials/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCredentialSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCredentialError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_invite(
    configuration: &configuration::Configuration,
    params: DeleteInviteParams,
) -> Result<ResponseContent<DeleteInviteSuccess>, Error<DeleteInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteInviteSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteInviteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_member(
    configuration: &configuration::Configuration,
    params: DeleteMemberParams,
) -> Result<ResponseContent<DeleteMemberSuccess>, Error<DeleteMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMemberSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMemberError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_message(
    configuration: &configuration::Configuration,
    params: DeleteMessageParams,
) -> Result<ResponseContent<DeleteMessageSuccess>, Error<DeleteMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMessageSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_role(
    configuration: &configuration::Configuration,
    params: DeleteRoleParams,
) -> Result<ResponseContent<DeleteRoleSuccess>, Error<DeleteRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Roles/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRoleSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRoleError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_service(
    configuration: &configuration::Configuration,
    params: DeleteServiceParams,
) -> Result<ResponseContent<DeleteServiceSuccess>, Error<DeleteServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_user(
    configuration: &configuration::Configuration,
    params: DeleteUserParams,
) -> Result<ResponseContent<DeleteUserSuccess>, Error<DeleteUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUserSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_user_binding(
    configuration: &configuration::Configuration,
    params: DeleteUserBindingParams,
) -> Result<ResponseContent<DeleteUserBindingSuccess>, Error<DeleteUserBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users/{UserSid}/Bindings/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        UserSid = crate::apis::urlencode(user_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUserBindingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUserBindingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_user_channel(
    configuration: &configuration::Configuration,
    params: DeleteUserChannelParams,
) -> Result<ResponseContent<DeleteUserChannelSuccess>, Error<DeleteUserChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let channel_sid = params.channel_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        UserSid = crate::apis::urlencode(user_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteUserChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteUserChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_binding(
    configuration: &configuration::Configuration,
    params: FetchBindingParams,
) -> Result<ResponseContent<FetchBindingSuccess>, Error<FetchBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Bindings/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchBindingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchBindingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_channel(
    configuration: &configuration::Configuration,
    params: FetchChannelParams,
) -> Result<ResponseContent<FetchChannelSuccess>, Error<FetchChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_channel_webhook(
    configuration: &configuration::Configuration,
    params: FetchChannelWebhookParams,
) -> Result<ResponseContent<FetchChannelWebhookSuccess>, Error<FetchChannelWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchChannelWebhookSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchChannelWebhookError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_credential(
    configuration: &configuration::Configuration,
    params: FetchCredentialParams,
) -> Result<ResponseContent<FetchCredentialSuccess>, Error<FetchCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Credentials/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCredentialSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCredentialError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_invite(
    configuration: &configuration::Configuration,
    params: FetchInviteParams,
) -> Result<ResponseContent<FetchInviteSuccess>, Error<FetchInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchInviteSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchInviteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_member(
    configuration: &configuration::Configuration,
    params: FetchMemberParams,
) -> Result<ResponseContent<FetchMemberSuccess>, Error<FetchMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMemberSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMemberError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_message(
    configuration: &configuration::Configuration,
    params: FetchMessageParams,
) -> Result<ResponseContent<FetchMessageSuccess>, Error<FetchMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMessageSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_role(
    configuration: &configuration::Configuration,
    params: FetchRoleParams,
) -> Result<ResponseContent<FetchRoleSuccess>, Error<FetchRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Roles/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoleSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoleError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_service(
    configuration: &configuration::Configuration,
    params: FetchServiceParams,
) -> Result<ResponseContent<FetchServiceSuccess>, Error<FetchServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user(
    configuration: &configuration::Configuration,
    params: FetchUserParams,
) -> Result<ResponseContent<FetchUserSuccess>, Error<FetchUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUserSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user_binding(
    configuration: &configuration::Configuration,
    params: FetchUserBindingParams,
) -> Result<ResponseContent<FetchUserBindingSuccess>, Error<FetchUserBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users/{UserSid}/Bindings/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        UserSid = crate::apis::urlencode(user_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUserBindingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUserBindingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user_channel(
    configuration: &configuration::Configuration,
    params: FetchUserChannelParams,
) -> Result<ResponseContent<FetchUserChannelSuccess>, Error<FetchUserChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let channel_sid = params.channel_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        UserSid = crate::apis::urlencode(user_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchUserChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchUserChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_binding(
    configuration: &configuration::Configuration,
    params: ListBindingParams,
) -> Result<ResponseContent<ListBindingSuccess>, Error<ListBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let binding_type = params.binding_type;
    let identity = params.identity;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Bindings",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = binding_type {
        local_var_req_builder = local_var_req_builder.query(&[(
            "BindingType",
            &local_var_str
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]);
    }
    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[(
            "Identity",
            &local_var_str
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListBindingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListBindingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_channel(
    configuration: &configuration::Configuration,
    params: ListChannelParams,
) -> Result<ResponseContent<ListChannelSuccess>, Error<ListChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let _type = params._type;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = _type {
        local_var_req_builder = local_var_req_builder.query(&[(
            "Type",
            &local_var_str
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_channel_webhook(
    configuration: &configuration::Configuration,
    params: ListChannelWebhookParams,
) -> Result<ResponseContent<ListChannelWebhookSuccess>, Error<ListChannelWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListChannelWebhookSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListChannelWebhookError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_credential(
    configuration: &configuration::Configuration,
    params: ListCredentialParams,
) -> Result<ResponseContent<ListCredentialSuccess>, Error<ListCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCredentialSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCredentialError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_invite(
    configuration: &configuration::Configuration,
    params: ListInviteParams,
) -> Result<ResponseContent<ListInviteSuccess>, Error<ListInviteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[(
            "Identity",
            &local_var_str
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListInviteSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListInviteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_member(
    configuration: &configuration::Configuration,
    params: ListMemberParams,
) -> Result<ResponseContent<ListMemberSuccess>, Error<ListMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let identity = params.identity;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[(
            "Identity",
            &local_var_str
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMemberSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMemberError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_message(
    configuration: &configuration::Configuration,
    params: ListMessageParams,
) -> Result<ResponseContent<ListMessageSuccess>, Error<ListMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let order = params.order;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder =
            local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMessageSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_role(
    configuration: &configuration::Configuration,
    params: ListRoleParams,
) -> Result<ResponseContent<ListRoleSuccess>, Error<ListRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Roles",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRoleSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_service(
    configuration: &configuration::Configuration,
    params: ListServiceParams,
) -> Result<ResponseContent<ListServiceSuccess>, Error<ListServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_user(
    configuration: &configuration::Configuration,
    params: ListUserParams,
) -> Result<ResponseContent<ListUserSuccess>, Error<ListUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_user_binding(
    configuration: &configuration::Configuration,
    params: ListUserBindingParams,
) -> Result<ResponseContent<ListUserBindingSuccess>, Error<ListUserBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let binding_type = params.binding_type;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users/{UserSid}/Bindings",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        UserSid = crate::apis::urlencode(user_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = binding_type {
        local_var_req_builder = local_var_req_builder.query(&[(
            "BindingType",
            &local_var_str
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserBindingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserBindingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_user_channel(
    configuration: &configuration::Configuration,
    params: ListUserChannelParams,
) -> Result<ResponseContent<ListUserChannelSuccess>, Error<ListUserChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users/{UserSid}/Channels",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        UserSid = crate::apis::urlencode(user_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUserChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUserChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_channel(
    configuration: &configuration::Configuration,
    params: UpdateChannelParams,
) -> Result<ResponseContent<UpdateChannelSuccess>, Error<UpdateChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let created_by = params.created_by;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let friendly_name = params.friendly_name;
    let unique_name = params.unique_name;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = created_by {
        local_var_form_params.insert("CreatedBy", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_channel_webhook(
    configuration: &configuration::Configuration,
    params: UpdateChannelWebhookParams,
) -> Result<ResponseContent<UpdateChannelWebhookSuccess>, Error<UpdateChannelWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let configuration_filters = params.configuration_filters;
    let configuration_flow_sid = params.configuration_flow_sid;
    let configuration_method = params.configuration_method;
    let configuration_retry_count = params.configuration_retry_count;
    let configuration_triggers = params.configuration_triggers;
    let configuration_url = params.configuration_url;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = configuration_filters {
        local_var_form_params.insert(
            "Configuration.Filters",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = configuration_flow_sid {
        local_var_form_params.insert("Configuration.FlowSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_method {
        local_var_form_params.insert("Configuration.Method", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration_retry_count {
        local_var_form_params.insert(
            "Configuration.RetryCount",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = configuration_triggers {
        local_var_form_params.insert(
            "Configuration.Triggers",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = configuration_url {
        local_var_form_params.insert("Configuration.Url", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateChannelWebhookSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateChannelWebhookError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_credential(
    configuration: &configuration::Configuration,
    params: UpdateCredentialParams,
) -> Result<ResponseContent<UpdateCredentialSuccess>, Error<UpdateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Credentials/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateCredentialSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateCredentialError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_member(
    configuration: &configuration::Configuration,
    params: UpdateMemberParams,
) -> Result<ResponseContent<UpdateMemberSuccess>, Error<UpdateMemberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let last_consumed_message_index = params.last_consumed_message_index;
    let last_consumption_timestamp = params.last_consumption_timestamp;
    let role_sid = params.role_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_consumed_message_index {
        local_var_form_params.insert(
            "LastConsumedMessageIndex",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = last_consumption_timestamp {
        local_var_form_params.insert(
            "LastConsumptionTimestamp",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMemberSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMemberError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_message(
    configuration: &configuration::Configuration,
    params: UpdateMessageParams,
) -> Result<ResponseContent<UpdateMessageSuccess>, Error<UpdateMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel_sid = params.channel_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let body = params.body;
    let date_created = params.date_created;
    let date_updated = params.date_updated;
    let from = params.from;
    let last_updated_by = params.last_updated_by;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        ChannelSid = crate::apis::urlencode(channel_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_created {
        local_var_form_params.insert("DateCreated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = date_updated {
        local_var_form_params.insert("DateUpdated", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = from {
        local_var_form_params.insert("From", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = last_updated_by {
        local_var_form_params.insert("LastUpdatedBy", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMessageSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMessageError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_role(
    configuration: &configuration::Configuration,
    params: UpdateRoleParams,
) -> Result<ResponseContent<UpdateRoleSuccess>, Error<UpdateRoleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let permission = params.permission;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Roles/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert(
        "Permission",
        permission
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<String>>()
            .join(",")
            .to_string(),
    );
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRoleSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRoleError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_service(
    configuration: &configuration::Configuration,
    params: UpdateServiceParams,
) -> Result<ResponseContent<UpdateServiceSuccess>, Error<UpdateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let consumption_report_interval = params.consumption_report_interval;
    let default_channel_creator_role_sid = params.default_channel_creator_role_sid;
    let default_channel_role_sid = params.default_channel_role_sid;
    let default_service_role_sid = params.default_service_role_sid;
    let friendly_name = params.friendly_name;
    let limits_channel_members = params.limits_channel_members;
    let limits_user_channels = params.limits_user_channels;
    let media_compatibility_message = params.media_compatibility_message;
    let notifications_added_to_channel_enabled = params.notifications_added_to_channel_enabled;
    let notifications_added_to_channel_sound = params.notifications_added_to_channel_sound;
    let notifications_added_to_channel_template = params.notifications_added_to_channel_template;
    let notifications_invited_to_channel_enabled = params.notifications_invited_to_channel_enabled;
    let notifications_invited_to_channel_sound = params.notifications_invited_to_channel_sound;
    let notifications_invited_to_channel_template =
        params.notifications_invited_to_channel_template;
    let notifications_log_enabled = params.notifications_log_enabled;
    let notifications_new_message_badge_count_enabled =
        params.notifications_new_message_badge_count_enabled;
    let notifications_new_message_enabled = params.notifications_new_message_enabled;
    let notifications_new_message_sound = params.notifications_new_message_sound;
    let notifications_new_message_template = params.notifications_new_message_template;
    let notifications_removed_from_channel_enabled =
        params.notifications_removed_from_channel_enabled;
    let notifications_removed_from_channel_sound = params.notifications_removed_from_channel_sound;
    let notifications_removed_from_channel_template =
        params.notifications_removed_from_channel_template;
    let post_webhook_retry_count = params.post_webhook_retry_count;
    let post_webhook_url = params.post_webhook_url;
    let pre_webhook_retry_count = params.pre_webhook_retry_count;
    let pre_webhook_url = params.pre_webhook_url;
    let reachability_enabled = params.reachability_enabled;
    let read_status_enabled = params.read_status_enabled;
    let typing_indicator_timeout = params.typing_indicator_timeout;
    let webhook_filters = params.webhook_filters;
    let webhook_method = params.webhook_method;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = consumption_report_interval {
        local_var_form_params.insert(
            "ConsumptionReportInterval",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = default_channel_creator_role_sid {
        local_var_form_params.insert(
            "DefaultChannelCreatorRoleSid",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = default_channel_role_sid {
        local_var_form_params.insert("DefaultChannelRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_service_role_sid {
        local_var_form_params.insert("DefaultServiceRoleSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = limits_channel_members {
        local_var_form_params.insert("Limits.ChannelMembers", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = limits_user_channels {
        local_var_form_params.insert("Limits.UserChannels", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = media_compatibility_message {
        local_var_form_params.insert(
            "Media.CompatibilityMessage",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_added_to_channel_enabled {
        local_var_form_params.insert(
            "Notifications.AddedToChannel.Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_added_to_channel_sound {
        local_var_form_params.insert(
            "Notifications.AddedToChannel.Sound",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_added_to_channel_template {
        local_var_form_params.insert(
            "Notifications.AddedToChannel.Template",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_invited_to_channel_enabled {
        local_var_form_params.insert(
            "Notifications.InvitedToChannel.Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_invited_to_channel_sound {
        local_var_form_params.insert(
            "Notifications.InvitedToChannel.Sound",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_invited_to_channel_template {
        local_var_form_params.insert(
            "Notifications.InvitedToChannel.Template",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_log_enabled {
        local_var_form_params.insert(
            "Notifications.LogEnabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_new_message_badge_count_enabled {
        local_var_form_params.insert(
            "Notifications.NewMessage.BadgeCountEnabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_new_message_enabled {
        local_var_form_params.insert(
            "Notifications.NewMessage.Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_new_message_sound {
        local_var_form_params.insert(
            "Notifications.NewMessage.Sound",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_new_message_template {
        local_var_form_params.insert(
            "Notifications.NewMessage.Template",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_removed_from_channel_enabled {
        local_var_form_params.insert(
            "Notifications.RemovedFromChannel.Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_removed_from_channel_sound {
        local_var_form_params.insert(
            "Notifications.RemovedFromChannel.Sound",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notifications_removed_from_channel_template {
        local_var_form_params.insert(
            "Notifications.RemovedFromChannel.Template",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = post_webhook_retry_count {
        local_var_form_params.insert("PostWebhookRetryCount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = post_webhook_url {
        local_var_form_params.insert("PostWebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = pre_webhook_retry_count {
        local_var_form_params.insert("PreWebhookRetryCount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = pre_webhook_url {
        local_var_form_params.insert("PreWebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_enabled {
        local_var_form_params.insert("ReachabilityEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = read_status_enabled {
        local_var_form_params.insert("ReadStatusEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = typing_indicator_timeout {
        local_var_form_params.insert("TypingIndicatorTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_filters {
        local_var_form_params.insert(
            "WebhookFilters",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = webhook_method {
        local_var_form_params.insert("WebhookMethod", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_user(
    configuration: &configuration::Configuration,
    params: UpdateUserParams,
) -> Result<ResponseContent<UpdateUserSuccess>, Error<UpdateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let x_twilio_webhook_enabled = params.x_twilio_webhook_enabled;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let role_sid = params.role_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users/{Sid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_twilio_webhook_enabled {
        local_var_req_builder = local_var_req_builder.header(
            "X-Twilio-Webhook-Enabled",
            local_var_param_value.to_string(),
        );
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = role_sid {
        local_var_form_params.insert("RoleSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateUserSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_user_channel(
    configuration: &configuration::Configuration,
    params: UpdateUserChannelParams,
) -> Result<ResponseContent<UpdateUserChannelSuccess>, Error<UpdateUserChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let user_sid = params.user_sid;
    let channel_sid = params.channel_sid;
    let last_consumed_message_index = params.last_consumed_message_index;
    let last_consumption_timestamp = params.last_consumption_timestamp;
    let notification_level = params.notification_level;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}",
        local_var_configuration.base_path,
        ServiceSid = crate::apis::urlencode(service_sid),
        UserSid = crate::apis::urlencode(user_sid),
        ChannelSid = crate::apis::urlencode(channel_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = last_consumed_message_index {
        local_var_form_params.insert(
            "LastConsumedMessageIndex",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = last_consumption_timestamp {
        local_var_form_params.insert(
            "LastConsumptionTimestamp",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = notification_level {
        local_var_form_params.insert("NotificationLevel", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateUserChannelSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateUserChannelError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
