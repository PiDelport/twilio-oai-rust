/*
 * Twilio - Notify
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_binding`]
#[derive(Clone, Debug, Default)]
pub struct CreateBindingParams {
    /// The SID of the [Service](https://www.twilio.com/docs/notify/api/service-resource) to create the resource under.
    pub service_sid: String,
    /// The channel-specific address. For APNS, the device token. For FCM and GCM, the registration token. For SMS, a phone number in E.164 format. For Facebook Messenger, the Messenger ID of the user or a phone number in E.164 format.
    pub address: String,
    /// The transport technology to use for the Binding. Can be: `apn`, `fcm`, `gcm`, `sms`, or `facebook-messenger`.
    pub binding_type: String,
    /// The `identity` value that uniquely identifies the new resource's [User](https://www.twilio.com/docs/chat/rest/user-resource) within the [Service](https://www.twilio.com/docs/notify/api/service-resource). Up to 20 Bindings can be created for the same Identity in a given Service.
    pub identity: String,
    /// The SID of the [Credential](https://www.twilio.com/docs/notify/api/credential-resource) resource to be used to send notifications to this Binding. If present, this overrides the Credential specified in the Service resource. Applies to only `apn`, `fcm`, and `gcm` type Bindings.
    pub credential_sid: Option<String>,
    /// Deprecated.
    pub endpoint: Option<String>,
    /// The protocol version to use to send the notification. This defaults to the value of `default_xxxx_notification_protocol_version` for the protocol in the [Service](https://www.twilio.com/docs/notify/api/service-resource). The current version is `\\\"3\\\"` for `apn`, `fcm`, and `gcm` type Bindings. The parameter is not applicable to `sms` and `facebook-messenger` type Bindings as the data format is fixed.
    pub notification_protocol_version: Option<String>,
    /// A tag that can be used to select the Bindings to notify. Repeat this parameter to specify more than one tag, up to a total of 20 tags.
    pub tag: Option<Vec<String>>
}

/// struct for passing parameters to the method [`create_credential`]
#[derive(Clone, Debug, Default)]
pub struct CreateCredentialParams {
    /// The Credential type. Can be: `gcm`, `fcm`, or `apn`.
    pub _type: String,
    /// [GCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging.
    pub api_key: Option<String>,
    /// [APN only] The URL-encoded representation of the certificate. Strip everything outside of the headers, e.g. `-----BEGIN CERTIFICATE-----MIIFnTCCBIWgAwIBAgIIAjy9H849+E8wDQYJKoZIhvcNAQEFBQAwgZYxCzAJBgNV.....A==-----END CERTIFICATE-----`
    pub certificate: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// [APN only] The URL-encoded representation of the private key. Strip everything outside of the headers, e.g. `-----BEGIN RSA PRIVATE KEY-----MIIEpQIBAAKCAQEAuyf/lNrH9ck8DmNyo3fGgvCI1l9s+cmBY3WIz+cUDqmxiieR\\\\n.-----END RSA PRIVATE KEY-----`
    pub private_key: Option<String>,
    /// [APN only] Whether to send the credential to sandbox APNs. Can be `true` to send to sandbox APNs or `false` to send to production.
    pub sandbox: Option<bool>,
    /// [FCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging.
    pub secret: Option<String>
}

/// struct for passing parameters to the method [`create_notification`]
#[derive(Clone, Debug, Default)]
pub struct CreateNotificationParams {
    /// The SID of the [Service](https://www.twilio.com/docs/notify/api/service-resource) to create the resource under.
    pub service_sid: String,
    /// The actions to display for the notification. For APNS, translates to the `aps.category` value. For GCM, translates to the `data.twi_action` value. For SMS, this parameter is not supported and is omitted from deliveries to those channels.
    pub action: Option<String>,
    /// Deprecated.
    pub alexa: Option<serde_json::Value>,
    /// The APNS-specific payload that overrides corresponding attributes in the generic payload for APNS Bindings. This property maps to the APNS `Payload` item, therefore the `aps` key must be used to change standard attributes. Adds custom key-value pairs to the root of the dictionary. See the [APNS documentation](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html) for more details. We reserve keys that start with `twi_` for future use. Custom keys that start with `twi_` are not allowed.
    pub apn: Option<serde_json::Value>,
    /// The notification text. For FCM and GCM, translates to `data.twi_body`. For APNS, translates to `aps.alert.body`. For SMS, translates to `body`. SMS requires either this `body` value, or `media_urls` attribute defined in the `sms` parameter of the notification.
    pub body: Option<String>,
    /// The custom key-value pairs of the notification's payload. For FCM and GCM, this value translates to `data` in the FCM and GCM payloads. FCM and GCM [reserve certain keys](https://firebase.google.com/docs/cloud-messaging/http-server-ref) that cannot be used in those channels. For APNS, attributes of `data` are inserted into the APNS payload as custom properties outside of the `aps` dictionary. In all channels, we reserve keys that start with `twi_` for future use. Custom keys that start with `twi_` are not allowed and are rejected as 400 Bad request with no delivery attempted. For SMS, this parameter is not supported and is omitted from deliveries to those channels.
    pub data: Option<serde_json::Value>,
    /// URL to send webhooks.
    pub delivery_callback_url: Option<String>,
    /// Deprecated.
    pub facebook_messenger: Option<serde_json::Value>,
    /// The FCM-specific payload that overrides corresponding attributes in the generic payload for FCM Bindings. This property maps to the root JSON dictionary. See the [FCM documentation](https://firebase.google.com/docs/cloud-messaging/http-server-ref#downstream) for more details. Target parameters `to`, `registration_ids`, `condition`, and `notification_key` are not allowed in this parameter. We reserve keys that start with `twi_` for future use. Custom keys that start with `twi_` are not allowed. FCM also [reserves certain keys](https://firebase.google.com/docs/cloud-messaging/http-server-ref), which cannot be used in that channel.
    pub fcm: Option<serde_json::Value>,
    /// The GCM-specific payload that overrides corresponding attributes in the generic payload for GCM Bindings.  This property maps to the root JSON dictionary. See the [GCM documentation](https://firebase.google.com/docs/cloud-messaging/http-server-ref) for more details. Target parameters `to`, `registration_ids`, and `notification_key` are not allowed. We reserve keys that start with `twi_` for future use. Custom keys that start with `twi_` are not allowed. GCM also [reserves certain keys](https://firebase.google.com/docs/cloud-messaging/http-server-ref).
    pub gcm: Option<serde_json::Value>,
    /// The `identity` value that uniquely identifies the new resource's [User](https://www.twilio.com/docs/chat/rest/user-resource) within the [Service](https://www.twilio.com/docs/notify/api/service-resource). Delivery will be attempted only to Bindings with an Identity in this list. No more than 20 items are allowed in this list.
    pub identity: Option<Vec<String>>,
    /// The priority of the notification. Can be: `low` or `high` and the default is `high`. A value of `low` optimizes the client app's battery consumption; however, notifications may be delivered with unspecified delay. For FCM and GCM, `low` priority is the same as `Normal` priority. For APNS `low` priority is the same as `5`. A value of `high` sends the notification immediately, and can wake up a sleeping device. For FCM and GCM, `high` is the same as `High` priority. For APNS, `high` is a priority `10`. SMS does not support this property.
    pub priority: Option<String>,
    /// The Segment resource is deprecated. Use the `tag` parameter, instead.
    pub segment: Option<Vec<String>>,
    /// The SMS-specific payload that overrides corresponding attributes in the generic payload for SMS Bindings.  Each attribute in this value maps to the corresponding `form` parameter of the Twilio [Message](https://www.twilio.com/docs/sms/send-messages) resource.  These parameters of the Message resource are supported in snake case format: `body`, `media_urls`, `status_callback`, and `max_price`.  The `status_callback` parameter overrides the corresponding parameter in the messaging service, if configured. The `media_urls` property expects a JSON array.
    pub sms: Option<serde_json::Value>,
    /// The name of the sound to be played for the notification. For FCM and GCM, this Translates to `data.twi_sound`.  For APNS, this translates to `aps.sound`.  SMS does not support this property.
    pub sound: Option<String>,
    /// A tag that selects the Bindings to notify. Repeat this parameter to specify more than one tag, up to a total of 5 tags. The implicit tag `all` is available to notify all Bindings in a Service instance. Similarly, the implicit tags `apn`, `fcm`, `gcm`, `sms` and `facebook-messenger` are available to notify all Bindings in a specific channel.
    pub tag: Option<Vec<String>>,
    /// The notification title. For FCM and GCM, this translates to the `data.twi_title` value. For APNS, this translates to the `aps.alert.title` value. SMS does not support this property. This field is not visible on iOS phones and tablets but appears on Apple Watch and Android devices.
    pub title: Option<String>,
    /// The destination address specified as a JSON string.  Multiple `to_binding` parameters can be included but the total size of the request entity should not exceed 1MB. This is typically sufficient for 10,000 phone numbers.
    pub to_binding: Option<Vec<String>>,
    /// How long, in seconds, the notification is valid. Can be an integer between 0 and 2,419,200, which is 4 weeks, the default and the maximum supported time to live (TTL). Delivery should be attempted if the device is offline until the TTL elapses. Zero means that the notification delivery is attempted immediately, only once, and is not stored for future delivery. SMS does not support this property.
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method [`create_service`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceParams {
    /// Deprecated.
    pub alexa_skill_id: Option<String>,
    /// The SID of the [Credential](https://www.twilio.com/docs/notify/api/credential-resource) to use for APN Bindings.
    pub apn_credential_sid: Option<String>,
    /// Deprecated.
    pub default_alexa_notification_protocol_version: Option<String>,
    /// The protocol version to use for sending APNS notifications. Can be overridden on a Binding by Binding basis when creating a [Binding](https://www.twilio.com/docs/notify/api/binding-resource) resource.
    pub default_apn_notification_protocol_version: Option<String>,
    /// The protocol version to use for sending FCM notifications. Can be overridden on a Binding by Binding basis when creating a [Binding](https://www.twilio.com/docs/notify/api/binding-resource) resource.
    pub default_fcm_notification_protocol_version: Option<String>,
    /// The protocol version to use for sending GCM notifications. Can be overridden on a Binding by Binding basis when creating a [Binding](https://www.twilio.com/docs/notify/api/binding-resource) resource.
    pub default_gcm_notification_protocol_version: Option<String>,
    /// Callback configuration that enables delivery callbacks, default false
    pub delivery_callback_enabled: Option<bool>,
    /// URL to send delivery status callback.
    pub delivery_callback_url: Option<String>,
    /// Deprecated.
    pub facebook_messenger_page_id: Option<String>,
    /// The SID of the [Credential](https://www.twilio.com/docs/notify/api/credential-resource) to use for FCM Bindings.
    pub fcm_credential_sid: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The SID of the [Credential](https://www.twilio.com/docs/notify/api/credential-resource) to use for GCM Bindings.
    pub gcm_credential_sid: Option<String>,
    /// Whether to log notifications. Can be: `true` or `false` and the default is `true`.
    pub log_enabled: Option<bool>,
    /// The SID of the [Messaging Service](https://www.twilio.com/docs/sms/send-messages#messaging-services) to use for SMS Bindings. This parameter must be set in order to send SMS notifications.
    pub messaging_service_sid: Option<String>
}

/// struct for passing parameters to the method [`delete_binding`]
#[derive(Clone, Debug, Default)]
pub struct DeleteBindingParams {
    /// The SID of the [Service](https://www.twilio.com/docs/notify/api/service-resource) to delete the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Binding resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_credential`]
#[derive(Clone, Debug, Default)]
pub struct DeleteCredentialParams {
    /// The Twilio-provided string that uniquely identifies the Credential resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_service`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    /// The Twilio-provided string that uniquely identifies the Service resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_binding`]
#[derive(Clone, Debug, Default)]
pub struct FetchBindingParams {
    /// The SID of the [Service](https://www.twilio.com/docs/notify/api/service-resource) to fetch the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Binding resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_credential`]
#[derive(Clone, Debug, Default)]
pub struct FetchCredentialParams {
    /// The Twilio-provided string that uniquely identifies the Credential resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceParams {
    /// The Twilio-provided string that uniquely identifies the Service resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`list_binding`]
#[derive(Clone, Debug, Default)]
pub struct ListBindingParams {
    /// The SID of the [Service](https://www.twilio.com/docs/notify/api/service-resource) to read the resource from.
    pub service_sid: String,
    /// Only include usage that has occurred on or after this date. Specify the date in GMT and format as `YYYY-MM-DD`.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date. Specify the date in GMT and format as `YYYY-MM-DD`.
    pub end_date: Option<String>,
    /// The [User](https://www.twilio.com/docs/chat/rest/user-resource)'s `identity` value of the resources to read.
    pub identity: Option<Vec<String>>,
    /// Only list Bindings that have all of the specified Tags. The following implicit tags are available: `all`, `apn`, `fcm`, `gcm`, `sms`, `facebook-messenger`. Up to 5 tags are allowed.
    pub tag: Option<Vec<String>>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_credential`]
#[derive(Clone, Debug, Default)]
pub struct ListCredentialParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceParams {
    /// The string that identifies the Service resources to read.
    pub friendly_name: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`update_credential`]
#[derive(Clone, Debug, Default)]
pub struct UpdateCredentialParams {
    /// The Twilio-provided string that uniquely identifies the Credential resource to update.
    pub sid: String,
    /// [GCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging.
    pub api_key: Option<String>,
    /// [APN only] The URL-encoded representation of the certificate. Strip everything outside of the headers, e.g. `-----BEGIN CERTIFICATE-----MIIFnTCCBIWgAwIBAgIIAjy9H849+E8wDQYJKoZIhvcNAQEFBQAwgZYxCzAJBgNV.....A==-----END CERTIFICATE-----`
    pub certificate: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// [APN only] The URL-encoded representation of the private key. Strip everything outside of the headers, e.g. `-----BEGIN RSA PRIVATE KEY-----MIIEpQIBAAKCAQEAuyf/lNrH9ck8DmNyo3fGgvCI1l9s+cmBY3WIz+cUDqmxiieR\\\\n.-----END RSA PRIVATE KEY-----`
    pub private_key: Option<String>,
    /// [APN only] Whether to send the credential to sandbox APNs. Can be `true` to send to sandbox APNs or `false` to send to production.
    pub sandbox: Option<bool>,
    /// [FCM only] The `Server key` of your project from Firebase console under Settings / Cloud messaging.
    pub secret: Option<String>
}

/// struct for passing parameters to the method [`update_service`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceParams {
    /// The Twilio-provided string that uniquely identifies the Service resource to update.
    pub sid: String,
    /// Deprecated.
    pub alexa_skill_id: Option<String>,
    /// The SID of the [Credential](https://www.twilio.com/docs/notify/api/credential-resource) to use for APN Bindings.
    pub apn_credential_sid: Option<String>,
    /// Deprecated.
    pub default_alexa_notification_protocol_version: Option<String>,
    /// The protocol version to use for sending APNS notifications. Can be overridden on a Binding by Binding basis when creating a [Binding](https://www.twilio.com/docs/notify/api/binding-resource) resource.
    pub default_apn_notification_protocol_version: Option<String>,
    /// The protocol version to use for sending FCM notifications. Can be overridden on a Binding by Binding basis when creating a [Binding](https://www.twilio.com/docs/notify/api/binding-resource) resource.
    pub default_fcm_notification_protocol_version: Option<String>,
    /// The protocol version to use for sending GCM notifications. Can be overridden on a Binding by Binding basis when creating a [Binding](https://www.twilio.com/docs/notify/api/binding-resource) resource.
    pub default_gcm_notification_protocol_version: Option<String>,
    /// Callback configuration that enables delivery callbacks, default false
    pub delivery_callback_enabled: Option<bool>,
    /// URL to send delivery status callback.
    pub delivery_callback_url: Option<String>,
    /// Deprecated.
    pub facebook_messenger_page_id: Option<String>,
    /// The SID of the [Credential](https://www.twilio.com/docs/notify/api/credential-resource) to use for FCM Bindings.
    pub fcm_credential_sid: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The SID of the [Credential](https://www.twilio.com/docs/notify/api/credential-resource) to use for GCM Bindings.
    pub gcm_credential_sid: Option<String>,
    /// Whether to log notifications. Can be: `true` or `false` and the default is `true`.
    pub log_enabled: Option<bool>,
    /// The SID of the [Messaging Service](https://www.twilio.com/docs/sms/send-messages#messaging-services) to use for SMS Bindings. This parameter must be set in order to send SMS notifications.
    pub messaging_service_sid: Option<String>
}


/// struct for typed successes of method [`create_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBindingSuccess {
    Status201(crate::models::NotifyV1ServiceBinding),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialSuccess {
    Status201(crate::models::NotifyV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNotificationSuccess {
    Status201(crate::models::NotifyV1ServiceNotification),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceSuccess {
    Status201(crate::models::NotifyV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBindingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBindingSuccess {
    Status200(crate::models::NotifyV1ServiceBinding),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialSuccess {
    Status200(crate::models::NotifyV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceSuccess {
    Status200(crate::models::NotifyV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBindingSuccess {
    Status200(crate::models::ListBindingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialSuccess {
    Status200(crate::models::ListCredentialResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceSuccess {
    Status200(crate::models::ListServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialSuccess {
    Status200(crate::models::NotifyV1Credential),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceSuccess {
    Status200(crate::models::NotifyV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_binding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBindingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}


pub async fn create_binding(configuration: &configuration::Configuration, params: CreateBindingParams) -> Result<ResponseContent<CreateBindingSuccess>, Error<CreateBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let address = params.address;
    let binding_type = params.binding_type;
    let identity = params.identity;
    let credential_sid = params.credential_sid;
    let endpoint = params.endpoint;
    let notification_protocol_version = params.notification_protocol_version;
    let tag = params.tag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Bindings", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Address", address.to_string());
    local_var_form_params.insert("BindingType", binding_type.to_string());
    if let Some(local_var_param_value) = credential_sid {
        local_var_form_params.insert("CredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = endpoint {
        local_var_form_params.insert("Endpoint", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Identity", identity.to_string());
    if let Some(local_var_param_value) = notification_protocol_version {
        local_var_form_params.insert("NotificationProtocolVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = tag {
        local_var_form_params.insert("Tag", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_credential(configuration: &configuration::Configuration, params: CreateCredentialParams) -> Result<ResponseContent<CreateCredentialSuccess>, Error<CreateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let _type = params._type;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_notification(configuration: &configuration::Configuration, params: CreateNotificationParams) -> Result<ResponseContent<CreateNotificationSuccess>, Error<CreateNotificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let action = params.action;
    let alexa = params.alexa;
    let apn = params.apn;
    let body = params.body;
    let data = params.data;
    let delivery_callback_url = params.delivery_callback_url;
    let facebook_messenger = params.facebook_messenger;
    let fcm = params.fcm;
    let gcm = params.gcm;
    let identity = params.identity;
    let priority = params.priority;
    let segment = params.segment;
    let sms = params.sms;
    let sound = params.sound;
    let tag = params.tag;
    let title = params.title;
    let to_binding = params.to_binding;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Notifications", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = action {
        local_var_form_params.insert("Action", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = alexa {
        local_var_form_params.insert("Alexa", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = apn {
        local_var_form_params.insert("Apn", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = body {
        local_var_form_params.insert("Body", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = data {
        local_var_form_params.insert("Data", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = delivery_callback_url {
        local_var_form_params.insert("DeliveryCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = facebook_messenger {
        local_var_form_params.insert("FacebookMessenger", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fcm {
        local_var_form_params.insert("Fcm", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = gcm {
        local_var_form_params.insert("Gcm", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = identity {
        local_var_form_params.insert("Identity", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = priority {
        local_var_form_params.insert("Priority", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = segment {
        local_var_form_params.insert("Segment", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = sms {
        local_var_form_params.insert("Sms", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sound {
        local_var_form_params.insert("Sound", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = tag {
        local_var_form_params.insert("Tag", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = title {
        local_var_form_params.insert("Title", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = to_binding {
        local_var_form_params.insert("ToBinding", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateNotificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateNotificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_service(configuration: &configuration::Configuration, params: CreateServiceParams) -> Result<ResponseContent<CreateServiceSuccess>, Error<CreateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let alexa_skill_id = params.alexa_skill_id;
    let apn_credential_sid = params.apn_credential_sid;
    let default_alexa_notification_protocol_version = params.default_alexa_notification_protocol_version;
    let default_apn_notification_protocol_version = params.default_apn_notification_protocol_version;
    let default_fcm_notification_protocol_version = params.default_fcm_notification_protocol_version;
    let default_gcm_notification_protocol_version = params.default_gcm_notification_protocol_version;
    let delivery_callback_enabled = params.delivery_callback_enabled;
    let delivery_callback_url = params.delivery_callback_url;
    let facebook_messenger_page_id = params.facebook_messenger_page_id;
    let fcm_credential_sid = params.fcm_credential_sid;
    let friendly_name = params.friendly_name;
    let gcm_credential_sid = params.gcm_credential_sid;
    let log_enabled = params.log_enabled;
    let messaging_service_sid = params.messaging_service_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = alexa_skill_id {
        local_var_form_params.insert("AlexaSkillId", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = apn_credential_sid {
        local_var_form_params.insert("ApnCredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_alexa_notification_protocol_version {
        local_var_form_params.insert("DefaultAlexaNotificationProtocolVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_apn_notification_protocol_version {
        local_var_form_params.insert("DefaultApnNotificationProtocolVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_fcm_notification_protocol_version {
        local_var_form_params.insert("DefaultFcmNotificationProtocolVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_gcm_notification_protocol_version {
        local_var_form_params.insert("DefaultGcmNotificationProtocolVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = delivery_callback_enabled {
        local_var_form_params.insert("DeliveryCallbackEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = delivery_callback_url {
        local_var_form_params.insert("DeliveryCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = facebook_messenger_page_id {
        local_var_form_params.insert("FacebookMessengerPageId", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fcm_credential_sid {
        local_var_form_params.insert("FcmCredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = gcm_credential_sid {
        local_var_form_params.insert("GcmCredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = log_enabled {
        local_var_form_params.insert("LogEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_service_sid {
        local_var_form_params.insert("MessagingServiceSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_binding(configuration: &configuration::Configuration, params: DeleteBindingParams) -> Result<ResponseContent<DeleteBindingSuccess>, Error<DeleteBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Bindings/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_credential(configuration: &configuration::Configuration, params: DeleteCredentialParams) -> Result<ResponseContent<DeleteCredentialSuccess>, Error<DeleteCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<ResponseContent<DeleteServiceSuccess>, Error<DeleteServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_binding(configuration: &configuration::Configuration, params: FetchBindingParams) -> Result<ResponseContent<FetchBindingSuccess>, Error<FetchBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Bindings/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_credential(configuration: &configuration::Configuration, params: FetchCredentialParams) -> Result<ResponseContent<FetchCredentialSuccess>, Error<FetchCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_service(configuration: &configuration::Configuration, params: FetchServiceParams) -> Result<ResponseContent<FetchServiceSuccess>, Error<FetchServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_binding(configuration: &configuration::Configuration, params: ListBindingParams) -> Result<ResponseContent<ListBindingSuccess>, Error<ListBindingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let identity = params.identity;
    let tag = params.tag;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Bindings", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = identity {
        local_var_req_builder = local_var_req_builder.query(&[("Identity", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = tag {
        local_var_req_builder = local_var_req_builder.query(&[("Tag", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListBindingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListBindingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_credential(configuration: &configuration::Configuration, params: ListCredentialParams) -> Result<ResponseContent<ListCredentialSuccess>, Error<ListCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_service(configuration: &configuration::Configuration, params: ListServiceParams) -> Result<ResponseContent<ListServiceSuccess>, Error<ListServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_credential(configuration: &configuration::Configuration, params: UpdateCredentialParams) -> Result<ResponseContent<UpdateCredentialSuccess>, Error<UpdateCredentialError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let api_key = params.api_key;
    let certificate = params.certificate;
    let friendly_name = params.friendly_name;
    let private_key = params.private_key;
    let sandbox = params.sandbox;
    let secret = params.secret;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Credentials/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = api_key {
        local_var_form_params.insert("ApiKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = certificate {
        local_var_form_params.insert("Certificate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = private_key {
        local_var_form_params.insert("PrivateKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sandbox {
        local_var_form_params.insert("Sandbox", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secret {
        local_var_form_params.insert("Secret", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateCredentialSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateCredentialError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_service(configuration: &configuration::Configuration, params: UpdateServiceParams) -> Result<ResponseContent<UpdateServiceSuccess>, Error<UpdateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let alexa_skill_id = params.alexa_skill_id;
    let apn_credential_sid = params.apn_credential_sid;
    let default_alexa_notification_protocol_version = params.default_alexa_notification_protocol_version;
    let default_apn_notification_protocol_version = params.default_apn_notification_protocol_version;
    let default_fcm_notification_protocol_version = params.default_fcm_notification_protocol_version;
    let default_gcm_notification_protocol_version = params.default_gcm_notification_protocol_version;
    let delivery_callback_enabled = params.delivery_callback_enabled;
    let delivery_callback_url = params.delivery_callback_url;
    let facebook_messenger_page_id = params.facebook_messenger_page_id;
    let fcm_credential_sid = params.fcm_credential_sid;
    let friendly_name = params.friendly_name;
    let gcm_credential_sid = params.gcm_credential_sid;
    let log_enabled = params.log_enabled;
    let messaging_service_sid = params.messaging_service_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = alexa_skill_id {
        local_var_form_params.insert("AlexaSkillId", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = apn_credential_sid {
        local_var_form_params.insert("ApnCredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_alexa_notification_protocol_version {
        local_var_form_params.insert("DefaultAlexaNotificationProtocolVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_apn_notification_protocol_version {
        local_var_form_params.insert("DefaultApnNotificationProtocolVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_fcm_notification_protocol_version {
        local_var_form_params.insert("DefaultFcmNotificationProtocolVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = default_gcm_notification_protocol_version {
        local_var_form_params.insert("DefaultGcmNotificationProtocolVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = delivery_callback_enabled {
        local_var_form_params.insert("DeliveryCallbackEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = delivery_callback_url {
        local_var_form_params.insert("DeliveryCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = facebook_messenger_page_id {
        local_var_form_params.insert("FacebookMessengerPageId", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fcm_credential_sid {
        local_var_form_params.insert("FcmCredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = gcm_credential_sid {
        local_var_form_params.insert("GcmCredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = log_enabled {
        local_var_form_params.insert("LogEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_service_sid {
        local_var_form_params.insert("MessagingServiceSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

