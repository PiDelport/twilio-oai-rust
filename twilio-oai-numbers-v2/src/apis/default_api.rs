/*
 * Twilio - Numbers
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_bundle`]
#[derive(Clone, Debug, Default)]
pub struct CreateBundleParams {
    /// The email address that will receive updates when the Bundle resource changes status.
    pub email: String,
    /// The string that you assigned to describe the resource.
    pub friendly_name: String,
    /// The [type of End User](https://www.twilio.com/docs/phone-numbers/regulatory/api/end-user-types) of the Bundle resource.
    pub end_user_type: Option<String>,
    /// The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the Bundle's phone number country ownership request.
    pub iso_country: Option<String>,
    /// The type of phone number of the Bundle's ownership request. Can be `local`, `mobile`, `national`, or `toll free`.
    pub number_type: Option<String>,
    /// The unique string of a regulation that is associated to the Bundle resource.
    pub regulation_sid: Option<String>,
    /// The URL we call to inform your application of status changes.
    pub status_callback: Option<String>
}

/// struct for passing parameters to the method [`create_end_user`]
#[derive(Clone, Debug, Default)]
pub struct CreateEndUserParams {
    /// The string that you assigned to describe the resource.
    pub friendly_name: String,
    /// The type of end user of the Bundle resource - can be `individual` or `business`.
    pub _type: String,
    /// The set of parameters that are the attributes of the End User resource which are derived End User Types.
    pub attributes: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`create_evaluation`]
#[derive(Clone, Debug, Default)]
pub struct CreateEvaluationParams {
    /// The unique string that identifies the Bundle resource.
    pub bundle_sid: String
}

/// struct for passing parameters to the method [`create_item_assignment`]
#[derive(Clone, Debug, Default)]
pub struct CreateItemAssignmentParams {
    /// The unique string that we created to identify the Bundle resource.
    pub bundle_sid: String,
    /// The SID of an object bag that holds information of the different items.
    pub object_sid: String
}

/// struct for passing parameters to the method [`create_supporting_document`]
#[derive(Clone, Debug, Default)]
pub struct CreateSupportingDocumentParams {
    /// The string that you assigned to describe the resource.
    pub friendly_name: String,
    /// The type of the Supporting Document.
    pub _type: String,
    /// The set of parameters that are the attributes of the Supporting Documents resource which are derived Supporting Document Types.
    pub attributes: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`delete_bundle`]
#[derive(Clone, Debug, Default)]
pub struct DeleteBundleParams {
    /// The unique string that we created to identify the Bundle resource.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_end_user`]
#[derive(Clone, Debug, Default)]
pub struct DeleteEndUserParams {
    /// The unique string created by Twilio to identify the End User resource.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_item_assignment`]
#[derive(Clone, Debug, Default)]
pub struct DeleteItemAssignmentParams {
    /// The unique string that we created to identify the Bundle resource.
    pub bundle_sid: String,
    /// The unique string that we created to identify the Identity resource.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_supporting_document`]
#[derive(Clone, Debug, Default)]
pub struct DeleteSupportingDocumentParams {
    /// The unique string created by Twilio to identify the Supporting Document resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_bundle`]
#[derive(Clone, Debug, Default)]
pub struct FetchBundleParams {
    /// The unique string that we created to identify the Bundle resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_end_user`]
#[derive(Clone, Debug, Default)]
pub struct FetchEndUserParams {
    /// The unique string created by Twilio to identify the End User resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_end_user_type`]
#[derive(Clone, Debug, Default)]
pub struct FetchEndUserTypeParams {
    /// The unique string that identifies the End-User Type resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_evaluation`]
#[derive(Clone, Debug, Default)]
pub struct FetchEvaluationParams {
    /// The unique string that we created to identify the Bundle resource.
    pub bundle_sid: String,
    /// The unique string that identifies the Evaluation resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_item_assignment`]
#[derive(Clone, Debug, Default)]
pub struct FetchItemAssignmentParams {
    /// The unique string that we created to identify the Bundle resource.
    pub bundle_sid: String,
    /// The unique string that we created to identify the Identity resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_regulation`]
#[derive(Clone, Debug, Default)]
pub struct FetchRegulationParams {
    /// The unique string that identifies the Regulation resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_supporting_document`]
#[derive(Clone, Debug, Default)]
pub struct FetchSupportingDocumentParams {
    /// The unique string created by Twilio to identify the Supporting Document resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_supporting_document_type`]
#[derive(Clone, Debug, Default)]
pub struct FetchSupportingDocumentTypeParams {
    /// The unique string that identifies the Supporting Document Type resource.
    pub sid: String
}

/// struct for passing parameters to the method [`list_bundle`]
#[derive(Clone, Debug, Default)]
pub struct ListBundleParams {
    /// The verification status of the Bundle resource.
    pub status: Option<String>,
    /// The string that you assigned to describe the resource.
    pub friendly_name: Option<String>,
    /// The unique string of a regulation that is associated to the Bundle resource.
    pub regulation_sid: Option<String>,
    /// The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the Bundle's phone number country ownership request.
    pub iso_country: Option<String>,
    /// The type of phone number of the Bundle's ownership request. Can be `local`, `mobile`, `national`, or `toll free`.
    pub number_type: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_end_user`]
#[derive(Clone, Debug, Default)]
pub struct ListEndUserParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_end_user_type`]
#[derive(Clone, Debug, Default)]
pub struct ListEndUserTypeParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_evaluation`]
#[derive(Clone, Debug, Default)]
pub struct ListEvaluationParams {
    /// The unique string that identifies the Bundle resource.
    pub bundle_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_item_assignment`]
#[derive(Clone, Debug, Default)]
pub struct ListItemAssignmentParams {
    /// The unique string that we created to identify the Bundle resource.
    pub bundle_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_regulation`]
#[derive(Clone, Debug, Default)]
pub struct ListRegulationParams {
    /// The type of End User the regulation requires - can be `individual` or `business`.
    pub end_user_type: Option<String>,
    /// The ISO country code of the phone number's country.
    pub iso_country: Option<String>,
    /// The type of phone number that the regulatory requiremnt is restricting.
    pub number_type: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_supporting_document`]
#[derive(Clone, Debug, Default)]
pub struct ListSupportingDocumentParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_supporting_document_type`]
#[derive(Clone, Debug, Default)]
pub struct ListSupportingDocumentTypeParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`update_bundle`]
#[derive(Clone, Debug, Default)]
pub struct UpdateBundleParams {
    /// The unique string that we created to identify the Bundle resource.
    pub sid: String,
    /// The email address that will receive updates when the Bundle resource changes status.
    pub email: Option<String>,
    /// The string that you assigned to describe the resource.
    pub friendly_name: Option<String>,
    /// The verification status of the Bundle resource.
    pub status: Option<String>,
    /// The URL we call to inform your application of status changes.
    pub status_callback: Option<String>
}

/// struct for passing parameters to the method [`update_end_user`]
#[derive(Clone, Debug, Default)]
pub struct UpdateEndUserParams {
    /// The unique string created by Twilio to identify the End User resource.
    pub sid: String,
    /// The set of parameters that are the attributes of the End User resource which are derived End User Types.
    pub attributes: Option<serde_json::Value>,
    /// The string that you assigned to describe the resource.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method [`update_supporting_document`]
#[derive(Clone, Debug, Default)]
pub struct UpdateSupportingDocumentParams {
    /// The unique string created by Twilio to identify the Supporting Document resource.
    pub sid: String,
    /// The set of parameters that are the attributes of the Supporting Document resource which are derived Supporting Document Types.
    pub attributes: Option<serde_json::Value>,
    /// The string that you assigned to describe the resource.
    pub friendly_name: Option<String>
}


/// struct for typed successes of method [`create_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBundleSuccess {
    Status201(crate::models::NumbersV2RegulatoryComplianceBundle),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_end_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEndUserSuccess {
    Status201(crate::models::NumbersV2RegulatoryComplianceEndUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_evaluation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEvaluationSuccess {
    Status201(crate::models::NumbersV2RegulatoryComplianceBundleEvaluation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_item_assignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateItemAssignmentSuccess {
    Status201(crate::models::NumbersV2RegulatoryComplianceBundleItemAssignment),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_supporting_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSupportingDocumentSuccess {
    Status201(crate::models::NumbersV2RegulatoryComplianceSupportingDocument),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBundleSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_end_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEndUserSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_item_assignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteItemAssignmentSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_supporting_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSupportingDocumentSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBundleSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceBundle),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_end_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEndUserSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceEndUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_end_user_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEndUserTypeSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceEndUserType),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_evaluation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEvaluationSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceBundleEvaluation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_item_assignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchItemAssignmentSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceBundleItemAssignment),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_regulation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRegulationSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceRegulation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_supporting_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSupportingDocumentSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceSupportingDocument),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_supporting_document_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSupportingDocumentTypeSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceSupportingDocumentType),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBundleSuccess {
    Status200(crate::models::ListBundleResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_end_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEndUserSuccess {
    Status200(crate::models::ListEndUserResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_end_user_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEndUserTypeSuccess {
    Status200(crate::models::ListEndUserTypeResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_evaluation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEvaluationSuccess {
    Status200(crate::models::ListEvaluationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_item_assignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListItemAssignmentSuccess {
    Status200(crate::models::ListItemAssignmentResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_regulation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRegulationSuccess {
    Status200(crate::models::ListRegulationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_supporting_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSupportingDocumentSuccess {
    Status200(crate::models::ListSupportingDocumentResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_supporting_document_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSupportingDocumentTypeSuccess {
    Status200(crate::models::ListSupportingDocumentTypeResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateBundleSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceBundle),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_end_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEndUserSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceEndUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_supporting_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSupportingDocumentSuccess {
    Status200(crate::models::NumbersV2RegulatoryComplianceSupportingDocument),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBundleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_end_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEndUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_evaluation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEvaluationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_item_assignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateItemAssignmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_supporting_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSupportingDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBundleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_end_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEndUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_item_assignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteItemAssignmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_supporting_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSupportingDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBundleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_end_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEndUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_end_user_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEndUserTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_evaluation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEvaluationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_item_assignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchItemAssignmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_regulation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRegulationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_supporting_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSupportingDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_supporting_document_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSupportingDocumentTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBundleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_end_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEndUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_end_user_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEndUserTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_evaluation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEvaluationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_item_assignment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListItemAssignmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_regulation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRegulationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_supporting_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSupportingDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_supporting_document_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSupportingDocumentTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateBundleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_end_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEndUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_supporting_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSupportingDocumentError {
    UnknownValue(serde_json::Value),
}


/// Create a new Bundle.
pub async fn create_bundle(configuration: &configuration::Configuration, params: CreateBundleParams) -> Result<ResponseContent<CreateBundleSuccess>, Error<CreateBundleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let email = params.email;
    let friendly_name = params.friendly_name;
    let end_user_type = params.end_user_type;
    let iso_country = params.iso_country;
    let number_type = params.number_type;
    let regulation_sid = params.regulation_sid;
    let status_callback = params.status_callback;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Email", email.to_string());
    if let Some(local_var_param_value) = end_user_type {
        local_var_form_params.insert("EndUserType", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = iso_country {
        local_var_form_params.insert("IsoCountry", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = number_type {
        local_var_form_params.insert("NumberType", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = regulation_sid {
        local_var_form_params.insert("RegulationSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateBundleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateBundleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new End User.
pub async fn create_end_user(configuration: &configuration::Configuration, params: CreateEndUserParams) -> Result<ResponseContent<CreateEndUserSuccess>, Error<CreateEndUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let _type = params._type;
    let attributes = params.attributes;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/EndUsers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateEndUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateEndUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates an evaluation for a bundle
pub async fn create_evaluation(configuration: &configuration::Configuration, params: CreateEvaluationParams) -> Result<ResponseContent<CreateEvaluationSuccess>, Error<CreateEvaluationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bundle_sid = params.bundle_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations", local_var_configuration.base_path, BundleSid=crate::apis::urlencode(bundle_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateEvaluationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateEvaluationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Assigned Item.
pub async fn create_item_assignment(configuration: &configuration::Configuration, params: CreateItemAssignmentParams) -> Result<ResponseContent<CreateItemAssignmentSuccess>, Error<CreateItemAssignmentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bundle_sid = params.bundle_sid;
    let object_sid = params.object_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments", local_var_configuration.base_path, BundleSid=crate::apis::urlencode(bundle_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("ObjectSid", object_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateItemAssignmentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateItemAssignmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Supporting Document.
pub async fn create_supporting_document(configuration: &configuration::Configuration, params: CreateSupportingDocumentParams) -> Result<ResponseContent<CreateSupportingDocumentSuccess>, Error<CreateSupportingDocumentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let _type = params._type;
    let attributes = params.attributes;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/SupportingDocuments", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("Type", _type.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSupportingDocumentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSupportingDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Bundle.
pub async fn delete_bundle(configuration: &configuration::Configuration, params: DeleteBundleParams) -> Result<ResponseContent<DeleteBundleSuccess>, Error<DeleteBundleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteBundleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteBundleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific End User.
pub async fn delete_end_user(configuration: &configuration::Configuration, params: DeleteEndUserParams) -> Result<ResponseContent<DeleteEndUserSuccess>, Error<DeleteEndUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/EndUsers/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteEndUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteEndUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an Assignment Item Instance.
pub async fn delete_item_assignment(configuration: &configuration::Configuration, params: DeleteItemAssignmentParams) -> Result<ResponseContent<DeleteItemAssignmentSuccess>, Error<DeleteItemAssignmentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bundle_sid = params.bundle_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments/{Sid}", local_var_configuration.base_path, BundleSid=crate::apis::urlencode(bundle_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteItemAssignmentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteItemAssignmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Supporting Document.
pub async fn delete_supporting_document(configuration: &configuration::Configuration, params: DeleteSupportingDocumentParams) -> Result<ResponseContent<DeleteSupportingDocumentSuccess>, Error<DeleteSupportingDocumentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/SupportingDocuments/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSupportingDocumentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSupportingDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Bundle instance.
pub async fn fetch_bundle(configuration: &configuration::Configuration, params: FetchBundleParams) -> Result<ResponseContent<FetchBundleSuccess>, Error<FetchBundleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchBundleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchBundleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch specific End User Instance.
pub async fn fetch_end_user(configuration: &configuration::Configuration, params: FetchEndUserParams) -> Result<ResponseContent<FetchEndUserSuccess>, Error<FetchEndUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/EndUsers/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchEndUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchEndUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific End-User Type Instance.
pub async fn fetch_end_user_type(configuration: &configuration::Configuration, params: FetchEndUserTypeParams) -> Result<ResponseContent<FetchEndUserTypeSuccess>, Error<FetchEndUserTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/EndUserTypes/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchEndUserTypeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchEndUserTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch specific Evaluation Instance.
pub async fn fetch_evaluation(configuration: &configuration::Configuration, params: FetchEvaluationParams) -> Result<ResponseContent<FetchEvaluationSuccess>, Error<FetchEvaluationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bundle_sid = params.bundle_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations/{Sid}", local_var_configuration.base_path, BundleSid=crate::apis::urlencode(bundle_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchEvaluationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchEvaluationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch specific Assigned Item Instance.
pub async fn fetch_item_assignment(configuration: &configuration::Configuration, params: FetchItemAssignmentParams) -> Result<ResponseContent<FetchItemAssignmentSuccess>, Error<FetchItemAssignmentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bundle_sid = params.bundle_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments/{Sid}", local_var_configuration.base_path, BundleSid=crate::apis::urlencode(bundle_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchItemAssignmentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchItemAssignmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch specific Regulation Instance.
pub async fn fetch_regulation(configuration: &configuration::Configuration, params: FetchRegulationParams) -> Result<ResponseContent<FetchRegulationSuccess>, Error<FetchRegulationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Regulations/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRegulationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRegulationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch specific Supporting Document Instance.
pub async fn fetch_supporting_document(configuration: &configuration::Configuration, params: FetchSupportingDocumentParams) -> Result<ResponseContent<FetchSupportingDocumentSuccess>, Error<FetchSupportingDocumentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/SupportingDocuments/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSupportingDocumentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSupportingDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Supporting Document Type Instance.
pub async fn fetch_supporting_document_type(configuration: &configuration::Configuration, params: FetchSupportingDocumentTypeParams) -> Result<ResponseContent<FetchSupportingDocumentTypeSuccess>, Error<FetchSupportingDocumentTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/SupportingDocumentTypes/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSupportingDocumentTypeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSupportingDocumentTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Bundles for an account.
pub async fn list_bundle(configuration: &configuration::Configuration, params: ListBundleParams) -> Result<ResponseContent<ListBundleSuccess>, Error<ListBundleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let status = params.status;
    let friendly_name = params.friendly_name;
    let regulation_sid = params.regulation_sid;
    let iso_country = params.iso_country;
    let number_type = params.number_type;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = regulation_sid {
        local_var_req_builder = local_var_req_builder.query(&[("RegulationSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iso_country {
        local_var_req_builder = local_var_req_builder.query(&[("IsoCountry", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = number_type {
        local_var_req_builder = local_var_req_builder.query(&[("NumberType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListBundleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListBundleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all End User for an account.
pub async fn list_end_user(configuration: &configuration::Configuration, params: ListEndUserParams) -> Result<ResponseContent<ListEndUserSuccess>, Error<ListEndUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/EndUsers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListEndUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListEndUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all End-User Types.
pub async fn list_end_user_type(configuration: &configuration::Configuration, params: ListEndUserTypeParams) -> Result<ResponseContent<ListEndUserTypeSuccess>, Error<ListEndUserTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/EndUserTypes", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListEndUserTypeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListEndUserTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Evaluations associated to the Bundle resource.
pub async fn list_evaluation(configuration: &configuration::Configuration, params: ListEvaluationParams) -> Result<ResponseContent<ListEvaluationSuccess>, Error<ListEvaluationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bundle_sid = params.bundle_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations", local_var_configuration.base_path, BundleSid=crate::apis::urlencode(bundle_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListEvaluationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListEvaluationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Assigned Items for an account.
pub async fn list_item_assignment(configuration: &configuration::Configuration, params: ListItemAssignmentParams) -> Result<ResponseContent<ListItemAssignmentSuccess>, Error<ListItemAssignmentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bundle_sid = params.bundle_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments", local_var_configuration.base_path, BundleSid=crate::apis::urlencode(bundle_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListItemAssignmentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListItemAssignmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Regulations.
pub async fn list_regulation(configuration: &configuration::Configuration, params: ListRegulationParams) -> Result<ResponseContent<ListRegulationSuccess>, Error<ListRegulationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let end_user_type = params.end_user_type;
    let iso_country = params.iso_country;
    let number_type = params.number_type;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Regulations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end_user_type {
        local_var_req_builder = local_var_req_builder.query(&[("EndUserType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iso_country {
        local_var_req_builder = local_var_req_builder.query(&[("IsoCountry", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = number_type {
        local_var_req_builder = local_var_req_builder.query(&[("NumberType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRegulationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRegulationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Supporting Document for an account.
pub async fn list_supporting_document(configuration: &configuration::Configuration, params: ListSupportingDocumentParams) -> Result<ResponseContent<ListSupportingDocumentSuccess>, Error<ListSupportingDocumentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/SupportingDocuments", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSupportingDocumentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSupportingDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Supporting Document Types.
pub async fn list_supporting_document_type(configuration: &configuration::Configuration, params: ListSupportingDocumentTypeParams) -> Result<ResponseContent<ListSupportingDocumentTypeSuccess>, Error<ListSupportingDocumentTypeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/SupportingDocumentTypes", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSupportingDocumentTypeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSupportingDocumentTypeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates a Bundle in an account.
pub async fn update_bundle(configuration: &configuration::Configuration, params: UpdateBundleParams) -> Result<ResponseContent<UpdateBundleSuccess>, Error<UpdateBundleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let email = params.email;
    let friendly_name = params.friendly_name;
    let status = params.status;
    let status_callback = params.status_callback;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/Bundles/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = email {
        local_var_form_params.insert("Email", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateBundleSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateBundleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing End User.
pub async fn update_end_user(configuration: &configuration::Configuration, params: UpdateEndUserParams) -> Result<ResponseContent<UpdateEndUserSuccess>, Error<UpdateEndUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/EndUsers/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateEndUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateEndUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing Supporting Document.
pub async fn update_supporting_document(configuration: &configuration::Configuration, params: UpdateSupportingDocumentParams) -> Result<ResponseContent<UpdateSupportingDocumentSuccess>, Error<UpdateSupportingDocumentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/RegulatoryCompliance/SupportingDocuments/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSupportingDocumentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSupportingDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

