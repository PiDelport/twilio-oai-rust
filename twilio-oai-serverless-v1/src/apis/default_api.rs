/*
 * Twilio - Serverless
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.2
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_asset`
#[derive(Clone, Debug, Default)]
pub struct CreateAssetParams {
    /// The SID of the Service to create the Asset resource under.
    pub service_sid: String,
    /// A descriptive string that you create to describe the Asset resource. It can be a maximum of 255 characters.
    pub friendly_name: String
}

/// struct for passing parameters to the method `create_build`
#[derive(Clone, Debug, Default)]
pub struct CreateBuildParams {
    /// The SID of the Service to create the Build resource under.
    pub service_sid: String,
    /// The list of Asset Version resource SIDs to include in the Build.
    pub asset_versions: Option<Vec<String>>,
    /// A list of objects that describe the Dependencies included in the Build. Each object contains the `name` and `version` of the dependency.
    pub dependencies: Option<String>,
    /// The list of the Function Version resource SIDs to include in the Build.
    pub function_versions: Option<Vec<String>>,
    /// The Runtime version that will be used to run the Build resource when it is deployed.
    pub runtime: Option<String>
}

/// struct for passing parameters to the method `create_deployment`
#[derive(Clone, Debug, Default)]
pub struct CreateDeploymentParams {
    /// The SID of the Service to create the Deployment resource under.
    pub service_sid: String,
    /// The SID of the Environment for the Deployment.
    pub environment_sid: String,
    /// The SID of the Build for the Deployment.
    pub build_sid: Option<String>
}

/// struct for passing parameters to the method `create_environment`
#[derive(Clone, Debug, Default)]
pub struct CreateEnvironmentParams {
    /// The SID of the Service to create the Environment resource under.
    pub service_sid: String,
    /// A user-defined string that uniquely identifies the Environment resource. It can be a maximum of 100 characters.
    pub unique_name: String,
    /// A URL-friendly name that represents the environment and forms part of the domain name. It can be a maximum of 16 characters.
    pub domain_suffix: Option<String>
}

/// struct for passing parameters to the method `create_function`
#[derive(Clone, Debug, Default)]
pub struct CreateFunctionParams {
    /// The SID of the Service to create the Function resource under.
    pub service_sid: String,
    /// A descriptive string that you create to describe the Function resource. It can be a maximum of 255 characters.
    pub friendly_name: String
}

/// struct for passing parameters to the method `create_service`
#[derive(Clone, Debug, Default)]
pub struct CreateServiceParams {
    /// A descriptive string that you create to describe the Service resource. It can be a maximum of 255 characters.
    pub friendly_name: String,
    /// A user-defined string that uniquely identifies the Service resource. It can be used as an alternative to the `sid` in the URL path to address the Service resource. This value must be 50 characters or less in length and be unique.
    pub unique_name: String,
    /// Whether to inject Account credentials into a function invocation context. The default value is `true`.
    pub include_credentials: Option<bool>,
    /// Whether the Service's properties and subresources can be edited via the UI. The default value is `false`.
    pub ui_editable: Option<bool>
}

/// struct for passing parameters to the method `create_variable`
#[derive(Clone, Debug, Default)]
pub struct CreateVariableParams {
    /// The SID of the Service to create the Variable resource under.
    pub service_sid: String,
    /// The SID of the Environment in which the Variable resource exists.
    pub environment_sid: String,
    /// A string by which the Variable resource can be referenced. It can be a maximum of 128 characters.
    pub key: String,
    /// A string that contains the actual value of the Variable. It can be a maximum of 450 bytes in size.
    pub value: String
}

/// struct for passing parameters to the method `delete_asset`
#[derive(Clone, Debug, Default)]
pub struct DeleteAssetParams {
    /// The SID of the Service to delete the Asset resource from.
    pub service_sid: String,
    /// The SID that identifies the Asset resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_build`
#[derive(Clone, Debug, Default)]
pub struct DeleteBuildParams {
    /// The SID of the Service to delete the Build resource from.
    pub service_sid: String,
    /// The SID of the Build resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_environment`
#[derive(Clone, Debug, Default)]
pub struct DeleteEnvironmentParams {
    /// The SID of the Service to delete the Environment resource from.
    pub service_sid: String,
    /// The SID of the Environment resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_function`
#[derive(Clone, Debug, Default)]
pub struct DeleteFunctionParams {
    /// The SID of the Service to delete the Function resource from.
    pub service_sid: String,
    /// The SID of the Function resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_service`
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    /// The `sid` or `unique_name` of the Service resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_variable`
#[derive(Clone, Debug, Default)]
pub struct DeleteVariableParams {
    /// The SID of the Service to delete the Variable resource from.
    pub service_sid: String,
    /// The SID of the Environment with the Variables to delete.
    pub environment_sid: String,
    /// The SID of the Variable resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_asset`
#[derive(Clone, Debug, Default)]
pub struct FetchAssetParams {
    /// The SID of the Service to fetch the Asset resource from.
    pub service_sid: String,
    /// The SID that identifies the Asset resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_asset_version`
#[derive(Clone, Debug, Default)]
pub struct FetchAssetVersionParams {
    /// The SID of the Service to fetch the Asset Version resource from.
    pub service_sid: String,
    /// The SID of the Asset resource that is the parent of the Asset Version resource to fetch.
    pub asset_sid: String,
    /// The SID of the Asset Version resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_build`
#[derive(Clone, Debug, Default)]
pub struct FetchBuildParams {
    /// The SID of the Service to fetch the Build resource from.
    pub service_sid: String,
    /// The SID of the Build resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_build_status`
#[derive(Clone, Debug, Default)]
pub struct FetchBuildStatusParams {
    /// The SID of the Service to fetch the Build resource from.
    pub service_sid: String,
    /// The SID of the Build resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_deployment`
#[derive(Clone, Debug, Default)]
pub struct FetchDeploymentParams {
    /// The SID of the Service to fetch the Deployment resource from.
    pub service_sid: String,
    /// The SID of the Environment used by the Deployment to fetch.
    pub environment_sid: String,
    /// The SID that identifies the Deployment resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_environment`
#[derive(Clone, Debug, Default)]
pub struct FetchEnvironmentParams {
    /// The SID of the Service to fetch the Environment resource from.
    pub service_sid: String,
    /// The SID of the Environment resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_function`
#[derive(Clone, Debug, Default)]
pub struct FetchFunctionParams {
    /// The SID of the Service to fetch the Function resource from.
    pub service_sid: String,
    /// The SID of the Function resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_function_version`
#[derive(Clone, Debug, Default)]
pub struct FetchFunctionVersionParams {
    /// The SID of the Service to fetch the Function Version resource from.
    pub service_sid: String,
    /// The SID of the function that is the parent of the Function Version resource to fetch.
    pub function_sid: String,
    /// The SID of the Function Version resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_function_version_content`
#[derive(Clone, Debug, Default)]
pub struct FetchFunctionVersionContentParams {
    /// The SID of the Service to fetch the Function Version content from.
    pub service_sid: String,
    /// The SID of the Function that is the parent of the Function Version content to fetch.
    pub function_sid: String,
    /// The SID of the Function Version content to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_log`
#[derive(Clone, Debug, Default)]
pub struct FetchLogParams {
    /// The SID of the Service to fetch the Log resource from.
    pub service_sid: String,
    /// The SID of the environment with the Log resource to fetch.
    pub environment_sid: String,
    /// The SID of the Log resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_service`
#[derive(Clone, Debug, Default)]
pub struct FetchServiceParams {
    /// The `sid` or `unique_name` of the Service resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_variable`
#[derive(Clone, Debug, Default)]
pub struct FetchVariableParams {
    /// The SID of the Service to fetch the Variable resource from.
    pub service_sid: String,
    /// The SID of the Environment with the Variable resource to fetch.
    pub environment_sid: String,
    /// The SID of the Variable resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `list_asset`
#[derive(Clone, Debug, Default)]
pub struct ListAssetParams {
    /// The SID of the Service to read the Asset resources from.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_asset_version`
#[derive(Clone, Debug, Default)]
pub struct ListAssetVersionParams {
    /// The SID of the Service to read the Asset Version resource from.
    pub service_sid: String,
    /// The SID of the Asset resource that is the parent of the Asset Version resources to read.
    pub asset_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_build`
#[derive(Clone, Debug, Default)]
pub struct ListBuildParams {
    /// The SID of the Service to read the Build resources from.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_deployment`
#[derive(Clone, Debug, Default)]
pub struct ListDeploymentParams {
    /// The SID of the Service to read the Deployment resources from.
    pub service_sid: String,
    /// The SID of the Environment used by the Deployment resources to read.
    pub environment_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_environment`
#[derive(Clone, Debug, Default)]
pub struct ListEnvironmentParams {
    /// The SID of the Service to read the Environment resources from.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_function`
#[derive(Clone, Debug, Default)]
pub struct ListFunctionParams {
    /// The SID of the Service to read the Function resources from.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_function_version`
#[derive(Clone, Debug, Default)]
pub struct ListFunctionVersionParams {
    /// The SID of the Service to read the Function Version resources from.
    pub service_sid: String,
    /// The SID of the function that is the parent of the Function Version resources to read.
    pub function_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_log`
#[derive(Clone, Debug, Default)]
pub struct ListLogParams {
    /// The SID of the Service to read the Log resource from.
    pub service_sid: String,
    /// The SID of the environment with the Log resources to read.
    pub environment_sid: String,
    /// The SID of the function whose invocation produced the Log resources to read.
    pub function_sid: Option<String>,
    /// The date/time (in GMT, ISO 8601) after which the Log resources must have been created. Defaults to 1 day prior to current date/time.
    pub start_date: Option<String>,
    /// The date/time (in GMT, ISO 8601) before which the Log resources must have been created. Defaults to current date/time.
    pub end_date: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_service`
#[derive(Clone, Debug, Default)]
pub struct ListServiceParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_variable`
#[derive(Clone, Debug, Default)]
pub struct ListVariableParams {
    /// The SID of the Service to read the Variable resources from.
    pub service_sid: String,
    /// The SID of the Environment with the Variable resources to read.
    pub environment_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_asset`
#[derive(Clone, Debug, Default)]
pub struct UpdateAssetParams {
    /// The SID of the Service to update the Asset resource from.
    pub service_sid: String,
    /// The SID that identifies the Asset resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the Asset resource. It can be a maximum of 255 characters.
    pub friendly_name: String
}

/// struct for passing parameters to the method `update_function`
#[derive(Clone, Debug, Default)]
pub struct UpdateFunctionParams {
    /// The SID of the Service to update the Function resource from.
    pub service_sid: String,
    /// The SID of the Function resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the Function resource. It can be a maximum of 255 characters.
    pub friendly_name: String
}

/// struct for passing parameters to the method `update_service`
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceParams {
    /// The `sid` or `unique_name` of the Service resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the Service resource. It can be a maximum of 255 characters.
    pub friendly_name: Option<String>,
    /// Whether to inject Account credentials into a function invocation context.
    pub include_credentials: Option<bool>,
    /// Whether the Service resource's properties and subresources can be edited via the UI. The default value is `false`.
    pub ui_editable: Option<bool>
}

/// struct for passing parameters to the method `update_variable`
#[derive(Clone, Debug, Default)]
pub struct UpdateVariableParams {
    /// The SID of the Service to update the Variable resource under.
    pub service_sid: String,
    /// The SID of the Environment with the Variable resource to update.
    pub environment_sid: String,
    /// The SID of the Variable resource to update.
    pub sid: String,
    /// A string by which the Variable resource can be referenced. It can be a maximum of 128 characters.
    pub key: Option<String>,
    /// A string that contains the actual value of the Variable. It can be a maximum of 450 bytes in size.
    pub value: Option<String>
}


/// struct for typed successes of method `create_asset`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssetSuccess {
    Status201(crate::models::ServerlessV1ServiceAsset),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBuildSuccess {
    Status201(crate::models::ServerlessV1ServiceBuild),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_deployment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDeploymentSuccess {
    Status201(crate::models::ServerlessV1ServiceEnvironmentDeployment),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_environment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEnvironmentSuccess {
    Status201(crate::models::ServerlessV1ServiceEnvironment),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_function`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFunctionSuccess {
    Status201(crate::models::ServerlessV1ServiceFunction),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceSuccess {
    Status201(crate::models::ServerlessV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_variable`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVariableSuccess {
    Status201(crate::models::ServerlessV1ServiceEnvironmentVariable),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_asset`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssetSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBuildSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_environment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEnvironmentSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_function`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFunctionSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_variable`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteVariableSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_asset`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAssetSuccess {
    Status200(crate::models::ServerlessV1ServiceAsset),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_asset_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAssetVersionSuccess {
    Status200(crate::models::ServerlessV1ServiceAssetAssetVersion),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBuildSuccess {
    Status200(crate::models::ServerlessV1ServiceBuild),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_build_status`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBuildStatusSuccess {
    Status200(crate::models::ServerlessV1ServiceBuildBuildStatus),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_deployment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDeploymentSuccess {
    Status200(crate::models::ServerlessV1ServiceEnvironmentDeployment),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_environment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEnvironmentSuccess {
    Status200(crate::models::ServerlessV1ServiceEnvironment),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_function`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFunctionSuccess {
    Status200(crate::models::ServerlessV1ServiceFunction),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_function_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFunctionVersionSuccess {
    Status200(crate::models::ServerlessV1ServiceFunctionFunctionVersion),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_function_version_content`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFunctionVersionContentSuccess {
    Status200(crate::models::ServerlessV1ServiceFunctionFunctionVersionFunctionVersionContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_log`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchLogSuccess {
    Status200(crate::models::ServerlessV1ServiceEnvironmentLog),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceSuccess {
    Status200(crate::models::ServerlessV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_variable`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchVariableSuccess {
    Status200(crate::models::ServerlessV1ServiceEnvironmentVariable),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_asset`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAssetSuccess {
    Status200(crate::models::ListAssetResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_asset_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAssetVersionSuccess {
    Status200(crate::models::ListAssetVersionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBuildSuccess {
    Status200(crate::models::ListBuildResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_deployment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDeploymentSuccess {
    Status200(crate::models::ListDeploymentResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_environment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEnvironmentSuccess {
    Status200(crate::models::ListEnvironmentResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_function`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFunctionSuccess {
    Status200(crate::models::ListFunctionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_function_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFunctionVersionSuccess {
    Status200(crate::models::ListFunctionVersionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_log`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListLogSuccess {
    Status200(crate::models::ListLogResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceSuccess {
    Status200(crate::models::ListServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_variable`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListVariableSuccess {
    Status200(crate::models::ListVariableResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_asset`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAssetSuccess {
    Status200(crate::models::ServerlessV1ServiceAsset),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_function`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFunctionSuccess {
    Status200(crate::models::ServerlessV1ServiceFunction),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceSuccess {
    Status200(crate::models::ServerlessV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_variable`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateVariableSuccess {
    Status200(crate::models::ServerlessV1ServiceEnvironmentVariable),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_asset`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_deployment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDeploymentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_environment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEnvironmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_function`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFunctionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_variable`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVariableError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_asset`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAssetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_environment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEnvironmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_function`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFunctionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_variable`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteVariableError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_asset`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAssetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_asset_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAssetVersionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_build_status`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBuildStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_deployment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDeploymentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_environment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEnvironmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_function`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFunctionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_function_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFunctionVersionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_function_version_content`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFunctionVersionContentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_log`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchLogError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_variable`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchVariableError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_asset`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAssetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_asset_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAssetVersionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_build`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBuildError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_deployment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDeploymentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_environment`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEnvironmentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_function`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFunctionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_function_version`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFunctionVersionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_log`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListLogError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_variable`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListVariableError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_asset`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAssetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_function`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFunctionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_variable`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateVariableError {
    UnknownValue(serde_json::Value),
}


/// Create a new Asset resource.
pub async fn create_asset(configuration: &configuration::Configuration, params: CreateAssetParams) -> Result<ResponseContent<CreateAssetSuccess>, Error<CreateAssetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Assets", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateAssetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateAssetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Build resource. At least one function version or asset version is required.
pub async fn create_build(configuration: &configuration::Configuration, params: CreateBuildParams) -> Result<ResponseContent<CreateBuildSuccess>, Error<CreateBuildError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let asset_versions = params.asset_versions;
    let dependencies = params.dependencies;
    let function_versions = params.function_versions;
    let runtime = params.runtime;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Builds", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = asset_versions {
        local_var_form_params.insert("AssetVersions", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = dependencies {
        local_var_form_params.insert("Dependencies", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = function_versions {
        local_var_form_params.insert("FunctionVersions", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = runtime {
        local_var_form_params.insert("Runtime", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateBuildSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Deployment.
pub async fn create_deployment(configuration: &configuration::Configuration, params: CreateDeploymentParams) -> Result<ResponseContent<CreateDeploymentSuccess>, Error<CreateDeploymentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let environment_sid = params.environment_sid;
    let build_sid = params.build_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Deployments", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), EnvironmentSid=crate::apis::urlencode(environment_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = build_sid {
        local_var_form_params.insert("BuildSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateDeploymentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateDeploymentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new environment.
pub async fn create_environment(configuration: &configuration::Configuration, params: CreateEnvironmentParams) -> Result<ResponseContent<CreateEnvironmentSuccess>, Error<CreateEnvironmentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let unique_name = params.unique_name;
    let domain_suffix = params.domain_suffix;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = domain_suffix {
        local_var_form_params.insert("DomainSuffix", local_var_param_value.to_string());
    }
    local_var_form_params.insert("UniqueName", unique_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateEnvironmentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateEnvironmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Function resource.
pub async fn create_function(configuration: &configuration::Configuration, params: CreateFunctionParams) -> Result<ResponseContent<CreateFunctionSuccess>, Error<CreateFunctionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Functions", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateFunctionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateFunctionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Service resource.
pub async fn create_service(configuration: &configuration::Configuration, params: CreateServiceParams) -> Result<ResponseContent<CreateServiceSuccess>, Error<CreateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let unique_name = params.unique_name;
    let include_credentials = params.include_credentials;
    let ui_editable = params.ui_editable;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = include_credentials {
        local_var_form_params.insert("IncludeCredentials", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ui_editable {
        local_var_form_params.insert("UiEditable", local_var_param_value.to_string());
    }
    local_var_form_params.insert("UniqueName", unique_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Variable.
pub async fn create_variable(configuration: &configuration::Configuration, params: CreateVariableParams) -> Result<ResponseContent<CreateVariableSuccess>, Error<CreateVariableError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let environment_sid = params.environment_sid;
    let key = params.key;
    let value = params.value;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), EnvironmentSid=crate::apis::urlencode(environment_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Key", key.to_string());
    local_var_form_params.insert("Value", value.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateVariableSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateVariableError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an Asset resource.
pub async fn delete_asset(configuration: &configuration::Configuration, params: DeleteAssetParams) -> Result<ResponseContent<DeleteAssetSuccess>, Error<DeleteAssetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Assets/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteAssetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteAssetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a Build resource.
pub async fn delete_build(configuration: &configuration::Configuration, params: DeleteBuildParams) -> Result<ResponseContent<DeleteBuildSuccess>, Error<DeleteBuildError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Builds/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteBuildSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific environment.
pub async fn delete_environment(configuration: &configuration::Configuration, params: DeleteEnvironmentParams) -> Result<ResponseContent<DeleteEnvironmentSuccess>, Error<DeleteEnvironmentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteEnvironmentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteEnvironmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a Function resource.
pub async fn delete_function(configuration: &configuration::Configuration, params: DeleteFunctionParams) -> Result<ResponseContent<DeleteFunctionSuccess>, Error<DeleteFunctionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Functions/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteFunctionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteFunctionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a Service resource.
pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<ResponseContent<DeleteServiceSuccess>, Error<DeleteServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Variable.
pub async fn delete_variable(configuration: &configuration::Configuration, params: DeleteVariableParams) -> Result<ResponseContent<DeleteVariableSuccess>, Error<DeleteVariableError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let environment_sid = params.environment_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), EnvironmentSid=crate::apis::urlencode(environment_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteVariableSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteVariableError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Asset resource.
pub async fn fetch_asset(configuration: &configuration::Configuration, params: FetchAssetParams) -> Result<ResponseContent<FetchAssetSuccess>, Error<FetchAssetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Assets/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchAssetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchAssetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Asset Version.
pub async fn fetch_asset_version(configuration: &configuration::Configuration, params: FetchAssetVersionParams) -> Result<ResponseContent<FetchAssetVersionSuccess>, Error<FetchAssetVersionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let asset_sid = params.asset_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Assets/{AssetSid}/Versions/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), AssetSid=crate::apis::urlencode(asset_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchAssetVersionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchAssetVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Build resource.
pub async fn fetch_build(configuration: &configuration::Configuration, params: FetchBuildParams) -> Result<ResponseContent<FetchBuildSuccess>, Error<FetchBuildError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Builds/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchBuildSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Build resource.
pub async fn fetch_build_status(configuration: &configuration::Configuration, params: FetchBuildStatusParams) -> Result<ResponseContent<FetchBuildStatusSuccess>, Error<FetchBuildStatusError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Builds/{Sid}/Status", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchBuildStatusSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchBuildStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Deployment.
pub async fn fetch_deployment(configuration: &configuration::Configuration, params: FetchDeploymentParams) -> Result<ResponseContent<FetchDeploymentSuccess>, Error<FetchDeploymentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let environment_sid = params.environment_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Deployments/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), EnvironmentSid=crate::apis::urlencode(environment_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchDeploymentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchDeploymentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific environment.
pub async fn fetch_environment(configuration: &configuration::Configuration, params: FetchEnvironmentParams) -> Result<ResponseContent<FetchEnvironmentSuccess>, Error<FetchEnvironmentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchEnvironmentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchEnvironmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Function resource.
pub async fn fetch_function(configuration: &configuration::Configuration, params: FetchFunctionParams) -> Result<ResponseContent<FetchFunctionSuccess>, Error<FetchFunctionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Functions/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFunctionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFunctionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Function Version resource.
pub async fn fetch_function_version(configuration: &configuration::Configuration, params: FetchFunctionVersionParams) -> Result<ResponseContent<FetchFunctionVersionSuccess>, Error<FetchFunctionVersionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let function_sid = params.function_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Functions/{FunctionSid}/Versions/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), FunctionSid=crate::apis::urlencode(function_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFunctionVersionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFunctionVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a the content of a specific Function Version resource.
pub async fn fetch_function_version_content(configuration: &configuration::Configuration, params: FetchFunctionVersionContentParams) -> Result<ResponseContent<FetchFunctionVersionContentSuccess>, Error<FetchFunctionVersionContentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let function_sid = params.function_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Functions/{FunctionSid}/Versions/{Sid}/Content", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), FunctionSid=crate::apis::urlencode(function_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFunctionVersionContentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFunctionVersionContentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific log.
pub async fn fetch_log(configuration: &configuration::Configuration, params: FetchLogParams) -> Result<ResponseContent<FetchLogSuccess>, Error<FetchLogError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let environment_sid = params.environment_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Logs/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), EnvironmentSid=crate::apis::urlencode(environment_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchLogSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchLogError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Service resource.
pub async fn fetch_service(configuration: &configuration::Configuration, params: FetchServiceParams) -> Result<ResponseContent<FetchServiceSuccess>, Error<FetchServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Variable.
pub async fn fetch_variable(configuration: &configuration::Configuration, params: FetchVariableParams) -> Result<ResponseContent<FetchVariableSuccess>, Error<FetchVariableError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let environment_sid = params.environment_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), EnvironmentSid=crate::apis::urlencode(environment_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchVariableSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchVariableError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Assets.
pub async fn list_asset(configuration: &configuration::Configuration, params: ListAssetParams) -> Result<ResponseContent<ListAssetSuccess>, Error<ListAssetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Assets", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAssetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAssetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Asset Versions.
pub async fn list_asset_version(configuration: &configuration::Configuration, params: ListAssetVersionParams) -> Result<ResponseContent<ListAssetVersionSuccess>, Error<ListAssetVersionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let asset_sid = params.asset_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Assets/{AssetSid}/Versions", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), AssetSid=crate::apis::urlencode(asset_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAssetVersionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAssetVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Builds.
pub async fn list_build(configuration: &configuration::Configuration, params: ListBuildParams) -> Result<ResponseContent<ListBuildSuccess>, Error<ListBuildError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Builds", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListBuildSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListBuildError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Deployments.
pub async fn list_deployment(configuration: &configuration::Configuration, params: ListDeploymentParams) -> Result<ResponseContent<ListDeploymentSuccess>, Error<ListDeploymentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let environment_sid = params.environment_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Deployments", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), EnvironmentSid=crate::apis::urlencode(environment_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListDeploymentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListDeploymentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all environments.
pub async fn list_environment(configuration: &configuration::Configuration, params: ListEnvironmentParams) -> Result<ResponseContent<ListEnvironmentSuccess>, Error<ListEnvironmentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListEnvironmentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListEnvironmentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Functions.
pub async fn list_function(configuration: &configuration::Configuration, params: ListFunctionParams) -> Result<ResponseContent<ListFunctionSuccess>, Error<ListFunctionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Functions", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFunctionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFunctionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Function Version resources.
pub async fn list_function_version(configuration: &configuration::Configuration, params: ListFunctionVersionParams) -> Result<ResponseContent<ListFunctionVersionSuccess>, Error<ListFunctionVersionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let function_sid = params.function_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Functions/{FunctionSid}/Versions", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), FunctionSid=crate::apis::urlencode(function_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFunctionVersionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFunctionVersionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all logs.
pub async fn list_log(configuration: &configuration::Configuration, params: ListLogParams) -> Result<ResponseContent<ListLogSuccess>, Error<ListLogError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let environment_sid = params.environment_sid;
    let function_sid = params.function_sid;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Logs", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), EnvironmentSid=crate::apis::urlencode(environment_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = function_sid {
        local_var_req_builder = local_var_req_builder.query(&[("FunctionSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListLogSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListLogError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Services.
pub async fn list_service(configuration: &configuration::Configuration, params: ListServiceParams) -> Result<ResponseContent<ListServiceSuccess>, Error<ListServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Variables.
pub async fn list_variable(configuration: &configuration::Configuration, params: ListVariableParams) -> Result<ResponseContent<ListVariableSuccess>, Error<ListVariableError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let environment_sid = params.environment_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), EnvironmentSid=crate::apis::urlencode(environment_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListVariableSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListVariableError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Asset resource.
pub async fn update_asset(configuration: &configuration::Configuration, params: UpdateAssetParams) -> Result<ResponseContent<UpdateAssetSuccess>, Error<UpdateAssetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Assets/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateAssetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateAssetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Function resource.
pub async fn update_function(configuration: &configuration::Configuration, params: UpdateFunctionParams) -> Result<ResponseContent<UpdateFunctionSuccess>, Error<UpdateFunctionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Functions/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateFunctionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateFunctionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Service resource.
pub async fn update_service(configuration: &configuration::Configuration, params: UpdateServiceParams) -> Result<ResponseContent<UpdateServiceSuccess>, Error<UpdateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let friendly_name = params.friendly_name;
    let include_credentials = params.include_credentials;
    let ui_editable = params.ui_editable;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = include_credentials {
        local_var_form_params.insert("IncludeCredentials", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ui_editable {
        local_var_form_params.insert("UiEditable", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Variable.
pub async fn update_variable(configuration: &configuration::Configuration, params: UpdateVariableParams) -> Result<ResponseContent<UpdateVariableSuccess>, Error<UpdateVariableError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let environment_sid = params.environment_sid;
    let sid = params.sid;
    let key = params.key;
    let value = params.value;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), EnvironmentSid=crate::apis::urlencode(environment_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = key {
        local_var_form_params.insert("Key", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = value {
        local_var_form_params.insert("Value", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateVariableSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateVariableError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

