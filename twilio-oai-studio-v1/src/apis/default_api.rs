/*
 * Twilio - Studio
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.2
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_engagement`
#[derive(Clone, Debug, Default)]
pub struct CreateEngagementParams {
    /// The SID of the Flow.
    pub flow_sid: String,
    /// The Twilio phone number to send messages or initiate calls from during the Flow Engagement. Available as variable `{{flow.channel.address}}`
    pub from: String,
    /// The Contact phone number to start a Studio Flow Engagement, available as variable `{{contact.channel.address}}`.
    pub to: String,
    /// A JSON string we will add to your flow's context and that you can access as variables inside your flow. For example, if you pass in `Parameters={'name':'Zeke'}` then inside a widget you can reference the variable `{{flow.data.name}}` which will return the string 'Zeke'. Note: the JSON value must explicitly be passed as a string, not as a hash object. Depending on your particular HTTP library, you may need to add quotes or URL encode your JSON string.
    pub parameters: Option<serde_json::Value>
}

/// struct for passing parameters to the method `create_execution`
#[derive(Clone, Debug, Default)]
pub struct CreateExecutionParams {
    /// The SID of the Excecution's Flow.
    pub flow_sid: String,
    /// The Twilio phone number to send messages or initiate calls from during the Flow's Execution. Available as variable `{{flow.channel.address}}`. For SMS, this can also be a Messaging Service SID.
    pub from: String,
    /// The Contact phone number to start a Studio Flow Execution, available as variable `{{contact.channel.address}}`.
    pub to: String,
    /// JSON data that will be added to the Flow's context and that can be accessed as variables inside your Flow. For example, if you pass in `Parameters={\\\"name\\\":\\\"Zeke\\\"}`, a widget in your Flow can reference the variable `{{flow.data.name}}`, which returns \\\"Zeke\\\". Note: the JSON value must explicitly be passed as a string, not as a hash object. Depending on your particular HTTP library, you may need to add quotes or URL encode the JSON string.
    pub parameters: Option<serde_json::Value>
}

/// struct for passing parameters to the method `delete_engagement`
#[derive(Clone, Debug, Default)]
pub struct DeleteEngagementParams {
    /// The SID of the Flow to delete Engagements from.
    pub flow_sid: String,
    /// The SID of the Engagement resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_execution`
#[derive(Clone, Debug, Default)]
pub struct DeleteExecutionParams {
    /// The SID of the Flow with the Execution resources to delete.
    pub flow_sid: String,
    /// The SID of the Execution resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_flow`
#[derive(Clone, Debug, Default)]
pub struct DeleteFlowParams {
    /// The SID of the Flow resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_engagement`
#[derive(Clone, Debug, Default)]
pub struct FetchEngagementParams {
    /// The SID of the Flow.
    pub flow_sid: String,
    /// The SID of the Engagement resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_engagement_context`
#[derive(Clone, Debug, Default)]
pub struct FetchEngagementContextParams {
    /// The SID of the Flow.
    pub flow_sid: String,
    /// The SID of the Engagement.
    pub engagement_sid: String
}

/// struct for passing parameters to the method `fetch_execution`
#[derive(Clone, Debug, Default)]
pub struct FetchExecutionParams {
    /// The SID of the Flow with the Execution resource to fetch
    pub flow_sid: String,
    /// The SID of the Execution resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_execution_context`
#[derive(Clone, Debug, Default)]
pub struct FetchExecutionContextParams {
    /// The SID of the Flow with the Execution context to fetch.
    pub flow_sid: String,
    /// The SID of the Execution context to fetch.
    pub execution_sid: String
}

/// struct for passing parameters to the method `fetch_execution_step`
#[derive(Clone, Debug, Default)]
pub struct FetchExecutionStepParams {
    /// The SID of the Flow with the Step to fetch.
    pub flow_sid: String,
    /// The SID of the Execution resource with the Step to fetch.
    pub execution_sid: String,
    /// The SID of the ExecutionStep resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_execution_step_context`
#[derive(Clone, Debug, Default)]
pub struct FetchExecutionStepContextParams {
    /// The SID of the Flow with the Step to fetch.
    pub flow_sid: String,
    /// The SID of the Execution resource with the Step to fetch.
    pub execution_sid: String,
    /// The SID of the Step to fetch.
    pub step_sid: String
}

/// struct for passing parameters to the method `fetch_flow`
#[derive(Clone, Debug, Default)]
pub struct FetchFlowParams {
    /// The SID of the Flow resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_step`
#[derive(Clone, Debug, Default)]
pub struct FetchStepParams {
    /// The SID of the Flow with the Step to fetch.
    pub flow_sid: String,
    /// The SID of the Engagement with the Step to fetch.
    pub engagement_sid: String,
    /// The SID of the Step resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_step_context`
#[derive(Clone, Debug, Default)]
pub struct FetchStepContextParams {
    /// The SID of the Flow with the Step to fetch.
    pub flow_sid: String,
    /// The SID of the Engagement with the Step to fetch.
    pub engagement_sid: String,
    /// The SID of the Step to fetch
    pub step_sid: String
}

/// struct for passing parameters to the method `list_engagement`
#[derive(Clone, Debug, Default)]
pub struct ListEngagementParams {
    /// The SID of the Flow to read Engagements from.
    pub flow_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_execution`
#[derive(Clone, Debug, Default)]
pub struct ListExecutionParams {
    /// The SID of the Flow with the Execution resources to read.
    pub flow_sid: String,
    /// Only show Execution resources starting on or after this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time, given as `YYYY-MM-DDThh:mm:ss-hh:mm`.
    pub date_created_from: Option<String>,
    /// Only show Execution resources starting before this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time, given as `YYYY-MM-DDThh:mm:ss-hh:mm`.
    pub date_created_to: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_execution_step`
#[derive(Clone, Debug, Default)]
pub struct ListExecutionStepParams {
    /// The SID of the Flow with the Steps to read.
    pub flow_sid: String,
    /// The SID of the Execution with the Steps to read.
    pub execution_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_flow`
#[derive(Clone, Debug, Default)]
pub struct ListFlowParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_step`
#[derive(Clone, Debug, Default)]
pub struct ListStepParams {
    /// The SID of the Flow with the Step to read.
    pub flow_sid: String,
    /// The SID of the Engagement with the Step to read.
    pub engagement_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_execution`
#[derive(Clone, Debug, Default)]
pub struct UpdateExecutionParams {
    /// The SID of the Flow with the Execution resources to update.
    pub flow_sid: String,
    /// The SID of the Execution resource to update.
    pub sid: String,
    /// The status of the Execution. Can only be `ended`.
    pub status: String
}


/// struct for typed successes of method `create_engagement`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEngagementSuccess {
    Status201(crate::models::StudioV1FlowEngagement),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateExecutionSuccess {
    Status201(crate::models::StudioV1FlowExecution),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_engagement`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEngagementSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteExecutionSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFlowSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_engagement`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEngagementSuccess {
    Status200(crate::models::StudioV1FlowEngagement),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_engagement_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEngagementContextSuccess {
    Status200(crate::models::StudioV1FlowEngagementEngagementContext),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionSuccess {
    Status200(crate::models::StudioV1FlowExecution),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_execution_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionContextSuccess {
    Status200(crate::models::StudioV1FlowExecutionExecutionContext),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_execution_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionStepSuccess {
    Status200(crate::models::StudioV1FlowExecutionExecutionStep),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_execution_step_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionStepContextSuccess {
    Status200(crate::models::StudioV1FlowExecutionExecutionStepExecutionStepContext),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFlowSuccess {
    Status200(crate::models::StudioV1Flow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchStepSuccess {
    Status200(crate::models::StudioV1FlowEngagementStep),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_step_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchStepContextSuccess {
    Status200(crate::models::StudioV1FlowEngagementStepStepContext),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_engagement`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEngagementSuccess {
    Status200(crate::models::ListEngagementResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExecutionSuccess {
    Status200(crate::models::ListExecutionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_execution_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExecutionStepSuccess {
    Status200(crate::models::ListExecutionStepResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFlowSuccess {
    Status200(crate::models::ListFlowResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListStepSuccess {
    Status200(crate::models::ListStepResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateExecutionSuccess {
    Status200(crate::models::StudioV1FlowExecution),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_engagement`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEngagementError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateExecutionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_engagement`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEngagementError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteExecutionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_engagement`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEngagementError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_engagement_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEngagementContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_execution_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_execution_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionStepError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_execution_step_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionStepContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchStepError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_step_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchStepContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_engagement`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEngagementError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExecutionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_execution_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExecutionStepError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListStepError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateExecutionError {
    UnknownValue(serde_json::Value),
}


/// Triggers a new Engagement for the Flow
pub async fn create_engagement(configuration: &configuration::Configuration, params: CreateEngagementParams) -> Result<ResponseContent<CreateEngagementSuccess>, Error<CreateEngagementError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let from = params.from;
    let to = params.to;
    let parameters = params.parameters;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Engagements", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("From", from.to_string());
    if let Some(local_var_param_value) = parameters {
        local_var_form_params.insert("Parameters", local_var_param_value.to_string());
    }
    local_var_form_params.insert("To", to.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateEngagementSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateEngagementError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Triggers a new Execution for the Flow
pub async fn create_execution(configuration: &configuration::Configuration, params: CreateExecutionParams) -> Result<ResponseContent<CreateExecutionSuccess>, Error<CreateExecutionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let from = params.from;
    let to = params.to;
    let parameters = params.parameters;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Executions", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("From", from.to_string());
    if let Some(local_var_param_value) = parameters {
        local_var_form_params.insert("Parameters", local_var_param_value.to_string());
    }
    local_var_form_params.insert("To", to.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateExecutionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateExecutionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete this Engagement and all Steps relating to it.
pub async fn delete_engagement(configuration: &configuration::Configuration, params: DeleteEngagementParams) -> Result<ResponseContent<DeleteEngagementSuccess>, Error<DeleteEngagementError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Engagements/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteEngagementSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteEngagementError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete the Execution and all Steps relating to it.
pub async fn delete_execution(configuration: &configuration::Configuration, params: DeleteExecutionParams) -> Result<ResponseContent<DeleteExecutionSuccess>, Error<DeleteExecutionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Executions/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteExecutionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteExecutionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Flow.
pub async fn delete_flow(configuration: &configuration::Configuration, params: DeleteFlowParams) -> Result<ResponseContent<DeleteFlowSuccess>, Error<DeleteFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve an Engagement
pub async fn fetch_engagement(configuration: &configuration::Configuration, params: FetchEngagementParams) -> Result<ResponseContent<FetchEngagementSuccess>, Error<FetchEngagementError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Engagements/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchEngagementSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchEngagementError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the most recent context for an Engagement.
pub async fn fetch_engagement_context(configuration: &configuration::Configuration, params: FetchEngagementContextParams) -> Result<ResponseContent<FetchEngagementContextSuccess>, Error<FetchEngagementContextError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let engagement_sid = params.engagement_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Context", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), EngagementSid=crate::apis::urlencode(engagement_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchEngagementContextSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchEngagementContextError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve an Execution
pub async fn fetch_execution(configuration: &configuration::Configuration, params: FetchExecutionParams) -> Result<ResponseContent<FetchExecutionSuccess>, Error<FetchExecutionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Executions/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchExecutionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchExecutionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the most recent context for an Execution.
pub async fn fetch_execution_context(configuration: &configuration::Configuration, params: FetchExecutionContextParams) -> Result<ResponseContent<FetchExecutionContextSuccess>, Error<FetchExecutionContextError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let execution_sid = params.execution_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Context", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), ExecutionSid=crate::apis::urlencode(execution_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchExecutionContextSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchExecutionContextError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a Step.
pub async fn fetch_execution_step(configuration: &configuration::Configuration, params: FetchExecutionStepParams) -> Result<ResponseContent<FetchExecutionStepSuccess>, Error<FetchExecutionStepError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let execution_sid = params.execution_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), ExecutionSid=crate::apis::urlencode(execution_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchExecutionStepSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchExecutionStepError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the context for an Execution Step.
pub async fn fetch_execution_step_context(configuration: &configuration::Configuration, params: FetchExecutionStepContextParams) -> Result<ResponseContent<FetchExecutionStepContextSuccess>, Error<FetchExecutionStepContextError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let execution_sid = params.execution_sid;
    let step_sid = params.step_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{StepSid}/Context", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), ExecutionSid=crate::apis::urlencode(execution_sid), StepSid=crate::apis::urlencode(step_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchExecutionStepContextSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchExecutionStepContextError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Flow.
pub async fn fetch_flow(configuration: &configuration::Configuration, params: FetchFlowParams) -> Result<ResponseContent<FetchFlowSuccess>, Error<FetchFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a Step.
pub async fn fetch_step(configuration: &configuration::Configuration, params: FetchStepParams) -> Result<ResponseContent<FetchStepSuccess>, Error<FetchStepError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let engagement_sid = params.engagement_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Steps/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), EngagementSid=crate::apis::urlencode(engagement_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchStepSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchStepError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the context for an Engagement Step.
pub async fn fetch_step_context(configuration: &configuration::Configuration, params: FetchStepContextParams) -> Result<ResponseContent<FetchStepContextSuccess>, Error<FetchStepContextError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let engagement_sid = params.engagement_sid;
    let step_sid = params.step_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Steps/{StepSid}/Context", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), EngagementSid=crate::apis::urlencode(engagement_sid), StepSid=crate::apis::urlencode(step_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchStepContextSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchStepContextError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Engagements for the Flow.
pub async fn list_engagement(configuration: &configuration::Configuration, params: ListEngagementParams) -> Result<ResponseContent<ListEngagementSuccess>, Error<ListEngagementError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Engagements", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListEngagementSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListEngagementError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Executions for the Flow.
pub async fn list_execution(configuration: &configuration::Configuration, params: ListExecutionParams) -> Result<ResponseContent<ListExecutionSuccess>, Error<ListExecutionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let date_created_from = params.date_created_from;
    let date_created_to = params.date_created_to;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Executions", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = date_created_from {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreatedFrom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_to {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreatedTo", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListExecutionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListExecutionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Steps for an Execution.
pub async fn list_execution_step(configuration: &configuration::Configuration, params: ListExecutionStepParams) -> Result<ResponseContent<ListExecutionStepSuccess>, Error<ListExecutionStepError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let execution_sid = params.execution_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), ExecutionSid=crate::apis::urlencode(execution_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListExecutionStepSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListExecutionStepError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Flows.
pub async fn list_flow(configuration: &configuration::Configuration, params: ListFlowParams) -> Result<ResponseContent<ListFlowSuccess>, Error<ListFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Steps for an Engagement.
pub async fn list_step(configuration: &configuration::Configuration, params: ListStepParams) -> Result<ResponseContent<ListStepSuccess>, Error<ListStepError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let engagement_sid = params.engagement_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Steps", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), EngagementSid=crate::apis::urlencode(engagement_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListStepSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListStepError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the status of an Execution to `ended`.
pub async fn update_execution(configuration: &configuration::Configuration, params: UpdateExecutionParams) -> Result<ResponseContent<UpdateExecutionSuccess>, Error<UpdateExecutionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let sid = params.sid;
    let status = params.status;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Flows/{FlowSid}/Executions/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateExecutionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateExecutionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

