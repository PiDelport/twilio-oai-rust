/*
 * Twilio - Studio
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_execution`
#[derive(Clone, Debug, Default)]
pub struct CreateExecutionParams {
    /// The SID of the Excecution's Flow.
    pub flow_sid: String,
    /// The Twilio phone number to send messages or initiate calls from during the Flow's Execution. Available as variable `{{flow.channel.address}}`. For SMS, this can also be a Messaging Service SID.
    pub from: String,
    /// The Contact phone number to start a Studio Flow Execution, available as variable `{{contact.channel.address}}`.
    pub to: String,
    /// JSON data that will be added to the Flow's context and that can be accessed as variables inside your Flow. For example, if you pass in `Parameters={\\\"name\\\":\\\"Zeke\\\"}`, a widget in your Flow can reference the variable `{{flow.data.name}}`, which returns \\\"Zeke\\\". Note: the JSON value must explicitly be passed as a string, not as a hash object. Depending on your particular HTTP library, you may need to add quotes or URL encode the JSON string.
    pub parameters: Option<serde_json::Value>
}

/// struct for passing parameters to the method `create_flow`
#[derive(Clone, Debug, Default)]
pub struct CreateFlowParams {
    /// JSON representation of flow definition.
    pub definition: serde_json::Value,
    /// The string that you assigned to describe the Flow.
    pub friendly_name: String,
    /// The status of the Flow. Can be: `draft` or `published`.
    pub status: String,
    /// Description of change made in the revision.
    pub commit_message: Option<String>
}

/// struct for passing parameters to the method `delete_execution`
#[derive(Clone, Debug, Default)]
pub struct DeleteExecutionParams {
    /// The SID of the Flow with the Execution resources to delete.
    pub flow_sid: String,
    /// The SID of the Execution resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_flow`
#[derive(Clone, Debug, Default)]
pub struct DeleteFlowParams {
    /// The SID of the Flow resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_execution`
#[derive(Clone, Debug, Default)]
pub struct FetchExecutionParams {
    /// The SID of the Flow with the Execution resource to fetch
    pub flow_sid: String,
    /// The SID of the Execution resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_execution_context`
#[derive(Clone, Debug, Default)]
pub struct FetchExecutionContextParams {
    /// The SID of the Flow with the Execution context to fetch.
    pub flow_sid: String,
    /// The SID of the Execution context to fetch.
    pub execution_sid: String
}

/// struct for passing parameters to the method `fetch_execution_step`
#[derive(Clone, Debug, Default)]
pub struct FetchExecutionStepParams {
    /// The SID of the Flow with the Step to fetch.
    pub flow_sid: String,
    /// The SID of the Execution resource with the Step to fetch.
    pub execution_sid: String,
    /// The SID of the ExecutionStep resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_execution_step_context`
#[derive(Clone, Debug, Default)]
pub struct FetchExecutionStepContextParams {
    /// The SID of the Flow with the Step to fetch.
    pub flow_sid: String,
    /// The SID of the Execution resource with the Step to fetch.
    pub execution_sid: String,
    /// The SID of the Step to fetch.
    pub step_sid: String
}

/// struct for passing parameters to the method `fetch_flow`
#[derive(Clone, Debug, Default)]
pub struct FetchFlowParams {
    /// The SID of the Flow resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_flow_revision`
#[derive(Clone, Debug, Default)]
pub struct FetchFlowRevisionParams {
    /// The SID of the Flow resource to fetch.
    pub sid: String,
    /// Specific Revision number or can be `LatestPublished` and `LatestRevision`.
    pub revision: String
}

/// struct for passing parameters to the method `fetch_test_user`
#[derive(Clone, Debug, Default)]
pub struct FetchTestUserParams {
    /// Unique identifier of the flow.
    pub sid: String
}

/// struct for passing parameters to the method `list_execution`
#[derive(Clone, Debug, Default)]
pub struct ListExecutionParams {
    /// The SID of the Flow with the Execution resources to read.
    pub flow_sid: String,
    /// Only show Execution resources starting on or after this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time, given as `YYYY-MM-DDThh:mm:ss-hh:mm`.
    pub date_created_from: Option<String>,
    /// Only show Execution resources starting before this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time, given as `YYYY-MM-DDThh:mm:ss-hh:mm`.
    pub date_created_to: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_execution_step`
#[derive(Clone, Debug, Default)]
pub struct ListExecutionStepParams {
    /// The SID of the Flow with the Steps to read.
    pub flow_sid: String,
    /// The SID of the Execution with the Steps to read.
    pub execution_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_flow`
#[derive(Clone, Debug, Default)]
pub struct ListFlowParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_flow_revision`
#[derive(Clone, Debug, Default)]
pub struct ListFlowRevisionParams {
    /// The SID of the Flow resource to fetch.
    pub sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_execution`
#[derive(Clone, Debug, Default)]
pub struct UpdateExecutionParams {
    /// The SID of the Flow with the Execution resources to update.
    pub flow_sid: String,
    /// The SID of the Execution resource to update.
    pub sid: String,
    /// The status of the Execution. Can only be `ended`.
    pub status: String
}

/// struct for passing parameters to the method `update_flow`
#[derive(Clone, Debug, Default)]
pub struct UpdateFlowParams {
    /// The SID of the Flow resource to fetch.
    pub sid: String,
    /// The status of the Flow. Can be: `draft` or `published`.
    pub status: String,
    /// Description of change made in the revision.
    pub commit_message: Option<String>,
    /// JSON representation of flow definition.
    pub definition: Option<serde_json::Value>,
    /// The string that you assigned to describe the Flow.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `update_flow_validate`
#[derive(Clone, Debug, Default)]
pub struct UpdateFlowValidateParams {
    /// JSON representation of flow definition.
    pub definition: serde_json::Value,
    /// The string that you assigned to describe the Flow.
    pub friendly_name: String,
    /// The status of the Flow. Can be: `draft` or `published`.
    pub status: String,
    /// Description of change made in the revision.
    pub commit_message: Option<String>
}

/// struct for passing parameters to the method `update_test_user`
#[derive(Clone, Debug, Default)]
pub struct UpdateTestUserParams {
    /// Unique identifier of the flow.
    pub sid: String,
    /// List of test user identities that can test draft versions of the flow.
    pub test_users: Vec<String>
}


/// struct for typed successes of method `create_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateExecutionSuccess {
    Status201(crate::models::StudioV2FlowExecution),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFlowSuccess {
    Status201(crate::models::StudioV2Flow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteExecutionSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFlowSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionSuccess {
    Status200(crate::models::StudioV2FlowExecution),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_execution_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionContextSuccess {
    Status200(crate::models::StudioV2FlowExecutionExecutionContext),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_execution_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionStepSuccess {
    Status200(crate::models::StudioV2FlowExecutionExecutionStep),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_execution_step_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionStepContextSuccess {
    Status200(crate::models::StudioV2FlowExecutionExecutionStepExecutionStepContext),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFlowSuccess {
    Status200(crate::models::StudioV2Flow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_flow_revision`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFlowRevisionSuccess {
    Status200(crate::models::StudioV2FlowFlowRevision),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_test_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTestUserSuccess {
    Status200(crate::models::StudioV2FlowTestUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExecutionSuccess {
    Status200(crate::models::ListExecutionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_execution_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExecutionStepSuccess {
    Status200(crate::models::ListExecutionStepResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFlowSuccess {
    Status200(crate::models::ListFlowResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_flow_revision`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFlowRevisionSuccess {
    Status200(crate::models::ListFlowRevisionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateExecutionSuccess {
    Status200(crate::models::StudioV2FlowExecution),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFlowSuccess {
    Status200(crate::models::StudioV2Flow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_flow_validate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFlowValidateSuccess {
    Status200(crate::models::StudioV2FlowValidate),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_test_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTestUserSuccess {
    Status200(crate::models::StudioV2FlowTestUser),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateExecutionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteExecutionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_execution_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_execution_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionStepError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_execution_step_context`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchExecutionStepContextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_flow_revision`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFlowRevisionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_test_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTestUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExecutionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_execution_step`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExecutionStepError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_flow_revision`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFlowRevisionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_execution`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateExecutionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_flow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFlowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_flow_validate`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFlowValidateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_test_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTestUserError {
    UnknownValue(serde_json::Value),
}


/// Triggers a new Execution for the Flow
pub async fn create_execution(configuration: &configuration::Configuration, params: CreateExecutionParams) -> Result<ResponseContent<CreateExecutionSuccess>, Error<CreateExecutionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let from = params.from;
    let to = params.to;
    let parameters = params.parameters;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{FlowSid}/Executions", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("From", from.to_string());
    if let Some(local_var_param_value) = parameters {
        local_var_form_params.insert("Parameters", local_var_param_value.to_string());
    }
    local_var_form_params.insert("To", to.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateExecutionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateExecutionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a Flow.
pub async fn create_flow(configuration: &configuration::Configuration, params: CreateFlowParams) -> Result<ResponseContent<CreateFlowSuccess>, Error<CreateFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let definition = params.definition;
    let friendly_name = params.friendly_name;
    let status = params.status;
    let commit_message = params.commit_message;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = commit_message {
        local_var_form_params.insert("CommitMessage", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Definition", definition.to_string());
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete the Execution and all Steps relating to it.
pub async fn delete_execution(configuration: &configuration::Configuration, params: DeleteExecutionParams) -> Result<ResponseContent<DeleteExecutionSuccess>, Error<DeleteExecutionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{FlowSid}/Executions/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteExecutionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteExecutionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Flow.
pub async fn delete_flow(configuration: &configuration::Configuration, params: DeleteFlowParams) -> Result<ResponseContent<DeleteFlowSuccess>, Error<DeleteFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve an Execution
pub async fn fetch_execution(configuration: &configuration::Configuration, params: FetchExecutionParams) -> Result<ResponseContent<FetchExecutionSuccess>, Error<FetchExecutionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{FlowSid}/Executions/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchExecutionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchExecutionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the most recent context for an Execution.
pub async fn fetch_execution_context(configuration: &configuration::Configuration, params: FetchExecutionContextParams) -> Result<ResponseContent<FetchExecutionContextSuccess>, Error<FetchExecutionContextError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let execution_sid = params.execution_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Context", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), ExecutionSid=crate::apis::urlencode(execution_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchExecutionContextSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchExecutionContextError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a Step.
pub async fn fetch_execution_step(configuration: &configuration::Configuration, params: FetchExecutionStepParams) -> Result<ResponseContent<FetchExecutionStepSuccess>, Error<FetchExecutionStepError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let execution_sid = params.execution_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), ExecutionSid=crate::apis::urlencode(execution_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchExecutionStepSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchExecutionStepError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the context for an Execution Step.
pub async fn fetch_execution_step_context(configuration: &configuration::Configuration, params: FetchExecutionStepContextParams) -> Result<ResponseContent<FetchExecutionStepContextSuccess>, Error<FetchExecutionStepContextError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let execution_sid = params.execution_sid;
    let step_sid = params.step_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{StepSid}/Context", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), ExecutionSid=crate::apis::urlencode(execution_sid), StepSid=crate::apis::urlencode(step_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchExecutionStepContextSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchExecutionStepContextError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Flow.
pub async fn fetch_flow(configuration: &configuration::Configuration, params: FetchFlowParams) -> Result<ResponseContent<FetchFlowSuccess>, Error<FetchFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a specific Flow revision.
pub async fn fetch_flow_revision(configuration: &configuration::Configuration, params: FetchFlowRevisionParams) -> Result<ResponseContent<FetchFlowRevisionSuccess>, Error<FetchFlowRevisionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let revision = params.revision;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{Sid}/Revisions/{Revision}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid), Revision=crate::apis::urlencode(revision));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFlowRevisionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFlowRevisionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch flow test users
pub async fn fetch_test_user(configuration: &configuration::Configuration, params: FetchTestUserParams) -> Result<ResponseContent<FetchTestUserSuccess>, Error<FetchTestUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{Sid}/TestUsers", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTestUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTestUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Executions for the Flow.
pub async fn list_execution(configuration: &configuration::Configuration, params: ListExecutionParams) -> Result<ResponseContent<ListExecutionSuccess>, Error<ListExecutionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let date_created_from = params.date_created_from;
    let date_created_to = params.date_created_to;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{FlowSid}/Executions", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = date_created_from {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreatedFrom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_to {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreatedTo", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListExecutionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListExecutionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Steps for an Execution.
pub async fn list_execution_step(configuration: &configuration::Configuration, params: ListExecutionStepParams) -> Result<ResponseContent<ListExecutionStepSuccess>, Error<ListExecutionStepError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let execution_sid = params.execution_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), ExecutionSid=crate::apis::urlencode(execution_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListExecutionStepSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListExecutionStepError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Flows.
pub async fn list_flow(configuration: &configuration::Configuration, params: ListFlowParams) -> Result<ResponseContent<ListFlowSuccess>, Error<ListFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Flows revisions.
pub async fn list_flow_revision(configuration: &configuration::Configuration, params: ListFlowRevisionParams) -> Result<ResponseContent<ListFlowRevisionSuccess>, Error<ListFlowRevisionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{Sid}/Revisions", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFlowRevisionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFlowRevisionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the status of an Execution to `ended`.
pub async fn update_execution(configuration: &configuration::Configuration, params: UpdateExecutionParams) -> Result<ResponseContent<UpdateExecutionSuccess>, Error<UpdateExecutionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let flow_sid = params.flow_sid;
    let sid = params.sid;
    let status = params.status;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{FlowSid}/Executions/{Sid}", local_var_configuration.base_path, FlowSid=crate::apis::urlencode(flow_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateExecutionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateExecutionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a Flow.
pub async fn update_flow(configuration: &configuration::Configuration, params: UpdateFlowParams) -> Result<ResponseContent<UpdateFlowSuccess>, Error<UpdateFlowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let status = params.status;
    let commit_message = params.commit_message;
    let definition = params.definition;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = commit_message {
        local_var_form_params.insert("CommitMessage", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = definition {
        local_var_form_params.insert("Definition", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateFlowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateFlowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Validate flow JSON definition
pub async fn update_flow_validate(configuration: &configuration::Configuration, params: UpdateFlowValidateParams) -> Result<ResponseContent<UpdateFlowValidateSuccess>, Error<UpdateFlowValidateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let definition = params.definition;
    let friendly_name = params.friendly_name;
    let status = params.status;
    let commit_message = params.commit_message;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/Validate", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = commit_message {
        local_var_form_params.insert("CommitMessage", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Definition", definition.to_string());
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateFlowValidateSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateFlowValidateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update flow test users
pub async fn update_test_user(configuration: &configuration::Configuration, params: UpdateTestUserParams) -> Result<ResponseContent<UpdateTestUserSuccess>, Error<UpdateTestUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let test_users = params.test_users;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Flows/{Sid}/TestUsers", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("TestUsers", test_users.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateTestUserSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateTestUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

