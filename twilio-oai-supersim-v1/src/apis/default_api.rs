/*
 * Twilio - Supersim
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.2
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_command`]
#[derive(Clone, Debug, Default)]
pub struct CreateCommandParams {
    /// The message body of the command.
    pub command: String,
    /// The `sid` or `unique_name` of the [SIM](https://www.twilio.com/docs/wireless/api/sim-resource) to send the Command to.
    pub sim: String,
    /// The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the default is POST.
    pub callback_method: Option<String>,
    /// The URL we should call using the `callback_method` after we have sent the command.
    pub callback_url: Option<String>
}

/// struct for passing parameters to the method [`create_fleet`]
#[derive(Clone, Debug, Default)]
pub struct CreateFleetParams {
    /// The SID or unique name of the Network Access Profile that will control which cellular networks the Fleet's SIMs can connect to.
    pub network_access_profile: String,
    /// Defines whether SIMs in the Fleet are capable of sending and receiving machine-to-machine SMS via Commands. Defaults to `true`.
    pub commands_enabled: Option<bool>,
    /// A string representing the HTTP method to use when making a request to `commands_url`. Can be one of `POST` or `GET`. Defaults to `POST`.
    pub commands_method: Option<String>,
    /// The URL that will receive a webhook when a Super SIM in the Fleet is used to send an SMS from your device to the Commands number. Your server should respond with an HTTP status code in the 200 range; any response body will be ignored.
    pub commands_url: Option<String>,
    /// Defines whether SIMs in the Fleet are capable of using 2G/3G/4G/LTE/CAT-M data connectivity. Defaults to `true`.
    pub data_enabled: Option<bool>,
    /// The total data usage (download and upload combined) in Megabytes that each Sim resource assigned to the Fleet resource can consume during a billing period (normally one month). Value must be between 1MB (1) and 2TB (2,000,000). Defaults to 1GB (1,000).
    pub data_limit: Option<i32>,
    /// Defines whether SIMs in the Fleet are capable of sending and receiving machine-to-machine SMS via Commands. Defaults to `true`.
    pub sms_commands_enabled: Option<bool>,
    /// A string representing the HTTP method to use when making a request to `sms_commands_url`. Can be one of `POST` or `GET`. Defaults to `POST`.
    pub sms_commands_method: Option<String>,
    /// The URL that will receive a webhook when a Super SIM in the Fleet is used to send an SMS from your device to the SMS Commands number. Your server should respond with an HTTP status code in the 200 range; any response body will be ignored.
    pub sms_commands_url: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used in place of the resource's `sid` in the URL to address the resource.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method [`create_network_access_profile`]
#[derive(Clone, Debug, Default)]
pub struct CreateNetworkAccessProfileParams {
    /// List of Network SIDs that this Network Access Profile will allow connections to.
    pub networks: Option<Vec<String>>,
    /// An application-defined string that uniquely identifies the resource. It can be used in place of the resource's `sid` in the URL to address the resource.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method [`create_network_access_profile_network`]
#[derive(Clone, Debug, Default)]
pub struct CreateNetworkAccessProfileNetworkParams {
    /// The unique string that identifies the Network Access Profile resource.
    pub network_access_profile_sid: String,
    /// The SID of the Network resource to be added to the Network Access Profile resource.
    pub network: String
}

/// struct for passing parameters to the method [`create_sim`]
#[derive(Clone, Debug, Default)]
pub struct CreateSimParams {
    /// The [ICCID](https://en.wikipedia.org/wiki/Subscriber_identity_module#ICCID) of the Super SIM to be added to your Account.
    pub iccid: String,
    /// The 10-digit code required to claim the Super SIM for your Account.
    pub registration_code: String
}

/// struct for passing parameters to the method [`create_sms_command`]
#[derive(Clone, Debug, Default)]
pub struct CreateSmsCommandParams {
    /// The message body of the SMS Command.
    pub payload: String,
    /// The `sid` or `unique_name` of the [SIM](https://www.twilio.com/docs/wireless/api/sim-resource) to send the SMS Command to.
    pub sim: String,
    /// The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the default is POST.
    pub callback_method: Option<String>,
    /// The URL we should call using the `callback_method` after we have sent the command.
    pub callback_url: Option<String>
}

/// struct for passing parameters to the method [`delete_network_access_profile_network`]
#[derive(Clone, Debug, Default)]
pub struct DeleteNetworkAccessProfileNetworkParams {
    /// The unique string that identifies the Network Access Profile resource.
    pub network_access_profile_sid: String,
    /// The SID of the Network resource to be removed from the Network Access Profile resource.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_command`]
#[derive(Clone, Debug, Default)]
pub struct FetchCommandParams {
    /// The SID of the Command resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_fleet`]
#[derive(Clone, Debug, Default)]
pub struct FetchFleetParams {
    /// The SID of the Fleet resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_network`]
#[derive(Clone, Debug, Default)]
pub struct FetchNetworkParams {
    /// The SID of the Network resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_network_access_profile`]
#[derive(Clone, Debug, Default)]
pub struct FetchNetworkAccessProfileParams {
    /// The SID of the Network Access Profile resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_network_access_profile_network`]
#[derive(Clone, Debug, Default)]
pub struct FetchNetworkAccessProfileNetworkParams {
    /// The unique string that identifies the Network Access Profile resource.
    pub network_access_profile_sid: String,
    /// The SID of the Network resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_sim`]
#[derive(Clone, Debug, Default)]
pub struct FetchSimParams {
    /// The SID of the Sim resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_sms_command`]
#[derive(Clone, Debug, Default)]
pub struct FetchSmsCommandParams {
    /// The SID of the SMS Command resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`list_billing_period`]
#[derive(Clone, Debug, Default)]
pub struct ListBillingPeriodParams {
    /// The SID of the Super SIM to list Billing Periods for.
    pub sim_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_command`]
#[derive(Clone, Debug, Default)]
pub struct ListCommandParams {
    /// The SID or unique name of the Sim that Command was sent to or from.
    pub sim: Option<String>,
    /// The status of the Command. Can be: `queued`, `sent`, `delivered`, `received` or `failed`. See the [Command Status Values](https://www.twilio.com/docs/wireless/api/command-resource#status-values) for a description of each.
    pub status: Option<String>,
    /// The direction of the Command. Can be `to_sim` or `from_sim`. The value of `to_sim` is synonymous with the term `mobile terminated`, and `from_sim` is synonymous with the term `mobile originated`.
    pub direction: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_fleet`]
#[derive(Clone, Debug, Default)]
pub struct ListFleetParams {
    /// The SID or unique name of the Network Access Profile that controls which cellular networks the Fleet's SIMs can connect to.
    pub network_access_profile: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_network`]
#[derive(Clone, Debug, Default)]
pub struct ListNetworkParams {
    /// The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the Network resources to read.
    pub iso_country: Option<String>,
    /// The 'mobile country code' of a country. Network resources with this `mcc` in their `identifiers` will be read.
    pub mcc: Option<String>,
    /// The 'mobile network code' of a mobile operator network. Network resources with this `mnc` in their `identifiers` will be read.
    pub mnc: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_network_access_profile`]
#[derive(Clone, Debug, Default)]
pub struct ListNetworkAccessProfileParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_network_access_profile_network`]
#[derive(Clone, Debug, Default)]
pub struct ListNetworkAccessProfileNetworkParams {
    /// The unique string that identifies the Network Access Profile resource.
    pub network_access_profile_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_sim`]
#[derive(Clone, Debug, Default)]
pub struct ListSimParams {
    /// The status of the Sim resources to read. Can be `new`, `ready`, `active`, `inactive`, or `scheduled`.
    pub status: Option<String>,
    /// The SID or unique name of the Fleet to which a list of Sims are assigned.
    pub fleet: Option<String>,
    /// The [ICCID](https://en.wikipedia.org/wiki/Subscriber_identity_module#ICCID) associated with a Super SIM to filter the list by. Passing this parameter will always return a list containing zero or one SIMs.
    pub iccid: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_sms_command`]
#[derive(Clone, Debug, Default)]
pub struct ListSmsCommandParams {
    /// The SID or unique name of the Sim resource that SMS Command was sent to or from.
    pub sim: Option<String>,
    /// The status of the SMS Command. Can be: `queued`, `sent`, `delivered`, `received` or `failed`. See the [SMS Command Status Values](https://www.twilio.com/docs/wireless/api/smscommand-resource#status-values) for a description of each.
    pub status: Option<String>,
    /// The direction of the SMS Command. Can be `to_sim` or `from_sim`. The value of `to_sim` is synonymous with the term `mobile terminated`, and `from_sim` is synonymous with the term `mobile originated`.
    pub direction: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_usage_record`]
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordParams {
    /// SID or unique name of a Sim resource. Only show UsageRecords representing usage incurred by this Super SIM.
    pub sim: Option<String>,
    /// SID or unique name of a Fleet resource. Only show UsageRecords representing usage for Super SIMs belonging to this Fleet resource at the time the usage occurred.
    pub fleet: Option<String>,
    /// SID of a Network resource. Only show UsageRecords representing usage on this network.
    pub network: Option<String>,
    /// Alpha-2 ISO Country Code. Only show UsageRecords representing usage in this country.
    pub iso_country: Option<String>,
    /// Dimension over which to aggregate usage records. Can be: `sim`, `fleet`, `network`, `isoCountry`. Default is to not aggregate across any of these dimensions, UsageRecords will be aggregated into the time buckets described by the `Granularity` parameter.
    pub group: Option<String>,
    /// Time-based grouping that UsageRecords should be aggregated by. Can be: `hour`, `day`, or `all`. Default is `all`. `all` returns one UsageRecord that describes the usage for the entire period.
    pub granularity: Option<String>,
    /// Only include usage that occurred at or after this time, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. Default is one month before the `end_time`.
    pub start_time: Option<String>,
    /// Only include usage that occurred before this time, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. Default is the current time.
    pub end_time: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`update_fleet`]
#[derive(Clone, Debug, Default)]
pub struct UpdateFleetParams {
    /// The SID of the Fleet resource to update.
    pub sid: String,
    /// A string representing the HTTP method to use when making a request to `commands_url`. Can be one of `POST` or `GET`. Defaults to `POST`.
    pub commands_method: Option<String>,
    /// The URL that will receive a webhook when a Super SIM in the Fleet is used to send an SMS from your device to the Commands number. Your server should respond with an HTTP status code in the 200 range; any response body will be ignored.
    pub commands_url: Option<String>,
    /// The SID or unique name of the Network Access Profile that will control which cellular networks the Fleet's SIMs can connect to.
    pub network_access_profile: Option<String>,
    /// A string representing the HTTP method to use when making a request to `sms_commands_url`. Can be one of `POST` or `GET`. Defaults to `POST`.
    pub sms_commands_method: Option<String>,
    /// The URL that will receive a webhook when a Super SIM in the Fleet is used to send an SMS from your device to the SMS Commands number. Your server should respond with an HTTP status code in the 200 range; any response body will be ignored.
    pub sms_commands_url: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used in place of the resource's `sid` in the URL to address the resource.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method [`update_network_access_profile`]
#[derive(Clone, Debug, Default)]
pub struct UpdateNetworkAccessProfileParams {
    /// The SID of the Network Access Profile to update.
    pub sid: String,
    /// The new unique name of the Network Access Profile.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method [`update_sim`]
#[derive(Clone, Debug, Default)]
pub struct UpdateSimParams {
    /// The SID of the Sim resource to update.
    pub sid: String,
    /// The SID of the Account to which the Sim resource should belong. The Account SID can only be that of the requesting Account or that of a Subaccount of the requesting Account. Only valid when the Sim resource's status is new.
    pub account_sid: Option<String>,
    /// The HTTP method we should use to call `callback_url`. Can be: `GET` or `POST` and the default is POST.
    pub callback_method: Option<String>,
    /// The URL we should call using the `callback_method` after an asynchronous update has finished.
    pub callback_url: Option<String>,
    /// The SID or unique name of the Fleet to which the SIM resource should be assigned.
    pub fleet: Option<String>,
    /// The new status of the resource. Can be: `ready`, `active`, or `inactive`. See the [Super SIM Status Values](https://www.twilio.com/docs/iot/supersim/api/sim-resource#status-values) for more info.
    pub status: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used in place of the resource's `sid` in the URL to address the resource.
    pub unique_name: Option<String>
}


/// struct for typed successes of method [`create_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCommandSuccess {
    Status201(crate::models::SupersimV1Command),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_fleet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFleetSuccess {
    Status201(crate::models::SupersimV1Fleet),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_network_access_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNetworkAccessProfileSuccess {
    Status201(crate::models::SupersimV1NetworkAccessProfile),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_network_access_profile_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNetworkAccessProfileNetworkSuccess {
    Status201(crate::models::SupersimV1NetworkAccessProfileNetworkAccessProfileNetwork),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_sim`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSimSuccess {
    Status201(crate::models::SupersimV1Sim),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_sms_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSmsCommandSuccess {
    Status201(crate::models::SupersimV1SmsCommand),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_network_access_profile_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteNetworkAccessProfileNetworkSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCommandSuccess {
    Status200(crate::models::SupersimV1Command),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_fleet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFleetSuccess {
    Status200(crate::models::SupersimV1Fleet),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchNetworkSuccess {
    Status200(crate::models::SupersimV1Network),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_network_access_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchNetworkAccessProfileSuccess {
    Status200(crate::models::SupersimV1NetworkAccessProfile),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_network_access_profile_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchNetworkAccessProfileNetworkSuccess {
    Status200(crate::models::SupersimV1NetworkAccessProfileNetworkAccessProfileNetwork),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_sim`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSimSuccess {
    Status200(crate::models::SupersimV1Sim),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_sms_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSmsCommandSuccess {
    Status200(crate::models::SupersimV1SmsCommand),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_billing_period`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBillingPeriodSuccess {
    Status200(crate::models::ListBillingPeriodResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCommandSuccess {
    Status200(crate::models::ListCommandResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_fleet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFleetSuccess {
    Status200(crate::models::ListFleetResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListNetworkSuccess {
    Status200(crate::models::ListNetworkResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_network_access_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListNetworkAccessProfileSuccess {
    Status200(crate::models::ListNetworkAccessProfileResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_network_access_profile_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListNetworkAccessProfileNetworkSuccess {
    Status200(crate::models::ListNetworkAccessProfileNetworkResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_sim`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSimSuccess {
    Status200(crate::models::ListSimResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_sms_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSmsCommandSuccess {
    Status200(crate::models::ListSmsCommandResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_usage_record`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordSuccess {
    Status200(crate::models::ListUsageRecordResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_fleet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFleetSuccess {
    Status200(crate::models::SupersimV1Fleet),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_network_access_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateNetworkAccessProfileSuccess {
    Status200(crate::models::SupersimV1NetworkAccessProfile),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_sim`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSimSuccess {
    Status200(crate::models::SupersimV1Sim),
    Status202(crate::models::SupersimV1Sim),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_fleet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFleetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_network_access_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNetworkAccessProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_network_access_profile_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNetworkAccessProfileNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sim`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSimError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sms_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSmsCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_network_access_profile_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteNetworkAccessProfileNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_fleet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFleetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_network_access_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchNetworkAccessProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_network_access_profile_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchNetworkAccessProfileNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_sim`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSimError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_sms_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSmsCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_billing_period`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBillingPeriodError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_fleet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFleetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_network_access_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListNetworkAccessProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_network_access_profile_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListNetworkAccessProfileNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_sim`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSimError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_sms_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSmsCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_usage_record`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_fleet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFleetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_network_access_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateNetworkAccessProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_sim`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSimError {
    UnknownValue(serde_json::Value),
}


/// Send a Command to a Sim.
pub async fn create_command(configuration: &configuration::Configuration, params: CreateCommandParams) -> Result<ResponseContent<CreateCommandSuccess>, Error<CreateCommandError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let command = params.command;
    let sim = params.sim;
    let callback_method = params.callback_method;
    let callback_url = params.callback_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Commands", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = callback_method {
        local_var_form_params.insert("CallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = callback_url {
        local_var_form_params.insert("CallbackUrl", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Command", command.to_string());
    local_var_form_params.insert("Sim", sim.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCommandSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCommandError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a Fleet
pub async fn create_fleet(configuration: &configuration::Configuration, params: CreateFleetParams) -> Result<ResponseContent<CreateFleetSuccess>, Error<CreateFleetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let network_access_profile = params.network_access_profile;
    let commands_enabled = params.commands_enabled;
    let commands_method = params.commands_method;
    let commands_url = params.commands_url;
    let data_enabled = params.data_enabled;
    let data_limit = params.data_limit;
    let sms_commands_enabled = params.sms_commands_enabled;
    let sms_commands_method = params.sms_commands_method;
    let sms_commands_url = params.sms_commands_url;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Fleets", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = commands_enabled {
        local_var_form_params.insert("CommandsEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = commands_method {
        local_var_form_params.insert("CommandsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = commands_url {
        local_var_form_params.insert("CommandsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = data_enabled {
        local_var_form_params.insert("DataEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = data_limit {
        local_var_form_params.insert("DataLimit", local_var_param_value.to_string());
    }
    local_var_form_params.insert("NetworkAccessProfile", network_access_profile.to_string());
    if let Some(local_var_param_value) = sms_commands_enabled {
        local_var_form_params.insert("SmsCommandsEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_commands_method {
        local_var_form_params.insert("SmsCommandsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_commands_url {
        local_var_form_params.insert("SmsCommandsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateFleetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateFleetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Network Access Profile
pub async fn create_network_access_profile(configuration: &configuration::Configuration, params: CreateNetworkAccessProfileParams) -> Result<ResponseContent<CreateNetworkAccessProfileSuccess>, Error<CreateNetworkAccessProfileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let networks = params.networks;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/NetworkAccessProfiles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = networks {
        local_var_form_params.insert("Networks", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateNetworkAccessProfileSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateNetworkAccessProfileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a Network resource to the Network Access Profile resource.
pub async fn create_network_access_profile_network(configuration: &configuration::Configuration, params: CreateNetworkAccessProfileNetworkParams) -> Result<ResponseContent<CreateNetworkAccessProfileNetworkSuccess>, Error<CreateNetworkAccessProfileNetworkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let network_access_profile_sid = params.network_access_profile_sid;
    let network = params.network;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks", local_var_configuration.base_path, NetworkAccessProfileSid=crate::apis::urlencode(network_access_profile_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Network", network.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateNetworkAccessProfileNetworkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateNetworkAccessProfileNetworkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Register a Super SIM to your Account
pub async fn create_sim(configuration: &configuration::Configuration, params: CreateSimParams) -> Result<ResponseContent<CreateSimSuccess>, Error<CreateSimError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let iccid = params.iccid;
    let registration_code = params.registration_code;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Iccid", iccid.to_string());
    local_var_form_params.insert("RegistrationCode", registration_code.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSimSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSimError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Send SMS Command to a Sim.
pub async fn create_sms_command(configuration: &configuration::Configuration, params: CreateSmsCommandParams) -> Result<ResponseContent<CreateSmsCommandSuccess>, Error<CreateSmsCommandError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let payload = params.payload;
    let sim = params.sim;
    let callback_method = params.callback_method;
    let callback_url = params.callback_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/SmsCommands", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = callback_method {
        local_var_form_params.insert("CallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = callback_url {
        local_var_form_params.insert("CallbackUrl", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Payload", payload.to_string());
    local_var_form_params.insert("Sim", sim.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSmsCommandSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSmsCommandError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a Network resource from the Network Access Profile resource's.
pub async fn delete_network_access_profile_network(configuration: &configuration::Configuration, params: DeleteNetworkAccessProfileNetworkParams) -> Result<ResponseContent<DeleteNetworkAccessProfileNetworkSuccess>, Error<DeleteNetworkAccessProfileNetworkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let network_access_profile_sid = params.network_access_profile_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks/{Sid}", local_var_configuration.base_path, NetworkAccessProfileSid=crate::apis::urlencode(network_access_profile_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteNetworkAccessProfileNetworkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteNetworkAccessProfileNetworkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a Command instance from your account.
pub async fn fetch_command(configuration: &configuration::Configuration, params: FetchCommandParams) -> Result<ResponseContent<FetchCommandSuccess>, Error<FetchCommandError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Commands/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCommandSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCommandError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a Fleet instance from your account.
pub async fn fetch_fleet(configuration: &configuration::Configuration, params: FetchFleetParams) -> Result<ResponseContent<FetchFleetSuccess>, Error<FetchFleetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Fleets/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFleetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFleetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a Network resource.
pub async fn fetch_network(configuration: &configuration::Configuration, params: FetchNetworkParams) -> Result<ResponseContent<FetchNetworkSuccess>, Error<FetchNetworkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Networks/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchNetworkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchNetworkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a Network Access Profile instance from your account.
pub async fn fetch_network_access_profile(configuration: &configuration::Configuration, params: FetchNetworkAccessProfileParams) -> Result<ResponseContent<FetchNetworkAccessProfileSuccess>, Error<FetchNetworkAccessProfileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/NetworkAccessProfiles/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchNetworkAccessProfileSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchNetworkAccessProfileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a Network Access Profile resource's Network resource.
pub async fn fetch_network_access_profile_network(configuration: &configuration::Configuration, params: FetchNetworkAccessProfileNetworkParams) -> Result<ResponseContent<FetchNetworkAccessProfileNetworkSuccess>, Error<FetchNetworkAccessProfileNetworkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let network_access_profile_sid = params.network_access_profile_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks/{Sid}", local_var_configuration.base_path, NetworkAccessProfileSid=crate::apis::urlencode(network_access_profile_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchNetworkAccessProfileNetworkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchNetworkAccessProfileNetworkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a Super SIM instance from your account.
pub async fn fetch_sim(configuration: &configuration::Configuration, params: FetchSimParams) -> Result<ResponseContent<FetchSimSuccess>, Error<FetchSimError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSimSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSimError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch SMS Command instance from your account.
pub async fn fetch_sms_command(configuration: &configuration::Configuration, params: FetchSmsCommandParams) -> Result<ResponseContent<FetchSmsCommandSuccess>, Error<FetchSmsCommandError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/SmsCommands/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSmsCommandSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSmsCommandError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Billing Periods for a Super SIM.
pub async fn list_billing_period(configuration: &configuration::Configuration, params: ListBillingPeriodParams) -> Result<ResponseContent<ListBillingPeriodSuccess>, Error<ListBillingPeriodError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sim_sid = params.sim_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims/{SimSid}/BillingPeriods", local_var_configuration.base_path, SimSid=crate::apis::urlencode(sim_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListBillingPeriodSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListBillingPeriodError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Commands from your account.
pub async fn list_command(configuration: &configuration::Configuration, params: ListCommandParams) -> Result<ResponseContent<ListCommandSuccess>, Error<ListCommandError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sim = params.sim;
    let status = params.status;
    let direction = params.direction;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Commands", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sim {
        local_var_req_builder = local_var_req_builder.query(&[("Sim", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = direction {
        local_var_req_builder = local_var_req_builder.query(&[("Direction", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCommandSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCommandError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Fleets from your account.
pub async fn list_fleet(configuration: &configuration::Configuration, params: ListFleetParams) -> Result<ResponseContent<ListFleetSuccess>, Error<ListFleetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let network_access_profile = params.network_access_profile;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Fleets", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = network_access_profile {
        local_var_req_builder = local_var_req_builder.query(&[("NetworkAccessProfile", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFleetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFleetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Network resources.
pub async fn list_network(configuration: &configuration::Configuration, params: ListNetworkParams) -> Result<ResponseContent<ListNetworkSuccess>, Error<ListNetworkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let iso_country = params.iso_country;
    let mcc = params.mcc;
    let mnc = params.mnc;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Networks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = iso_country {
        local_var_req_builder = local_var_req_builder.query(&[("IsoCountry", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mcc {
        local_var_req_builder = local_var_req_builder.query(&[("Mcc", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = mnc {
        local_var_req_builder = local_var_req_builder.query(&[("Mnc", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListNetworkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListNetworkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Network Access Profiles from your account.
pub async fn list_network_access_profile(configuration: &configuration::Configuration, params: ListNetworkAccessProfileParams) -> Result<ResponseContent<ListNetworkAccessProfileSuccess>, Error<ListNetworkAccessProfileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/NetworkAccessProfiles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListNetworkAccessProfileSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListNetworkAccessProfileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Network Access Profile resource's Network resource.
pub async fn list_network_access_profile_network(configuration: &configuration::Configuration, params: ListNetworkAccessProfileNetworkParams) -> Result<ResponseContent<ListNetworkAccessProfileNetworkSuccess>, Error<ListNetworkAccessProfileNetworkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let network_access_profile_sid = params.network_access_profile_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks", local_var_configuration.base_path, NetworkAccessProfileSid=crate::apis::urlencode(network_access_profile_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListNetworkAccessProfileNetworkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListNetworkAccessProfileNetworkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Super SIMs from your account.
pub async fn list_sim(configuration: &configuration::Configuration, params: ListSimParams) -> Result<ResponseContent<ListSimSuccess>, Error<ListSimError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let status = params.status;
    let fleet = params.fleet;
    let iccid = params.iccid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fleet {
        local_var_req_builder = local_var_req_builder.query(&[("Fleet", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iccid {
        local_var_req_builder = local_var_req_builder.query(&[("Iccid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSimSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSimError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of SMS Commands from your account.
pub async fn list_sms_command(configuration: &configuration::Configuration, params: ListSmsCommandParams) -> Result<ResponseContent<ListSmsCommandSuccess>, Error<ListSmsCommandError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sim = params.sim;
    let status = params.status;
    let direction = params.direction;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/SmsCommands", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sim {
        local_var_req_builder = local_var_req_builder.query(&[("Sim", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = direction {
        local_var_req_builder = local_var_req_builder.query(&[("Direction", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSmsCommandSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSmsCommandError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List UsageRecords
pub async fn list_usage_record(configuration: &configuration::Configuration, params: ListUsageRecordParams) -> Result<ResponseContent<ListUsageRecordSuccess>, Error<ListUsageRecordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sim = params.sim;
    let fleet = params.fleet;
    let network = params.network;
    let iso_country = params.iso_country;
    let group = params.group;
    let granularity = params.granularity;
    let start_time = params.start_time;
    let end_time = params.end_time;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/UsageRecords", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sim {
        local_var_req_builder = local_var_req_builder.query(&[("Sim", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fleet {
        local_var_req_builder = local_var_req_builder.query(&[("Fleet", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = network {
        local_var_req_builder = local_var_req_builder.query(&[("Network", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iso_country {
        local_var_req_builder = local_var_req_builder.query(&[("IsoCountry", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = group {
        local_var_req_builder = local_var_req_builder.query(&[("Group", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = granularity {
        local_var_req_builder = local_var_req_builder.query(&[("Granularity", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_time {
        local_var_req_builder = local_var_req_builder.query(&[("StartTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_time {
        local_var_req_builder = local_var_req_builder.query(&[("EndTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the given properties of a Super SIM Fleet instance from your account.
pub async fn update_fleet(configuration: &configuration::Configuration, params: UpdateFleetParams) -> Result<ResponseContent<UpdateFleetSuccess>, Error<UpdateFleetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let commands_method = params.commands_method;
    let commands_url = params.commands_url;
    let network_access_profile = params.network_access_profile;
    let sms_commands_method = params.sms_commands_method;
    let sms_commands_url = params.sms_commands_url;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Fleets/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = commands_method {
        local_var_form_params.insert("CommandsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = commands_url {
        local_var_form_params.insert("CommandsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = network_access_profile {
        local_var_form_params.insert("NetworkAccessProfile", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_commands_method {
        local_var_form_params.insert("SmsCommandsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_commands_url {
        local_var_form_params.insert("SmsCommandsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateFleetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateFleetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the given properties of a Network Access Profile in your account.
pub async fn update_network_access_profile(configuration: &configuration::Configuration, params: UpdateNetworkAccessProfileParams) -> Result<ResponseContent<UpdateNetworkAccessProfileSuccess>, Error<UpdateNetworkAccessProfileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/NetworkAccessProfiles/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateNetworkAccessProfileSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateNetworkAccessProfileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the given properties of a Super SIM instance from your account.
pub async fn update_sim(configuration: &configuration::Configuration, params: UpdateSimParams) -> Result<ResponseContent<UpdateSimSuccess>, Error<UpdateSimError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let account_sid = params.account_sid;
    let callback_method = params.callback_method;
    let callback_url = params.callback_url;
    let fleet = params.fleet;
    let status = params.status;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = account_sid {
        local_var_form_params.insert("AccountSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = callback_method {
        local_var_form_params.insert("CallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = callback_url {
        local_var_form_params.insert("CallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fleet {
        local_var_form_params.insert("Fleet", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSimSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSimError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

