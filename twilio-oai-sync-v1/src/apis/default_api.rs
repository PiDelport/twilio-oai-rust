/*
 * Twilio - Sync
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_document`
#[derive(Clone, Debug, Default)]
pub struct CreateDocumentParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) to create the new Document resource in.
    pub service_sid: String,
    /// A JSON string that represents an arbitrary, schema-less object that the Sync Document stores. Can be up to 16 KiB in length.
    pub data: Option<serde_json::Value>,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Sync Document expires and is deleted (the Sync Document's time-to-live).
    pub ttl: Option<i32>,
    /// An application-defined string that uniquely identifies the Sync Document
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `create_service`
#[derive(Clone, Debug, Default)]
pub struct CreateServiceParams {
    /// Whether token identities in the Service must be granted access to Sync objects by using the [Permissions](https://www.twilio.com/docs/sync/api/sync-permissions) resource.
    pub acl_enabled: Option<bool>,
    /// A string that you assign to describe the resource.
    pub friendly_name: Option<String>,
    /// Whether every `endpoint_disconnected` event should occur after a configurable delay. The default is `false`, where the `endpoint_disconnected` event occurs immediately after disconnection. When `true`, intervening reconnections can prevent the `endpoint_disconnected` event.
    pub reachability_debouncing_enabled: Option<bool>,
    /// The reachability event delay in milliseconds if `reachability_debouncing_enabled` = `true`.  Must be between 1,000 and 30,000 and defaults to 5,000. This is the number of milliseconds after the last running client disconnects, and a Sync identity is declared offline, before the `webhook_url` is called if all endpoints remain offline. A reconnection from the same identity by any endpoint during this interval prevents the call to `webhook_url`.
    pub reachability_debouncing_window: Option<i32>,
    /// Whether the service instance should call `webhook_url` when client endpoints connect to Sync. The default is `false`.
    pub reachability_webhooks_enabled: Option<bool>,
    /// The URL we should call when Sync objects are manipulated.
    pub webhook_url: Option<String>,
    /// Whether the Service instance should call `webhook_url` when the REST API is used to update Sync objects. The default is `false`.
    pub webhooks_from_rest_enabled: Option<bool>
}

/// struct for passing parameters to the method `create_stream_message`
#[derive(Clone, Debug, Default)]
pub struct CreateStreamMessageParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) to create the new Stream Message in.
    pub service_sid: String,
    /// The SID of the Sync Stream to create the new Stream Message resource for.
    pub stream_sid: String,
    /// A JSON string that represents an arbitrary, schema-less object that makes up the Stream Message body. Can be up to 4 KiB in length.
    pub data: serde_json::Value
}

/// struct for passing parameters to the method `create_sync_list`
#[derive(Clone, Debug, Default)]
pub struct CreateSyncListParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) to create the new Sync List in.
    pub service_sid: String,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Sync List expires (time-to-live) and is deleted.
    pub collection_ttl: Option<i32>,
    /// Alias for collection_ttl. If both are provided, this value is ignored.
    pub ttl: Option<i32>,
    /// An application-defined string that uniquely identifies the resource. This value must be unique within its Service and it can be up to 320 characters long. The `unique_name` value can be used as an alternative to the `sid` in the URL path to address the resource.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `create_sync_list_item`
#[derive(Clone, Debug, Default)]
pub struct CreateSyncListItemParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) to create the new List Item in.
    pub service_sid: String,
    /// The SID of the Sync List to add the new List Item to. Can be the Sync List resource's `sid` or its `unique_name`.
    pub list_sid: String,
    /// A JSON string that represents an arbitrary, schema-less object that the List Item stores. Can be up to 16 KiB in length.
    pub data: serde_json::Value,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the List Item's parent Sync List expires (time-to-live) and is deleted.
    pub collection_ttl: Option<i32>,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the List Item expires (time-to-live) and is deleted.
    pub item_ttl: Option<i32>,
    /// An alias for `item_ttl`. If both parameters are provided, this value is ignored.
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method `create_sync_map`
#[derive(Clone, Debug, Default)]
pub struct CreateSyncMapParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) to create the Sync Map in.
    pub service_sid: String,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Sync Map expires (time-to-live) and is deleted.
    pub collection_ttl: Option<i32>,
    /// An alias for `collection_ttl`. If both parameters are provided, this value is ignored.
    pub ttl: Option<i32>,
    /// An application-defined string that uniquely identifies the resource. It can be used as an alternative to the `sid` in the URL path to address the resource.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `create_sync_map_item`
#[derive(Clone, Debug, Default)]
pub struct CreateSyncMapItemParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) to create the Map Item in.
    pub service_sid: String,
    /// The SID of the Sync Map to add the new Map Item to. Can be the Sync Map resource's `sid` or its `unique_name`.
    pub map_sid: String,
    /// A JSON string that represents an arbitrary, schema-less object that the Map Item stores. Can be up to 16 KiB in length.
    pub data: serde_json::Value,
    /// The unique, user-defined key for the Map Item. Can be up to 320 characters long.
    pub key: String,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Map Item's parent Sync Map expires (time-to-live) and is deleted.
    pub collection_ttl: Option<i32>,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Map Item expires (time-to-live) and is deleted.
    pub item_ttl: Option<i32>,
    /// An alias for `item_ttl`. If both parameters are provided, this value is ignored.
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method `create_sync_stream`
#[derive(Clone, Debug, Default)]
pub struct CreateSyncStreamParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) to create the new Stream in.
    pub service_sid: String,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Stream expires and is deleted (time-to-live).
    pub ttl: Option<i32>,
    /// An application-defined string that uniquely identifies the resource. This value must be unique within its Service and it can be up to 320 characters long. The `unique_name` value can be used as an alternative to the `sid` in the URL path to address the resource.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `delete_document`
#[derive(Clone, Debug, Default)]
pub struct DeleteDocumentParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Document resource to delete.
    pub service_sid: String,
    /// The SID of the Document resource to delete. Can be the Document resource's `sid` or its `unique_name`.
    pub sid: String
}

/// struct for passing parameters to the method `delete_document_permission`
#[derive(Clone, Debug, Default)]
pub struct DeleteDocumentPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Document Permission resource to delete.
    pub service_sid: String,
    /// The SID of the Sync Document with the Document Permission resource to delete. Can be the Document resource's `sid` or its `unique_name`.
    pub document_sid: String,
    /// The application-defined string that uniquely identifies the User's Document Permission resource to delete.
    pub identity: String
}

/// struct for passing parameters to the method `delete_service`
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    /// The SID of the Service resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sync_list`
#[derive(Clone, Debug, Default)]
pub struct DeleteSyncListParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List resource to delete.
    pub service_sid: String,
    /// The SID of the Sync List resource to delete. Can be the Sync List resource's `sid` or its `unique_name`.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sync_list_item`
#[derive(Clone, Debug, Default)]
pub struct DeleteSyncListItemParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List Item resource to delete.
    pub service_sid: String,
    /// The SID of the Sync List with the Sync List Item resource to delete. Can be the Sync List resource's `sid` or its `unique_name`.
    pub list_sid: String,
    /// The index of the Sync List Item resource to delete.
    pub index: i32,
    /// If provided, applies this mutation if (and only if) the “revision” field of this [map item] matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
    pub if_match: Option<String>
}

/// struct for passing parameters to the method `delete_sync_list_permission`
#[derive(Clone, Debug, Default)]
pub struct DeleteSyncListPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List Permission resource to delete.
    pub service_sid: String,
    /// The SID of the Sync List with the Sync List Permission resource to delete. Can be the Sync List resource's `sid` or its `unique_name`.
    pub list_sid: String,
    /// The application-defined string that uniquely identifies the User's Sync List Permission resource to delete.
    pub identity: String
}

/// struct for passing parameters to the method `delete_sync_map`
#[derive(Clone, Debug, Default)]
pub struct DeleteSyncMapParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map resource to delete.
    pub service_sid: String,
    /// The SID of the Sync Map resource to delete. Can be the Sync Map's `sid` or its `unique_name`.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sync_map_item`
#[derive(Clone, Debug, Default)]
pub struct DeleteSyncMapItemParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map Item resource to delete.
    pub service_sid: String,
    /// The SID of the Sync Map with the Sync Map Item resource to delete. Can be the Sync Map resource's `sid` or its `unique_name`.
    pub map_sid: String,
    /// The `key` value of the Sync Map Item resource to delete.
    pub key: String,
    /// If provided, applies this mutation if (and only if) the “revision” field of this [map item] matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
    pub if_match: Option<String>
}

/// struct for passing parameters to the method `delete_sync_map_permission`
#[derive(Clone, Debug, Default)]
pub struct DeleteSyncMapPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map Permission resource to delete. Can be the Service's `sid` value or `default`.
    pub service_sid: String,
    /// The SID of the Sync Map with the Sync Map Permission resource to delete. Can be the Sync Map resource's `sid` or its `unique_name`.
    pub map_sid: String,
    /// The application-defined string that uniquely identifies the User's Sync Map Permission resource to delete.
    pub identity: String
}

/// struct for passing parameters to the method `delete_sync_stream`
#[derive(Clone, Debug, Default)]
pub struct DeleteSyncStreamParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Stream resource to delete.
    pub service_sid: String,
    /// The SID of the Stream resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_document`
#[derive(Clone, Debug, Default)]
pub struct FetchDocumentParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Document resource to fetch.
    pub service_sid: String,
    /// The SID of the Document resource to fetch. Can be the Document resource's `sid` or its `unique_name`.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_document_permission`
#[derive(Clone, Debug, Default)]
pub struct FetchDocumentPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Document Permission resource to fetch.
    pub service_sid: String,
    /// The SID of the Sync Document with the Document Permission resource to fetch. Can be the Document resource's `sid` or its `unique_name`.
    pub document_sid: String,
    /// The application-defined string that uniquely identifies the User's Document Permission resource to fetch.
    pub identity: String
}

/// struct for passing parameters to the method `fetch_service`
#[derive(Clone, Debug, Default)]
pub struct FetchServiceParams {
    /// The SID of the Service resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sync_list`
#[derive(Clone, Debug, Default)]
pub struct FetchSyncListParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List resource to fetch.
    pub service_sid: String,
    /// The SID of the Sync List resource to fetch. Can be the Sync List resource's `sid` or its `unique_name`.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sync_list_item`
#[derive(Clone, Debug, Default)]
pub struct FetchSyncListItemParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List Item resource to fetch.
    pub service_sid: String,
    /// The SID of the Sync List with the Sync List Item resource to fetch. Can be the Sync List resource's `sid` or its `unique_name`.
    pub list_sid: String,
    /// The index of the Sync List Item resource to fetch.
    pub index: i32
}

/// struct for passing parameters to the method `fetch_sync_list_permission`
#[derive(Clone, Debug, Default)]
pub struct FetchSyncListPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List Permission resource to fetch.
    pub service_sid: String,
    /// The SID of the Sync List with the Sync List Permission resource to fetch. Can be the Sync List resource's `sid` or its `unique_name`.
    pub list_sid: String,
    /// The application-defined string that uniquely identifies the User's Sync List Permission resource to fetch.
    pub identity: String
}

/// struct for passing parameters to the method `fetch_sync_map`
#[derive(Clone, Debug, Default)]
pub struct FetchSyncMapParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map resource to fetch.
    pub service_sid: String,
    /// The SID of the Sync Map resource to fetch. Can be the Sync Map's `sid` or its `unique_name`.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sync_map_item`
#[derive(Clone, Debug, Default)]
pub struct FetchSyncMapItemParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map Item resource to fetch.
    pub service_sid: String,
    /// The SID of the Sync Map with the Sync Map Item resource to fetch. Can be the Sync Map resource's `sid` or its `unique_name`.
    pub map_sid: String,
    /// The `key` value of the Sync Map Item resource to fetch.
    pub key: String
}

/// struct for passing parameters to the method `fetch_sync_map_permission`
#[derive(Clone, Debug, Default)]
pub struct FetchSyncMapPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map Permission resource to fetch. Can be the Service's `sid` value or `default`.
    pub service_sid: String,
    /// The SID of the Sync Map with the Sync Map Permission resource to fetch. Can be the Sync Map resource's `sid` or its `unique_name`.
    pub map_sid: String,
    /// The application-defined string that uniquely identifies the User's Sync Map Permission resource to fetch.
    pub identity: String
}

/// struct for passing parameters to the method `fetch_sync_stream`
#[derive(Clone, Debug, Default)]
pub struct FetchSyncStreamParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Stream resource to fetch.
    pub service_sid: String,
    /// The SID of the Stream resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `list_document`
#[derive(Clone, Debug, Default)]
pub struct ListDocumentParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Document resources to read.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_document_permission`
#[derive(Clone, Debug, Default)]
pub struct ListDocumentPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Document Permission resources to read.
    pub service_sid: String,
    /// The SID of the Sync Document with the Document Permission resources to read. Can be the Document resource's `sid` or its `unique_name`.
    pub document_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_service`
#[derive(Clone, Debug, Default)]
pub struct ListServiceParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sync_list`
#[derive(Clone, Debug, Default)]
pub struct ListSyncListParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List resources to read.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sync_list_item`
#[derive(Clone, Debug, Default)]
pub struct ListSyncListItemParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the List Item resources to read.
    pub service_sid: String,
    /// The SID of the Sync List with the List Items to read. Can be the Sync List resource's `sid` or its `unique_name`.
    pub list_sid: String,
    /// How to order the List Items returned by their `index` value. Can be: `asc` (ascending) or `desc` (descending) and the default is ascending.
    pub order: Option<String>,
    /// The `index` of the first Sync List Item resource to read. See also `bounds`.
    pub from: Option<String>,
    /// Whether to include the List Item referenced by the `from` parameter. Can be: `inclusive` to include the List Item referenced by the `from` parameter or `exclusive` to start with the next List Item. The default value is `inclusive`.
    pub bounds: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sync_list_permission`
#[derive(Clone, Debug, Default)]
pub struct ListSyncListPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List Permission resources to read.
    pub service_sid: String,
    /// The SID of the Sync List with the Sync List Permission resources to read. Can be the Sync List resource's `sid` or its `unique_name`.
    pub list_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sync_map`
#[derive(Clone, Debug, Default)]
pub struct ListSyncMapParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map resources to read.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sync_map_item`
#[derive(Clone, Debug, Default)]
pub struct ListSyncMapItemParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Map Item resources to read.
    pub service_sid: String,
    /// The SID of the Sync Map with the Sync Map Item resource to fetch. Can be the Sync Map resource's `sid` or its `unique_name`.
    pub map_sid: String,
    /// How to order the Map Items returned by their `key` value. Can be: `asc` (ascending) or `desc` (descending) and the default is ascending. Map Items are [ordered lexicographically](https://en.wikipedia.org/wiki/Lexicographical_order) by Item key.
    pub order: Option<String>,
    /// The `key` of the first Sync Map Item resource to read. See also `bounds`.
    pub from: Option<String>,
    /// Whether to include the Map Item referenced by the `from` parameter. Can be: `inclusive` to include the Map Item referenced by the `from` parameter or `exclusive` to start with the next Map Item. The default value is `inclusive`.
    pub bounds: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sync_map_permission`
#[derive(Clone, Debug, Default)]
pub struct ListSyncMapPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map Permission resources to read. Can be the Service's `sid` value or `default`.
    pub service_sid: String,
    /// The SID of the Sync Map with the Permission resources to read. Can be the Sync Map resource's `sid` or its `unique_name`.
    pub map_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sync_stream`
#[derive(Clone, Debug, Default)]
pub struct ListSyncStreamParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Stream resources to read.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_document`
#[derive(Clone, Debug, Default)]
pub struct UpdateDocumentParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Document resource to update.
    pub service_sid: String,
    /// The SID of the Document resource to update. Can be the Document resource's `sid` or its `unique_name`.
    pub sid: String,
    /// The If-Match HTTP request header
    pub if_match: Option<String>,
    /// A JSON string that represents an arbitrary, schema-less object that the Sync Document stores. Can be up to 16 KiB in length.
    pub data: Option<serde_json::Value>,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Sync Document expires and is deleted (time-to-live).
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method `update_document_permission`
#[derive(Clone, Debug, Default)]
pub struct UpdateDocumentPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Document Permission resource to update.
    pub service_sid: String,
    /// The SID of the Sync Document with the Document Permission resource to update. Can be the Document resource's `sid` or its `unique_name`.
    pub document_sid: String,
    /// The application-defined string that uniquely identifies the User's Document Permission resource to update.
    pub identity: String,
    /// Whether the identity can delete the Sync Document. Default value is `false`.
    pub manage: bool,
    /// Whether the identity can read the Sync Document. Default value is `false`.
    pub read: bool,
    /// Whether the identity can update the Sync Document. Default value is `false`.
    pub write: bool
}

/// struct for passing parameters to the method `update_service`
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceParams {
    /// The SID of the Service resource to update.
    pub sid: String,
    /// Whether token identities in the Service must be granted access to Sync objects by using the [Permissions](https://www.twilio.com/docs/sync/api/sync-permissions) resource.
    pub acl_enabled: Option<bool>,
    /// A string that you assign to describe the resource.
    pub friendly_name: Option<String>,
    /// Whether every `endpoint_disconnected` event should occur after a configurable delay. The default is `false`, where the `endpoint_disconnected` event occurs immediately after disconnection. When `true`, intervening reconnections can prevent the `endpoint_disconnected` event.
    pub reachability_debouncing_enabled: Option<bool>,
    /// The reachability event delay in milliseconds if `reachability_debouncing_enabled` = `true`.  Must be between 1,000 and 30,000 and defaults to 5,000. This is the number of milliseconds after the last running client disconnects, and a Sync identity is declared offline, before the webhook is called if all endpoints remain offline. A reconnection from the same identity by any endpoint during this interval prevents the webhook from being called.
    pub reachability_debouncing_window: Option<i32>,
    /// Whether the service instance should call `webhook_url` when client endpoints connect to Sync. The default is `false`.
    pub reachability_webhooks_enabled: Option<bool>,
    /// The URL we should call when Sync objects are manipulated.
    pub webhook_url: Option<String>,
    /// Whether the Service instance should call `webhook_url` when the REST API is used to update Sync objects. The default is `false`.
    pub webhooks_from_rest_enabled: Option<bool>
}

/// struct for passing parameters to the method `update_sync_list`
#[derive(Clone, Debug, Default)]
pub struct UpdateSyncListParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List resource to update.
    pub service_sid: String,
    /// The SID of the Sync List resource to update. Can be the Sync List resource's `sid` or its `unique_name`.
    pub sid: String,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Sync List expires (time-to-live) and is deleted.
    pub collection_ttl: Option<i32>,
    /// An alias for `collection_ttl`. If both are provided, this value is ignored.
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method `update_sync_list_item`
#[derive(Clone, Debug, Default)]
pub struct UpdateSyncListItemParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List Item resource to update.
    pub service_sid: String,
    /// The SID of the Sync List with the Sync List Item resource to update. Can be the Sync List resource's `sid` or its `unique_name`.
    pub list_sid: String,
    /// The index of the Sync List Item resource to update.
    pub index: i32,
    /// If provided, applies this mutation if (and only if) the “revision” field of this [map item] matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
    pub if_match: Option<String>,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the List Item's parent Sync List expires (time-to-live) and is deleted. This parameter can only be used when the List Item's `data` or `ttl` is updated in the same request.
    pub collection_ttl: Option<i32>,
    /// A JSON string that represents an arbitrary, schema-less object that the List Item stores. Can be up to 16 KiB in length.
    pub data: Option<serde_json::Value>,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the List Item expires (time-to-live) and is deleted.
    pub item_ttl: Option<i32>,
    /// An alias for `item_ttl`. If both parameters are provided, this value is ignored.
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method `update_sync_list_permission`
#[derive(Clone, Debug, Default)]
pub struct UpdateSyncListPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync List Permission resource to update.
    pub service_sid: String,
    /// The SID of the Sync List with the Sync List Permission resource to update. Can be the Sync List resource's `sid` or its `unique_name`.
    pub list_sid: String,
    /// The application-defined string that uniquely identifies the User's Sync List Permission resource to update.
    pub identity: String,
    /// Whether the identity can delete the Sync List. Default value is `false`.
    pub manage: bool,
    /// Whether the identity can read the Sync List and its Items. Default value is `false`.
    pub read: bool,
    /// Whether the identity can create, update, and delete Items in the Sync List. Default value is `false`.
    pub write: bool
}

/// struct for passing parameters to the method `update_sync_map`
#[derive(Clone, Debug, Default)]
pub struct UpdateSyncMapParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map resource to update.
    pub service_sid: String,
    /// The SID of the Sync Map resource to update. Can be the Sync Map's `sid` or its `unique_name`.
    pub sid: String,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Sync Map expires (time-to-live) and is deleted.
    pub collection_ttl: Option<i32>,
    /// An alias for `collection_ttl`. If both parameters are provided, this value is ignored.
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method `update_sync_map_item`
#[derive(Clone, Debug, Default)]
pub struct UpdateSyncMapItemParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map Item resource to update.
    pub service_sid: String,
    /// The SID of the Sync Map with the Sync Map Item resource to update. Can be the Sync Map resource's `sid` or its `unique_name`.
    pub map_sid: String,
    /// The `key` value of the Sync Map Item resource to update. 
    pub key: String,
    /// If provided, applies this mutation if (and only if) the “revision” field of this [map item] matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
    pub if_match: Option<String>,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Map Item's parent Sync Map expires (time-to-live) and is deleted. This parameter can only be used when the Map Item's `data` or `ttl` is updated in the same request.
    pub collection_ttl: Option<i32>,
    /// A JSON string that represents an arbitrary, schema-less object that the Map Item stores. Can be up to 16 KiB in length.
    pub data: Option<serde_json::Value>,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Map Item expires (time-to-live) and is deleted.
    pub item_ttl: Option<i32>,
    /// An alias for `item_ttl`. If both parameters are provided, this value is ignored.
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method `update_sync_map_permission`
#[derive(Clone, Debug, Default)]
pub struct UpdateSyncMapPermissionParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Map Permission resource to update. Can be the Service's `sid` value or `default`.
    pub service_sid: String,
    /// The SID of the Sync Map with the Sync Map Permission resource to update. Can be the Sync Map resource's `sid` or its `unique_name`.
    pub map_sid: String,
    /// The application-defined string that uniquely identifies the User's Sync Map Permission resource to update.
    pub identity: String,
    /// Whether the identity can delete the Sync Map. Default value is `false`.
    pub manage: bool,
    /// Whether the identity can read the Sync Map and its Items. Default value is `false`.
    pub read: bool,
    /// Whether the identity can create, update, and delete Items in the Sync Map. Default value is `false`.
    pub write: bool
}

/// struct for passing parameters to the method `update_sync_stream`
#[derive(Clone, Debug, Default)]
pub struct UpdateSyncStreamParams {
    /// The SID of the [Sync Service](https://www.twilio.com/docs/sync/api/service) with the Sync Stream resource to update.
    pub service_sid: String,
    /// The SID of the Stream resource to update.
    pub sid: String,
    /// How long, [in seconds](https://www.twilio.com/docs/sync/limits#sync-payload-limits), before the Stream expires and is deleted (time-to-live).
    pub ttl: Option<i32>
}


/// struct for typed successes of method `create_document`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDocumentSuccess {
    Status201(crate::models::SyncV1ServiceDocument),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceSuccess {
    Status201(crate::models::SyncV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_stream_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateStreamMessageSuccess {
    Status201(crate::models::SyncV1ServiceSyncStreamStreamMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sync_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSyncListSuccess {
    Status201(crate::models::SyncV1ServiceSyncList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sync_list_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSyncListItemSuccess {
    Status201(crate::models::SyncV1ServiceSyncListSyncListItem),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sync_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSyncMapSuccess {
    Status201(crate::models::SyncV1ServiceSyncMap),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sync_map_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSyncMapItemSuccess {
    Status201(crate::models::SyncV1ServiceSyncMapSyncMapItem),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_sync_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSyncStreamSuccess {
    Status201(crate::models::SyncV1ServiceSyncStream),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_document`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_document_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentPermissionSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sync_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncListSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sync_list_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncListItemSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sync_list_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncListPermissionSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sync_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncMapSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sync_map_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncMapItemSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sync_map_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncMapPermissionSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sync_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncStreamSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_document`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDocumentSuccess {
    Status200(crate::models::SyncV1ServiceDocument),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_document_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDocumentPermissionSuccess {
    Status200(crate::models::SyncV1ServiceDocumentDocumentPermission),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceSuccess {
    Status200(crate::models::SyncV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sync_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncListSuccess {
    Status200(crate::models::SyncV1ServiceSyncList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sync_list_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncListItemSuccess {
    Status200(crate::models::SyncV1ServiceSyncListSyncListItem),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sync_list_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncListPermissionSuccess {
    Status200(crate::models::SyncV1ServiceSyncListSyncListPermission),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sync_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncMapSuccess {
    Status200(crate::models::SyncV1ServiceSyncMap),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sync_map_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncMapItemSuccess {
    Status200(crate::models::SyncV1ServiceSyncMapSyncMapItem),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sync_map_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncMapPermissionSuccess {
    Status200(crate::models::SyncV1ServiceSyncMapSyncMapPermission),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sync_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncStreamSuccess {
    Status200(crate::models::SyncV1ServiceSyncStream),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_document`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDocumentSuccess {
    Status200(crate::models::ListDocumentResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_document_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDocumentPermissionSuccess {
    Status200(crate::models::ListDocumentPermissionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceSuccess {
    Status200(crate::models::ListServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sync_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncListSuccess {
    Status200(crate::models::ListSyncListResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sync_list_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncListItemSuccess {
    Status200(crate::models::ListSyncListItemResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sync_list_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncListPermissionSuccess {
    Status200(crate::models::ListSyncListPermissionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sync_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncMapSuccess {
    Status200(crate::models::ListSyncMapResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sync_map_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncMapItemSuccess {
    Status200(crate::models::ListSyncMapItemResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sync_map_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncMapPermissionSuccess {
    Status200(crate::models::ListSyncMapPermissionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sync_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncStreamSuccess {
    Status200(crate::models::ListSyncStreamResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_document`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentSuccess {
    Status200(crate::models::SyncV1ServiceDocument),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_document_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentPermissionSuccess {
    Status200(crate::models::SyncV1ServiceDocumentDocumentPermission),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceSuccess {
    Status200(crate::models::SyncV1Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sync_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncListSuccess {
    Status200(crate::models::SyncV1ServiceSyncList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sync_list_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncListItemSuccess {
    Status200(crate::models::SyncV1ServiceSyncListSyncListItem),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sync_list_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncListPermissionSuccess {
    Status200(crate::models::SyncV1ServiceSyncListSyncListPermission),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sync_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncMapSuccess {
    Status200(crate::models::SyncV1ServiceSyncMap),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sync_map_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncMapItemSuccess {
    Status200(crate::models::SyncV1ServiceSyncMapSyncMapItem),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sync_map_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncMapPermissionSuccess {
    Status200(crate::models::SyncV1ServiceSyncMapSyncMapPermission),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sync_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncStreamSuccess {
    Status200(crate::models::SyncV1ServiceSyncStream),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_document`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_stream_message`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateStreamMessageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sync_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSyncListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sync_list_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSyncListItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sync_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSyncMapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sync_map_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSyncMapItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_sync_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSyncStreamError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_document`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_document_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sync_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sync_list_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncListItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sync_list_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncListPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sync_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncMapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sync_map_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncMapItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sync_map_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncMapPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sync_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSyncStreamError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_document`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_document_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDocumentPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sync_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sync_list_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncListItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sync_list_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncListPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sync_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncMapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sync_map_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncMapItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sync_map_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncMapPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sync_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSyncStreamError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_document`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_document_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDocumentPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sync_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sync_list_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncListItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sync_list_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncListPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sync_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncMapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sync_map_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncMapItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sync_map_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncMapPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sync_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSyncStreamError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_document`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_document_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_service`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sync_list`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sync_list_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncListItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sync_list_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncListPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sync_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncMapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sync_map_item`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncMapItemError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sync_map_permission`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncMapPermissionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sync_stream`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSyncStreamError {
    UnknownValue(serde_json::Value),
}


pub async fn create_document(configuration: &configuration::Configuration, params: CreateDocumentParams) -> Result<ResponseContent<CreateDocumentSuccess>, Error<CreateDocumentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let data = params.data;
    let ttl = params.ttl;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Documents", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = data {
        local_var_form_params.insert("Data", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateDocumentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_service(configuration: &configuration::Configuration, params: CreateServiceParams) -> Result<ResponseContent<CreateServiceSuccess>, Error<CreateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let acl_enabled = params.acl_enabled;
    let friendly_name = params.friendly_name;
    let reachability_debouncing_enabled = params.reachability_debouncing_enabled;
    let reachability_debouncing_window = params.reachability_debouncing_window;
    let reachability_webhooks_enabled = params.reachability_webhooks_enabled;
    let webhook_url = params.webhook_url;
    let webhooks_from_rest_enabled = params.webhooks_from_rest_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = acl_enabled {
        local_var_form_params.insert("AclEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_debouncing_enabled {
        local_var_form_params.insert("ReachabilityDebouncingEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_debouncing_window {
        local_var_form_params.insert("ReachabilityDebouncingWindow", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_webhooks_enabled {
        local_var_form_params.insert("ReachabilityWebhooksEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_url {
        local_var_form_params.insert("WebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_from_rest_enabled {
        local_var_form_params.insert("WebhooksFromRestEnabled", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Stream Message.
pub async fn create_stream_message(configuration: &configuration::Configuration, params: CreateStreamMessageParams) -> Result<ResponseContent<CreateStreamMessageSuccess>, Error<CreateStreamMessageError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let stream_sid = params.stream_sid;
    let data = params.data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Streams/{StreamSid}/Messages", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), StreamSid=crate::apis::urlencode(stream_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Data", data.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateStreamMessageSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateStreamMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_sync_list(configuration: &configuration::Configuration, params: CreateSyncListParams) -> Result<ResponseContent<CreateSyncListSuccess>, Error<CreateSyncListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let collection_ttl = params.collection_ttl;
    let ttl = params.ttl;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = collection_ttl {
        local_var_form_params.insert("CollectionTtl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSyncListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSyncListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_sync_list_item(configuration: &configuration::Configuration, params: CreateSyncListItemParams) -> Result<ResponseContent<CreateSyncListItemSuccess>, Error<CreateSyncListItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let list_sid = params.list_sid;
    let data = params.data;
    let collection_ttl = params.collection_ttl;
    let item_ttl = params.item_ttl;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{ListSid}/Items", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ListSid=crate::apis::urlencode(list_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = collection_ttl {
        local_var_form_params.insert("CollectionTtl", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Data", data.to_string());
    if let Some(local_var_param_value) = item_ttl {
        local_var_form_params.insert("ItemTtl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSyncListItemSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSyncListItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_sync_map(configuration: &configuration::Configuration, params: CreateSyncMapParams) -> Result<ResponseContent<CreateSyncMapSuccess>, Error<CreateSyncMapError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let collection_ttl = params.collection_ttl;
    let ttl = params.ttl;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = collection_ttl {
        local_var_form_params.insert("CollectionTtl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSyncMapSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSyncMapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_sync_map_item(configuration: &configuration::Configuration, params: CreateSyncMapItemParams) -> Result<ResponseContent<CreateSyncMapItemSuccess>, Error<CreateSyncMapItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let map_sid = params.map_sid;
    let data = params.data;
    let key = params.key;
    let collection_ttl = params.collection_ttl;
    let item_ttl = params.item_ttl;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{MapSid}/Items", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), MapSid=crate::apis::urlencode(map_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = collection_ttl {
        local_var_form_params.insert("CollectionTtl", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Data", data.to_string());
    if let Some(local_var_param_value) = item_ttl {
        local_var_form_params.insert("ItemTtl", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Key", key.to_string());
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSyncMapItemSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSyncMapItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Stream.
pub async fn create_sync_stream(configuration: &configuration::Configuration, params: CreateSyncStreamParams) -> Result<ResponseContent<CreateSyncStreamSuccess>, Error<CreateSyncStreamError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let ttl = params.ttl;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Streams", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSyncStreamSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSyncStreamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_document(configuration: &configuration::Configuration, params: DeleteDocumentParams) -> Result<ResponseContent<DeleteDocumentSuccess>, Error<DeleteDocumentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Documents/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteDocumentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Sync Document Permission.
pub async fn delete_document_permission(configuration: &configuration::Configuration, params: DeleteDocumentPermissionParams) -> Result<ResponseContent<DeleteDocumentPermissionSuccess>, Error<DeleteDocumentPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let document_sid = params.document_sid;
    let identity = params.identity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), DocumentSid=crate::apis::urlencode(document_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteDocumentPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteDocumentPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<ResponseContent<DeleteServiceSuccess>, Error<DeleteServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sync_list(configuration: &configuration::Configuration, params: DeleteSyncListParams) -> Result<ResponseContent<DeleteSyncListSuccess>, Error<DeleteSyncListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSyncListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSyncListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sync_list_item(configuration: &configuration::Configuration, params: DeleteSyncListItemParams) -> Result<ResponseContent<DeleteSyncListItemSuccess>, Error<DeleteSyncListItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let list_sid = params.list_sid;
    let index = params.index;
    let if_match = params.if_match;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ListSid=crate::apis::urlencode(list_sid), Index=index);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = if_match {
        local_var_req_builder = local_var_req_builder.header("If-Match", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSyncListItemSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSyncListItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Sync List Permission.
pub async fn delete_sync_list_permission(configuration: &configuration::Configuration, params: DeleteSyncListPermissionParams) -> Result<ResponseContent<DeleteSyncListPermissionSuccess>, Error<DeleteSyncListPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let list_sid = params.list_sid;
    let identity = params.identity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ListSid=crate::apis::urlencode(list_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSyncListPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSyncListPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sync_map(configuration: &configuration::Configuration, params: DeleteSyncMapParams) -> Result<ResponseContent<DeleteSyncMapSuccess>, Error<DeleteSyncMapError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSyncMapSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSyncMapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_sync_map_item(configuration: &configuration::Configuration, params: DeleteSyncMapItemParams) -> Result<ResponseContent<DeleteSyncMapItemSuccess>, Error<DeleteSyncMapItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let map_sid = params.map_sid;
    let key = params.key;
    let if_match = params.if_match;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), MapSid=crate::apis::urlencode(map_sid), Key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = if_match {
        local_var_req_builder = local_var_req_builder.header("If-Match", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSyncMapItemSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSyncMapItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Sync Map Permission.
pub async fn delete_sync_map_permission(configuration: &configuration::Configuration, params: DeleteSyncMapPermissionParams) -> Result<ResponseContent<DeleteSyncMapPermissionSuccess>, Error<DeleteSyncMapPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let map_sid = params.map_sid;
    let identity = params.identity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), MapSid=crate::apis::urlencode(map_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSyncMapPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSyncMapPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Stream.
pub async fn delete_sync_stream(configuration: &configuration::Configuration, params: DeleteSyncStreamParams) -> Result<ResponseContent<DeleteSyncStreamSuccess>, Error<DeleteSyncStreamError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Streams/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSyncStreamSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSyncStreamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_document(configuration: &configuration::Configuration, params: FetchDocumentParams) -> Result<ResponseContent<FetchDocumentSuccess>, Error<FetchDocumentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Documents/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchDocumentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Sync Document Permission.
pub async fn fetch_document_permission(configuration: &configuration::Configuration, params: FetchDocumentPermissionParams) -> Result<ResponseContent<FetchDocumentPermissionSuccess>, Error<FetchDocumentPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let document_sid = params.document_sid;
    let identity = params.identity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), DocumentSid=crate::apis::urlencode(document_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchDocumentPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchDocumentPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_service(configuration: &configuration::Configuration, params: FetchServiceParams) -> Result<ResponseContent<FetchServiceSuccess>, Error<FetchServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_sync_list(configuration: &configuration::Configuration, params: FetchSyncListParams) -> Result<ResponseContent<FetchSyncListSuccess>, Error<FetchSyncListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSyncListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSyncListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_sync_list_item(configuration: &configuration::Configuration, params: FetchSyncListItemParams) -> Result<ResponseContent<FetchSyncListItemSuccess>, Error<FetchSyncListItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let list_sid = params.list_sid;
    let index = params.index;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ListSid=crate::apis::urlencode(list_sid), Index=index);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSyncListItemSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSyncListItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Sync List Permission.
pub async fn fetch_sync_list_permission(configuration: &configuration::Configuration, params: FetchSyncListPermissionParams) -> Result<ResponseContent<FetchSyncListPermissionSuccess>, Error<FetchSyncListPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let list_sid = params.list_sid;
    let identity = params.identity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ListSid=crate::apis::urlencode(list_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSyncListPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSyncListPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_sync_map(configuration: &configuration::Configuration, params: FetchSyncMapParams) -> Result<ResponseContent<FetchSyncMapSuccess>, Error<FetchSyncMapError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSyncMapSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSyncMapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_sync_map_item(configuration: &configuration::Configuration, params: FetchSyncMapItemParams) -> Result<ResponseContent<FetchSyncMapItemSuccess>, Error<FetchSyncMapItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let map_sid = params.map_sid;
    let key = params.key;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), MapSid=crate::apis::urlencode(map_sid), Key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSyncMapItemSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSyncMapItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Sync Map Permission.
pub async fn fetch_sync_map_permission(configuration: &configuration::Configuration, params: FetchSyncMapPermissionParams) -> Result<ResponseContent<FetchSyncMapPermissionSuccess>, Error<FetchSyncMapPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let map_sid = params.map_sid;
    let identity = params.identity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), MapSid=crate::apis::urlencode(map_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSyncMapPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSyncMapPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Stream.
pub async fn fetch_sync_stream(configuration: &configuration::Configuration, params: FetchSyncStreamParams) -> Result<ResponseContent<FetchSyncStreamSuccess>, Error<FetchSyncStreamError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Streams/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSyncStreamSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSyncStreamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_document(configuration: &configuration::Configuration, params: ListDocumentParams) -> Result<ResponseContent<ListDocumentSuccess>, Error<ListDocumentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Documents", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListDocumentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Permissions applying to a Sync Document.
pub async fn list_document_permission(configuration: &configuration::Configuration, params: ListDocumentPermissionParams) -> Result<ResponseContent<ListDocumentPermissionSuccess>, Error<ListDocumentPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let document_sid = params.document_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), DocumentSid=crate::apis::urlencode(document_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListDocumentPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListDocumentPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_service(configuration: &configuration::Configuration, params: ListServiceParams) -> Result<ResponseContent<ListServiceSuccess>, Error<ListServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_sync_list(configuration: &configuration::Configuration, params: ListSyncListParams) -> Result<ResponseContent<ListSyncListSuccess>, Error<ListSyncListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSyncListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSyncListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_sync_list_item(configuration: &configuration::Configuration, params: ListSyncListItemParams) -> Result<ResponseContent<ListSyncListItemSuccess>, Error<ListSyncListItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let list_sid = params.list_sid;
    let order = params.order;
    let from = params.from;
    let bounds = params.bounds;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{ListSid}/Items", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ListSid=crate::apis::urlencode(list_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("From", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = bounds {
        local_var_req_builder = local_var_req_builder.query(&[("Bounds", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSyncListItemSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSyncListItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Permissions applying to a Sync List.
pub async fn list_sync_list_permission(configuration: &configuration::Configuration, params: ListSyncListPermissionParams) -> Result<ResponseContent<ListSyncListPermissionSuccess>, Error<ListSyncListPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let list_sid = params.list_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ListSid=crate::apis::urlencode(list_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSyncListPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSyncListPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_sync_map(configuration: &configuration::Configuration, params: ListSyncMapParams) -> Result<ResponseContent<ListSyncMapSuccess>, Error<ListSyncMapError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSyncMapSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSyncMapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_sync_map_item(configuration: &configuration::Configuration, params: ListSyncMapItemParams) -> Result<ResponseContent<ListSyncMapItemSuccess>, Error<ListSyncMapItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let map_sid = params.map_sid;
    let order = params.order;
    let from = params.from;
    let bounds = params.bounds;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{MapSid}/Items", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), MapSid=crate::apis::urlencode(map_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("From", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = bounds {
        local_var_req_builder = local_var_req_builder.query(&[("Bounds", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSyncMapItemSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSyncMapItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Permissions applying to a Sync Map.
pub async fn list_sync_map_permission(configuration: &configuration::Configuration, params: ListSyncMapPermissionParams) -> Result<ResponseContent<ListSyncMapPermissionSuccess>, Error<ListSyncMapPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let map_sid = params.map_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), MapSid=crate::apis::urlencode(map_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSyncMapPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSyncMapPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Streams in a Service Instance.
pub async fn list_sync_stream(configuration: &configuration::Configuration, params: ListSyncStreamParams) -> Result<ResponseContent<ListSyncStreamSuccess>, Error<ListSyncStreamError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Streams", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSyncStreamSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSyncStreamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_document(configuration: &configuration::Configuration, params: UpdateDocumentParams) -> Result<ResponseContent<UpdateDocumentSuccess>, Error<UpdateDocumentError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let if_match = params.if_match;
    let data = params.data;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Documents/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = if_match {
        local_var_req_builder = local_var_req_builder.header("If-Match", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = data {
        local_var_form_params.insert("Data", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateDocumentSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateDocumentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an identity's access to a specific Sync Document.
pub async fn update_document_permission(configuration: &configuration::Configuration, params: UpdateDocumentPermissionParams) -> Result<ResponseContent<UpdateDocumentPermissionSuccess>, Error<UpdateDocumentPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let document_sid = params.document_sid;
    let identity = params.identity;
    let manage = params.manage;
    let read = params.read;
    let write = params.write;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), DocumentSid=crate::apis::urlencode(document_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Manage", manage.to_string());
    local_var_form_params.insert("Read", read.to_string());
    local_var_form_params.insert("Write", write.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateDocumentPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateDocumentPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_service(configuration: &configuration::Configuration, params: UpdateServiceParams) -> Result<ResponseContent<UpdateServiceSuccess>, Error<UpdateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let acl_enabled = params.acl_enabled;
    let friendly_name = params.friendly_name;
    let reachability_debouncing_enabled = params.reachability_debouncing_enabled;
    let reachability_debouncing_window = params.reachability_debouncing_window;
    let reachability_webhooks_enabled = params.reachability_webhooks_enabled;
    let webhook_url = params.webhook_url;
    let webhooks_from_rest_enabled = params.webhooks_from_rest_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = acl_enabled {
        local_var_form_params.insert("AclEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_debouncing_enabled {
        local_var_form_params.insert("ReachabilityDebouncingEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_debouncing_window {
        local_var_form_params.insert("ReachabilityDebouncingWindow", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reachability_webhooks_enabled {
        local_var_form_params.insert("ReachabilityWebhooksEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_url {
        local_var_form_params.insert("WebhookUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhooks_from_rest_enabled {
        local_var_form_params.insert("WebhooksFromRestEnabled", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_sync_list(configuration: &configuration::Configuration, params: UpdateSyncListParams) -> Result<ResponseContent<UpdateSyncListSuccess>, Error<UpdateSyncListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let collection_ttl = params.collection_ttl;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = collection_ttl {
        local_var_form_params.insert("CollectionTtl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSyncListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSyncListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_sync_list_item(configuration: &configuration::Configuration, params: UpdateSyncListItemParams) -> Result<ResponseContent<UpdateSyncListItemSuccess>, Error<UpdateSyncListItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let list_sid = params.list_sid;
    let index = params.index;
    let if_match = params.if_match;
    let collection_ttl = params.collection_ttl;
    let data = params.data;
    let item_ttl = params.item_ttl;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ListSid=crate::apis::urlencode(list_sid), Index=index);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = if_match {
        local_var_req_builder = local_var_req_builder.header("If-Match", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = collection_ttl {
        local_var_form_params.insert("CollectionTtl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = data {
        local_var_form_params.insert("Data", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = item_ttl {
        local_var_form_params.insert("ItemTtl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSyncListItemSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSyncListItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an identity's access to a specific Sync List.
pub async fn update_sync_list_permission(configuration: &configuration::Configuration, params: UpdateSyncListPermissionParams) -> Result<ResponseContent<UpdateSyncListPermissionSuccess>, Error<UpdateSyncListPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let list_sid = params.list_sid;
    let identity = params.identity;
    let manage = params.manage;
    let read = params.read;
    let write = params.write;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), ListSid=crate::apis::urlencode(list_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Manage", manage.to_string());
    local_var_form_params.insert("Read", read.to_string());
    local_var_form_params.insert("Write", write.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSyncListPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSyncListPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_sync_map(configuration: &configuration::Configuration, params: UpdateSyncMapParams) -> Result<ResponseContent<UpdateSyncMapSuccess>, Error<UpdateSyncMapError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let collection_ttl = params.collection_ttl;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = collection_ttl {
        local_var_form_params.insert("CollectionTtl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSyncMapSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSyncMapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_sync_map_item(configuration: &configuration::Configuration, params: UpdateSyncMapItemParams) -> Result<ResponseContent<UpdateSyncMapItemSuccess>, Error<UpdateSyncMapItemError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let map_sid = params.map_sid;
    let key = params.key;
    let if_match = params.if_match;
    let collection_ttl = params.collection_ttl;
    let data = params.data;
    let item_ttl = params.item_ttl;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), MapSid=crate::apis::urlencode(map_sid), Key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = if_match {
        local_var_req_builder = local_var_req_builder.header("If-Match", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = collection_ttl {
        local_var_form_params.insert("CollectionTtl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = data {
        local_var_form_params.insert("Data", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = item_ttl {
        local_var_form_params.insert("ItemTtl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSyncMapItemSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSyncMapItemError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an identity's access to a specific Sync Map.
pub async fn update_sync_map_permission(configuration: &configuration::Configuration, params: UpdateSyncMapPermissionParams) -> Result<ResponseContent<UpdateSyncMapPermissionSuccess>, Error<UpdateSyncMapPermissionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let map_sid = params.map_sid;
    let identity = params.identity;
    let manage = params.manage;
    let read = params.read;
    let write = params.write;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), MapSid=crate::apis::urlencode(map_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Manage", manage.to_string());
    local_var_form_params.insert("Read", read.to_string());
    local_var_form_params.insert("Write", write.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSyncMapPermissionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSyncMapPermissionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Stream.
pub async fn update_sync_stream(configuration: &configuration::Configuration, params: UpdateSyncStreamParams) -> Result<ResponseContent<UpdateSyncStreamSuccess>, Error<UpdateSyncStreamError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Services/{ServiceSid}/Streams/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSyncStreamSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSyncStreamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

