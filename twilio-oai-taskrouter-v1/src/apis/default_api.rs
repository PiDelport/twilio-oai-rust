/*
 * Twilio - Taskrouter
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.2
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_activity`
#[derive(Clone, Debug, Default)]
pub struct CreateActivityParams {
    /// The SID of the Workspace that the new Activity belongs to.
    pub workspace_sid: String,
    /// A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.
    pub friendly_name: String,
    /// Whether the Worker should be eligible to receive a Task when it occupies the Activity. A value of `true`, `1`, or `yes` specifies the Activity is available. All other values specify that it is not. The value cannot be changed after the Activity is created.
    pub available: Option<bool>
}

/// struct for passing parameters to the method `create_task`
#[derive(Clone, Debug, Default)]
pub struct CreateTaskParams {
    /// The SID of the Workspace that the new Task belongs to.
    pub workspace_sid: String,
    /// A URL-encoded JSON string with the attributes of the new task. This value is passed to the Workflow's `assignment_callback_url` when the Task is assigned to a Worker. For example: `{ \\\"task_type\\\": \\\"call\\\", \\\"twilio_call_sid\\\": \\\"CAxxx\\\", \\\"customer_ticket_number\\\": \\\"12345\\\" }`.
    pub attributes: Option<String>,
    /// The priority to assign the new task and override the default. When supplied, the new Task will have this priority unless it matches a Workflow Target with a Priority set. When not supplied, the new Task will have the priority of the matching Workflow Target. Value can be 0 to 2^31^ (2,147,483,647).
    pub priority: Option<i32>,
    /// When MultiTasking is enabled, specify the TaskChannel by passing either its `unique_name` or `sid`. Default value is `default`.
    pub task_channel: Option<String>,
    /// The amount of time in seconds the new task can live before being assigned. Can be up to a maximum of 2 weeks (1,209,600 seconds). The default value is 24 hours (86,400 seconds). On timeout, the `task.canceled` event will fire with description `Task TTL Exceeded`.
    pub timeout: Option<i32>,
    /// The SID of the Workflow that you would like to handle routing for the new Task. If there is only one Workflow defined for the Workspace that you are posting the new task to, this parameter is optional.
    pub workflow_sid: Option<String>
}

/// struct for passing parameters to the method `create_task_channel`
#[derive(Clone, Debug, Default)]
pub struct CreateTaskChannelParams {
    /// The SID of the Workspace that the new Task Channel belongs to.
    pub workspace_sid: String,
    /// A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.
    pub friendly_name: String,
    /// An application-defined string that uniquely identifies the Task Channel, such as `voice` or `sms`.
    pub unique_name: String,
    /// Whether the Task Channel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.
    pub channel_optimized_routing: Option<bool>
}

/// struct for passing parameters to the method `create_task_queue`
#[derive(Clone, Debug, Default)]
pub struct CreateTaskQueueParams {
    /// The SID of the Workspace that the new TaskQueue belongs to.
    pub workspace_sid: String,
    /// A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.
    pub friendly_name: String,
    /// The SID of the Activity to assign Workers when a task is assigned to them.
    pub assignment_activity_sid: Option<String>,
    /// The maximum number of Workers to reserve for the assignment of a Task in the queue. Can be an integer between 1 and 50, inclusive and defaults to 1.
    pub max_reserved_workers: Option<i32>,
    /// The SID of the Activity to assign Workers when a task is reserved for them.
    pub reservation_activity_sid: Option<String>,
    /// A string that describes the Worker selection criteria for any Tasks that enter the TaskQueue. For example, `'\\\"language\\\" == \\\"spanish\\\"'`. The default value is `1==1`. If this value is empty, Tasks will wait in the TaskQueue until they are deleted or moved to another TaskQueue. For more information about Worker selection, see [Describing Worker selection criteria](https://www.twilio.com/docs/taskrouter/api/taskqueues#target-workers).
    pub target_workers: Option<String>,
    /// How Tasks will be assigned to Workers. Set this parameter to `LIFO` to assign most recently created Task first or FIFO to assign the oldest Task first. Default is `FIFO`. [Click here](https://www.twilio.com/docs/taskrouter/queue-ordering-last-first-out-lifo) to learn more.
    pub task_order: Option<String>
}

/// struct for passing parameters to the method `create_worker`
#[derive(Clone, Debug, Default)]
pub struct CreateWorkerParams {
    /// The SID of the Workspace that the new Worker belongs to.
    pub workspace_sid: String,
    /// A descriptive string that you create to describe the new Worker. It can be up to 64 characters long.
    pub friendly_name: String,
    /// The SID of a valid Activity that will describe the new Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information. If not provided, the new Worker's initial state is the `default_activity_sid` configured on the Workspace.
    pub activity_sid: Option<String>,
    /// A valid JSON string that describes the new Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.
    pub attributes: Option<String>
}

/// struct for passing parameters to the method `create_workflow`
#[derive(Clone, Debug, Default)]
pub struct CreateWorkflowParams {
    /// The SID of the Workspace that the new Workflow to create belongs to.
    pub workspace_sid: String,
    /// A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.
    pub configuration: String,
    /// A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.
    pub friendly_name: String,
    /// The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.
    pub assignment_callback_url: Option<String>,
    /// The URL that we should call when a call to the `assignment_callback_url` fails.
    pub fallback_assignment_callback_url: Option<String>,
    /// How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.
    pub task_reservation_timeout: Option<i32>
}

/// struct for passing parameters to the method `create_workspace`
#[derive(Clone, Debug, Default)]
pub struct CreateWorkspaceParams {
    /// A descriptive string that you create to describe the Workspace resource. It can be up to 64 characters long. For example: `Customer Support` or `2014 Election Campaign`.
    pub friendly_name: String,
    /// The URL we should call when an event occurs. If provided, the Workspace will publish events to this URL, for example, to collect data for reporting. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information.
    pub event_callback_url: Option<String>,
    /// The list of Workspace events for which to call event_callback_url. For example, if `EventsFilter=task.created, task.canceled, worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.
    pub events_filter: Option<String>,
    /// Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be created as multi-tasking. The default is `true`. Multi-tasking allows Workers to handle multiple Tasks simultaneously. When enabled (`true`), each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).
    pub multi_task_enabled: Option<bool>,
    /// The type of TaskQueue to prioritize when Workers are receiving Tasks from both types of TaskQueues. Can be: `LIFO` or `FIFO` and the default is `FIFO`. For more information, see [Queue Ordering](https://www.twilio.com/docs/taskrouter/queue-ordering-last-first-out-lifo).
    pub prioritize_queue_order: Option<String>,
    /// An available template name. Can be: `NONE` or `FIFO` and the default is `NONE`. Pre-configures the Workspace with the Workflow and Activities specified in the template. `NONE` will create a Workspace with only a set of default activities. `FIFO` will configure TaskRouter with a set of default activities and a single TaskQueue for first-in, first-out distribution, which can be useful when you are getting started with TaskRouter.
    pub template: Option<String>
}

/// struct for passing parameters to the method `delete_activity`
#[derive(Clone, Debug, Default)]
pub struct DeleteActivityParams {
    /// The SID of the Workspace with the Activity resources to delete.
    pub workspace_sid: String,
    /// The SID of the Activity resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_task`
#[derive(Clone, Debug, Default)]
pub struct DeleteTaskParams {
    /// The SID of the Workspace with the Task to delete.
    pub workspace_sid: String,
    /// The SID of the Task resource to delete.
    pub sid: String,
    /// If provided, deletes this Task if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
    pub if_match: Option<String>
}

/// struct for passing parameters to the method `delete_task_channel`
#[derive(Clone, Debug, Default)]
pub struct DeleteTaskChannelParams {
    /// The SID of the Workspace with the Task Channel to delete.
    pub workspace_sid: String,
    /// The SID of the Task Channel resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_task_queue`
#[derive(Clone, Debug, Default)]
pub struct DeleteTaskQueueParams {
    /// The SID of the Workspace with the TaskQueue to delete.
    pub workspace_sid: String,
    /// The SID of the TaskQueue resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_worker`
#[derive(Clone, Debug, Default)]
pub struct DeleteWorkerParams {
    /// The SID of the Workspace with the Worker to delete.
    pub workspace_sid: String,
    /// The SID of the Worker resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_workflow`
#[derive(Clone, Debug, Default)]
pub struct DeleteWorkflowParams {
    /// The SID of the Workspace with the Workflow to delete.
    pub workspace_sid: String,
    /// The SID of the Workflow resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_workspace`
#[derive(Clone, Debug, Default)]
pub struct DeleteWorkspaceParams {
    /// The SID of the Workspace resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_activity`
#[derive(Clone, Debug, Default)]
pub struct FetchActivityParams {
    /// The SID of the Workspace with the Activity resources to fetch.
    pub workspace_sid: String,
    /// The SID of the Activity resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_event`
#[derive(Clone, Debug, Default)]
pub struct FetchEventParams {
    /// The SID of the Workspace with the Event to fetch.
    pub workspace_sid: String,
    /// The SID of the Event resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_task`
#[derive(Clone, Debug, Default)]
pub struct FetchTaskParams {
    /// The SID of the Workspace with the Task to fetch.
    pub workspace_sid: String,
    /// The SID of the Task resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_task_channel`
#[derive(Clone, Debug, Default)]
pub struct FetchTaskChannelParams {
    /// The SID of the Workspace with the Task Channel to fetch.
    pub workspace_sid: String,
    /// The SID of the Task Channel resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_task_queue`
#[derive(Clone, Debug, Default)]
pub struct FetchTaskQueueParams {
    /// The SID of the Workspace with the TaskQueue to fetch.
    pub workspace_sid: String,
    /// The SID of the TaskQueue resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_task_queue_cumulative_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchTaskQueueCumulativeStatisticsParams {
    /// The SID of the Workspace with the TaskQueue to fetch.
    pub workspace_sid: String,
    /// The SID of the TaskQueue for which to fetch statistics.
    pub task_queue_sid: String,
    /// Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
    pub end_date: Option<String>,
    /// Only calculate statistics since this many minutes in the past. The default is 15 minutes.
    pub minutes: Option<i32>,
    /// Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub start_date: Option<String>,
    /// Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>,
    /// A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
    pub split_by_wait_time: Option<String>
}

/// struct for passing parameters to the method `fetch_task_queue_real_time_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchTaskQueueRealTimeStatisticsParams {
    /// The SID of the Workspace with the TaskQueue to fetch.
    pub workspace_sid: String,
    /// The SID of the TaskQueue for which to fetch statistics.
    pub task_queue_sid: String,
    /// The TaskChannel for which to fetch statistics. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>
}

/// struct for passing parameters to the method `fetch_task_queue_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchTaskQueueStatisticsParams {
    /// The SID of the Workspace with the TaskQueue to fetch.
    pub workspace_sid: String,
    /// The SID of the TaskQueue for which to fetch statistics.
    pub task_queue_sid: String,
    /// Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
    pub end_date: Option<String>,
    /// Only calculate statistics since this many minutes in the past. The default is 15 minutes.
    pub minutes: Option<i32>,
    /// Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub start_date: Option<String>,
    /// Only calculate real-time and cumulative statistics for the specified TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>,
    /// A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
    pub split_by_wait_time: Option<String>
}

/// struct for passing parameters to the method `fetch_task_reservation`
#[derive(Clone, Debug, Default)]
pub struct FetchTaskReservationParams {
    /// The SID of the Workspace with the TaskReservation resource to fetch.
    pub workspace_sid: String,
    /// The SID of the reserved Task resource with the TaskReservation resource to fetch.
    pub task_sid: String,
    /// The SID of the TaskReservation resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_worker`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkerParams {
    /// The SID of the Workspace with the Worker to fetch.
    pub workspace_sid: String,
    /// The SID of the Worker resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_worker_channel`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkerChannelParams {
    /// The SID of the Workspace with the WorkerChannel to fetch.
    pub workspace_sid: String,
    /// The SID of the Worker with the WorkerChannel to fetch.
    pub worker_sid: String,
    /// The SID of the WorkerChannel to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_worker_instance_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkerInstanceStatisticsParams {
    /// The SID of the Workspace with the WorkerChannel to fetch.
    pub workspace_sid: String,
    /// The SID of the Worker with the WorkerChannel to fetch.
    pub worker_sid: String,
    /// Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
    pub minutes: Option<i32>,
    /// Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub start_date: Option<String>,
    /// Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
    pub end_date: Option<String>,
    /// Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>
}

/// struct for passing parameters to the method `fetch_worker_reservation`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkerReservationParams {
    /// The SID of the Workspace with the WorkerReservation resource to fetch.
    pub workspace_sid: String,
    /// The SID of the reserved Worker resource with the WorkerReservation resource to fetch.
    pub worker_sid: String,
    /// The SID of the WorkerReservation resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_worker_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkerStatisticsParams {
    /// The SID of the Workspace with the Worker to fetch.
    pub workspace_sid: String,
    /// Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
    pub minutes: Option<i32>,
    /// Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub start_date: Option<String>,
    /// Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
    pub end_date: Option<String>,
    /// The SID of the TaskQueue for which to fetch Worker statistics.
    pub task_queue_sid: Option<String>,
    /// The `friendly_name` of the TaskQueue for which to fetch Worker statistics.
    pub task_queue_name: Option<String>,
    /// Only include Workers with `friendly_name` values that match this parameter.
    pub friendly_name: Option<String>,
    /// Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>
}

/// struct for passing parameters to the method `fetch_workers_cumulative_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkersCumulativeStatisticsParams {
    /// The SID of the Workspace with the resource to fetch.
    pub workspace_sid: String,
    /// Only calculate statistics from this date and time and earlier, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub end_date: Option<String>,
    /// Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
    pub minutes: Option<i32>,
    /// Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub start_date: Option<String>,
    /// Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>
}

/// struct for passing parameters to the method `fetch_workers_real_time_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkersRealTimeStatisticsParams {
    /// The SID of the Workspace with the resource to fetch.
    pub workspace_sid: String,
    /// Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>
}

/// struct for passing parameters to the method `fetch_workflow`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkflowParams {
    /// The SID of the Workspace with the Workflow to fetch.
    pub workspace_sid: String,
    /// The SID of the Workflow resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_workflow_cumulative_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkflowCumulativeStatisticsParams {
    /// The SID of the Workspace with the resource to fetch.
    pub workspace_sid: String,
    /// Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value.
    pub workflow_sid: String,
    /// Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
    pub end_date: Option<String>,
    /// Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
    pub minutes: Option<i32>,
    /// Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub start_date: Option<String>,
    /// Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>,
    /// A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
    pub split_by_wait_time: Option<String>
}

/// struct for passing parameters to the method `fetch_workflow_real_time_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkflowRealTimeStatisticsParams {
    /// The SID of the Workspace with the Workflow to fetch.
    pub workspace_sid: String,
    /// Returns the list of Tasks that are being controlled by the Workflow with the specified SID value.
    pub workflow_sid: String,
    /// Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>
}

/// struct for passing parameters to the method `fetch_workflow_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkflowStatisticsParams {
    /// The SID of the Workspace with the Workflow to fetch.
    pub workspace_sid: String,
    /// Returns the list of Tasks that are being controlled by the Workflow with the specified SID value.
    pub workflow_sid: String,
    /// Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
    pub minutes: Option<i32>,
    /// Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub start_date: Option<String>,
    /// Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
    pub end_date: Option<String>,
    /// Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>,
    /// A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
    pub split_by_wait_time: Option<String>
}

/// struct for passing parameters to the method `fetch_workspace`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkspaceParams {
    /// The SID of the Workspace resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_workspace_cumulative_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkspaceCumulativeStatisticsParams {
    /// The SID of the Workspace to fetch.
    pub workspace_sid: String,
    /// Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
    pub end_date: Option<String>,
    /// Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
    pub minutes: Option<i32>,
    /// Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub start_date: Option<String>,
    /// Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>,
    /// A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
    pub split_by_wait_time: Option<String>
}

/// struct for passing parameters to the method `fetch_workspace_real_time_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkspaceRealTimeStatisticsParams {
    /// The SID of the Workspace to fetch.
    pub workspace_sid: String,
    /// Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>
}

/// struct for passing parameters to the method `fetch_workspace_statistics`
#[derive(Clone, Debug, Default)]
pub struct FetchWorkspaceStatisticsParams {
    /// The SID of the Workspace to fetch.
    pub workspace_sid: String,
    /// Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
    pub minutes: Option<i32>,
    /// Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub start_date: Option<String>,
    /// Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
    pub end_date: Option<String>,
    /// Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>,
    /// A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
    pub split_by_wait_time: Option<String>
}

/// struct for passing parameters to the method `list_activity`
#[derive(Clone, Debug, Default)]
pub struct ListActivityParams {
    /// The SID of the Workspace with the Activity resources to read.
    pub workspace_sid: String,
    /// The `friendly_name` of the Activity resources to read.
    pub friendly_name: Option<String>,
    /// Whether return only Activity resources that are available or unavailable. A value of `true` returns only available activities. Values of '1' or `yes` also indicate `true`. All other values represent `false` and return activities that are unavailable.
    pub available: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_event`
#[derive(Clone, Debug, Default)]
pub struct ListEventParams {
    /// The SID of the Workspace with the Events to read. Returns only the Events that pertain to the specified Workspace.
    pub workspace_sid: String,
    /// Only include Events that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
    pub end_date: Option<String>,
    /// The type of Events to read. Returns only Events of the type specified.
    pub event_type: Option<String>,
    /// The period of events to read in minutes. Returns only Events that occurred since this many minutes in the past. The default is `15` minutes. Task Attributes for Events occuring more 43,200 minutes ago will be redacted.
    pub minutes: Option<i32>,
    /// The SID of the Reservation with the Events to read. Returns only Events that pertain to the specified Reservation.
    pub reservation_sid: Option<String>,
    /// Only include Events from on or after this date and time, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. Task Attributes for Events older than 30 days will be redacted.
    pub start_date: Option<String>,
    /// The SID of the TaskQueue with the Events to read. Returns only the Events that pertain to the specified TaskQueue.
    pub task_queue_sid: Option<String>,
    /// The SID of the Task with the Events to read. Returns only the Events that pertain to the specified Task.
    pub task_sid: Option<String>,
    /// The SID of the Worker with the Events to read. Returns only the Events that pertain to the specified Worker.
    pub worker_sid: Option<String>,
    /// The SID of the Workflow with the Events to read. Returns only the Events that pertain to the specified Workflow.
    pub workflow_sid: Option<String>,
    /// The TaskChannel with the Events to read. Returns only the Events that pertain to the specified TaskChannel.
    pub task_channel: Option<String>,
    /// The SID of the Event resource to read.
    pub sid: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_task`
#[derive(Clone, Debug, Default)]
pub struct ListTaskParams {
    /// The SID of the Workspace with the Tasks to read.
    pub workspace_sid: String,
    /// The priority value of the Tasks to read. Returns the list of all Tasks in the Workspace with the specified priority.
    pub priority: Option<i32>,
    /// The `assignment_status` of the Tasks you want to read. Can be: `pending`, `reserved`, `assigned`, `canceled`, `wrapping`, or `completed`. Returns all Tasks in the Workspace with the specified `assignment_status`.
    pub assignment_status: Option<Vec<String>>,
    /// The SID of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this SID.
    pub workflow_sid: Option<String>,
    /// The friendly name of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this friendly name.
    pub workflow_name: Option<String>,
    /// The SID of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this SID.
    pub task_queue_sid: Option<String>,
    /// The `friendly_name` of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this friendly name.
    pub task_queue_name: Option<String>,
    /// The attributes of the Tasks to read. Returns the Tasks that match the attributes specified in this parameter.
    pub evaluate_task_attributes: Option<String>,
    /// How to order the returned Task resources. y default, Tasks are sorted by ascending DateCreated. This value is specified as: `Attribute:Order`, where `Attribute` can be either `Priority` or `DateCreated` and `Order` can be either `asc` or `desc`. For example, `Priority:desc` returns Tasks ordered in descending order of their Priority. Multiple sort orders can be specified in a comma-separated list such as `Priority:desc,DateCreated:asc`, which returns the Tasks in descending Priority order and ascending DateCreated Order.
    pub ordering: Option<String>,
    /// Whether to read Tasks with addons. If `true`, returns only Tasks with addons. If `false`, returns only Tasks without addons.
    pub has_addons: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_task_channel`
#[derive(Clone, Debug, Default)]
pub struct ListTaskChannelParams {
    /// The SID of the Workspace with the Task Channel to read.
    pub workspace_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_task_queue`
#[derive(Clone, Debug, Default)]
pub struct ListTaskQueueParams {
    /// The SID of the Workspace with the TaskQueue to read.
    pub workspace_sid: String,
    /// The `friendly_name` of the TaskQueue resources to read.
    pub friendly_name: Option<String>,
    /// The attributes of the Workers to read. Returns the TaskQueues with Workers that match the attributes specified in this parameter.
    pub evaluate_worker_attributes: Option<String>,
    /// The SID of the Worker with the TaskQueue resources to read.
    pub worker_sid: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_task_queues_statistics`
#[derive(Clone, Debug, Default)]
pub struct ListTaskQueuesStatisticsParams {
    /// The SID of the Workspace with the TaskQueues to read.
    pub workspace_sid: String,
    /// Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
    pub end_date: Option<String>,
    /// The `friendly_name` of the TaskQueue statistics to read.
    pub friendly_name: Option<String>,
    /// Only calculate statistics since this many minutes in the past. The default is 15 minutes.
    pub minutes: Option<i32>,
    /// Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
    pub start_date: Option<String>,
    /// Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>,
    /// A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
    pub split_by_wait_time: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_task_reservation`
#[derive(Clone, Debug, Default)]
pub struct ListTaskReservationParams {
    /// The SID of the Workspace with the TaskReservation resources to read.
    pub workspace_sid: String,
    /// The SID of the reserved Task resource with the TaskReservation resources to read.
    pub task_sid: String,
    /// Returns the list of reservations for a task with a specified ReservationStatus.  Can be: `pending`, `accepted`, `rejected`, or `timeout`.
    pub reservation_status: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_worker`
#[derive(Clone, Debug, Default)]
pub struct ListWorkerParams {
    /// The SID of the Workspace with the Workers to read.
    pub workspace_sid: String,
    /// The `activity_name` of the Worker resources to read.
    pub activity_name: Option<String>,
    /// The `activity_sid` of the Worker resources to read.
    pub activity_sid: Option<String>,
    /// Whether to return only Worker resources that are available or unavailable. Can be `true`, `1`, or `yes` to return Worker resources that are available, and `false`, or any value returns the Worker resources that are not available.
    pub available: Option<String>,
    /// The `friendly_name` of the Worker resources to read.
    pub friendly_name: Option<String>,
    /// Filter by Workers that would match an expression on a TaskQueue. This is helpful for debugging which Workers would match a potential queue.
    pub target_workers_expression: Option<String>,
    /// The `friendly_name` of the TaskQueue that the Workers to read are eligible for.
    pub task_queue_name: Option<String>,
    /// The SID of the TaskQueue that the Workers to read are eligible for.
    pub task_queue_sid: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_worker_channel`
#[derive(Clone, Debug, Default)]
pub struct ListWorkerChannelParams {
    /// The SID of the Workspace with the WorkerChannels to read.
    pub workspace_sid: String,
    /// The SID of the Worker with the WorkerChannels to read.
    pub worker_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_worker_reservation`
#[derive(Clone, Debug, Default)]
pub struct ListWorkerReservationParams {
    /// The SID of the Workspace with the WorkerReservation resources to read.
    pub workspace_sid: String,
    /// The SID of the reserved Worker resource with the WorkerReservation resources to read.
    pub worker_sid: String,
    /// Returns the list of reservations for a worker with a specified ReservationStatus. Can be: `pending`, `accepted`, `rejected`, `timeout`, `canceled`, or `rescinded`.
    pub reservation_status: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_workflow`
#[derive(Clone, Debug, Default)]
pub struct ListWorkflowParams {
    /// The SID of the Workspace with the Workflow to read.
    pub workspace_sid: String,
    /// The `friendly_name` of the Workflow resources to read.
    pub friendly_name: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_workspace`
#[derive(Clone, Debug, Default)]
pub struct ListWorkspaceParams {
    /// The `friendly_name` of the Workspace resources to read. For example `Customer Support` or `2014 Election Campaign`.
    pub friendly_name: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_activity`
#[derive(Clone, Debug, Default)]
pub struct UpdateActivityParams {
    /// The SID of the Workspace with the Activity resources to update.
    pub workspace_sid: String,
    /// The SID of the Activity resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `update_task`
#[derive(Clone, Debug, Default)]
pub struct UpdateTaskParams {
    /// The SID of the Workspace with the Task to update.
    pub workspace_sid: String,
    /// The SID of the Task resource to update.
    pub sid: String,
    /// If provided, applies this mutation if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
    pub if_match: Option<String>,
    /// The new status of the task. Can be: `canceled`, to cancel a Task that is currently `pending` or `reserved`; `wrapping`, to move the Task to wrapup state; or `completed`, to move a Task to the completed state.
    pub assignment_status: Option<String>,
    /// The JSON string that describes the custom attributes of the task.
    pub attributes: Option<String>,
    /// The Task's new priority value. When supplied, the Task takes on the specified priority unless it matches a Workflow Target with a Priority set. Value can be 0 to 2^31^ (2,147,483,647).
    pub priority: Option<i32>,
    /// The reason that the Task was canceled or completed. This parameter is required only if the Task is canceled or completed. Setting this value queues the task for deletion and logs the reason.
    pub reason: Option<String>,
    /// When MultiTasking is enabled, specify the TaskChannel with the task to update. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
    pub task_channel: Option<String>
}

/// struct for passing parameters to the method `update_task_channel`
#[derive(Clone, Debug, Default)]
pub struct UpdateTaskChannelParams {
    /// The SID of the Workspace with the Task Channel to update.
    pub workspace_sid: String,
    /// The SID of the Task Channel resource to update.
    pub sid: String,
    /// Whether the TaskChannel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.
    pub channel_optimized_routing: Option<bool>,
    /// A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `update_task_queue`
#[derive(Clone, Debug, Default)]
pub struct UpdateTaskQueueParams {
    /// The SID of the Workspace with the TaskQueue to update.
    pub workspace_sid: String,
    /// The SID of the TaskQueue resource to update.
    pub sid: String,
    /// The SID of the Activity to assign Workers when a task is assigned for them.
    pub assignment_activity_sid: Option<String>,
    /// A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.
    pub friendly_name: Option<String>,
    /// The maximum number of Workers to create reservations for the assignment of a task while in the queue. Maximum of 50.
    pub max_reserved_workers: Option<i32>,
    /// The SID of the Activity to assign Workers when a task is reserved for them.
    pub reservation_activity_sid: Option<String>,
    /// A string describing the Worker selection criteria for any Tasks that enter the TaskQueue. For example '\\\"language\\\" == \\\"spanish\\\"' If no TargetWorkers parameter is provided, Tasks will wait in the queue until they are either deleted or moved to another queue. Additional examples on how to describing Worker selection criteria below.
    pub target_workers: Option<String>,
    /// How Tasks will be assigned to Workers. Can be: `FIFO` or `LIFO` and the default is `FIFO`. Use `FIFO` to assign the oldest task first and `LIFO` to assign the most recent task first. For more information, see [Queue Ordering](https://www.twilio.com/docs/taskrouter/queue-ordering-last-first-out-lifo).
    pub task_order: Option<String>
}

/// struct for passing parameters to the method `update_task_reservation`
#[derive(Clone, Debug, Default)]
pub struct UpdateTaskReservationParams {
    /// The SID of the Workspace with the TaskReservation resources to update.
    pub workspace_sid: String,
    /// The SID of the reserved Task resource with the TaskReservation resources to update.
    pub task_sid: String,
    /// The SID of the TaskReservation resource to update.
    pub sid: String,
    /// Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
    pub beep: Option<String>,
    /// Whether to play a notification beep when the customer joins.
    pub beep_on_customer_entrance: Option<bool>,
    /// Whether to accept a reservation when executing a Call instruction.
    pub call_accept: Option<bool>,
    /// The Caller ID of the outbound call when executing a Call instruction.
    pub call_from: Option<String>,
    /// Whether to record both legs of a call when executing a Call instruction or which leg to record.
    pub call_record: Option<String>,
    /// The URL to call  for the completed call event when executing a Call instruction.
    pub call_status_callback_url: Option<String>,
    /// Timeout for call when executing a Call instruction.
    pub call_timeout: Option<i32>,
    /// The Contact URI of the worker when executing a Call instruction.  Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
    pub call_to: Option<String>,
    /// TwiML URI executed on answering the worker's leg as a result of the Call instruction.
    pub call_url: Option<String>,
    /// Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
    pub conference_record: Option<String>,
    /// The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
    pub conference_recording_status_callback: Option<String>,
    /// The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub conference_recording_status_callback_method: Option<String>,
    /// The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
    pub conference_status_callback: Option<String>,
    /// The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.
    pub conference_status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub conference_status_callback_method: Option<String>,
    /// How to trim the leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
    pub conference_trim: Option<String>,
    /// The Caller ID of the call to the worker when executing a Dequeue instruction.
    pub dequeue_from: Option<String>,
    /// The SID of the Activity resource to start after executing a Dequeue instruction.
    pub dequeue_post_work_activity_sid: Option<String>,
    /// Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.
    pub dequeue_record: Option<String>,
    /// The Call progress events sent via webhooks as a result of a Dequeue instruction.
    pub dequeue_status_callback_event: Option<Vec<String>>,
    /// The Callback URL for completed call event when executing a Dequeue instruction.
    pub dequeue_status_callback_url: Option<String>,
    /// Timeout for call when executing a Dequeue instruction.
    pub dequeue_timeout: Option<i32>,
    /// The Contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
    pub dequeue_to: Option<String>,
    /// Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.
    pub early_media: Option<bool>,
    /// Whether to end the conference when the customer leaves.
    pub end_conference_on_customer_exit: Option<bool>,
    /// Whether to end the conference when the agent leaves.
    pub end_conference_on_exit: Option<bool>,
    /// The Caller ID of the call to the worker when executing a Conference instruction.
    pub from: Option<String>,
    /// The assignment instruction for reservation.
    pub instruction: Option<String>,
    /// The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
    pub max_participants: Option<i32>,
    /// Whether the agent is muted in the conference. The default is `false`.
    pub muted: Option<bool>,
    /// The new worker activity SID after executing a Conference instruction.
    pub post_work_activity_sid: Option<String>,
    /// Whether to record the participant and their conferences, including the time between conferences. The default is `false`.
    pub record: Option<bool>,
    /// The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
    pub recording_channels: Option<String>,
    /// The URL that we should call using the `recording_status_callback_method` when the recording status changes.
    pub recording_status_callback: Option<String>,
    /// The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub recording_status_callback_method: Option<String>,
    /// Whether the reservation should be accepted when executing a Redirect instruction.
    pub redirect_accept: Option<bool>,
    /// The Call SID of the call parked in the queue when executing a Redirect instruction.
    pub redirect_call_sid: Option<String>,
    /// TwiML URI to redirect the call to when executing the Redirect instruction.
    pub redirect_url: Option<String>,
    /// The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
    pub region: Option<String>,
    /// The new status of the reservation. Can be: `pending`, `accepted`, `rejected`, or `timeout`.
    pub reservation_status: Option<String>,
    /// The SIP password for authentication.
    pub sip_auth_password: Option<String>,
    /// The SIP username used for authentication.
    pub sip_auth_username: Option<String>,
    /// Whether to start the conference when the participant joins, if it has not already started. The default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
    pub start_conference_on_enter: Option<bool>,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.
    pub status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
    pub status_callback_method: Option<String>,
    /// The Supervisor SID/URI when executing the Supervise instruction.
    pub supervisor: Option<String>,
    /// The Supervisor mode when executing the Supervise instruction.
    pub supervisor_mode: Option<String>,
    /// Timeout for call when executing a Conference instruction.
    pub timeout: Option<i32>,
    /// The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
    pub to: Option<String>,
    /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
    pub wait_method: Option<String>,
    /// The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
    pub wait_url: Option<String>,
    /// The new worker activity SID if rejecting a reservation.
    pub worker_activity_sid: Option<String>
}

/// struct for passing parameters to the method `update_worker`
#[derive(Clone, Debug, Default)]
pub struct UpdateWorkerParams {
    /// The SID of the Workspace with the Worker to update.
    pub workspace_sid: String,
    /// The SID of the Worker resource to update.
    pub sid: String,
    /// The SID of a valid Activity that will describe the Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information.
    pub activity_sid: Option<String>,
    /// The JSON string that describes the Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.
    pub attributes: Option<String>,
    /// A descriptive string that you create to describe the Worker. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// Whether to reject pending reservations.
    pub reject_pending_reservations: Option<bool>
}

/// struct for passing parameters to the method `update_worker_channel`
#[derive(Clone, Debug, Default)]
pub struct UpdateWorkerChannelParams {
    /// The SID of the Workspace with the WorkerChannel to update.
    pub workspace_sid: String,
    /// The SID of the Worker with the WorkerChannel to update.
    pub worker_sid: String,
    /// The SID of the WorkerChannel to update.
    pub sid: String,
    /// Whether the WorkerChannel is available. Set to `false` to prevent the Worker from receiving any new Tasks of this TaskChannel type.
    pub available: Option<bool>,
    /// The total number of Tasks that the Worker should handle for the TaskChannel type. TaskRouter creates reservations for Tasks of this TaskChannel type up to the specified capacity. If the capacity is 0, no new reservations will be created.
    pub capacity: Option<i32>
}

/// struct for passing parameters to the method `update_worker_reservation`
#[derive(Clone, Debug, Default)]
pub struct UpdateWorkerReservationParams {
    /// The SID of the Workspace with the WorkerReservation resources to update.
    pub workspace_sid: String,
    /// The SID of the reserved Worker resource with the WorkerReservation resources to update.
    pub worker_sid: String,
    /// The SID of the WorkerReservation resource to update.
    pub sid: String,
    /// Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
    pub beep: Option<String>,
    /// Whether to play a notification beep when the customer joins.
    pub beep_on_customer_entrance: Option<bool>,
    /// Whether to accept a reservation when executing a Call instruction.
    pub call_accept: Option<bool>,
    /// The Caller ID of the outbound call when executing a Call instruction.
    pub call_from: Option<String>,
    /// Whether to record both legs of a call when executing a Call instruction.
    pub call_record: Option<String>,
    /// The URL to call for the completed call event when executing a Call instruction.
    pub call_status_callback_url: Option<String>,
    /// The timeout for a call when executing a Call instruction.
    pub call_timeout: Option<i32>,
    /// The contact URI of the worker when executing a Call instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
    pub call_to: Option<String>,
    /// TwiML URI executed on answering the worker's leg as a result of the Call instruction.
    pub call_url: Option<String>,
    /// Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
    pub conference_record: Option<String>,
    /// The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
    pub conference_recording_status_callback: Option<String>,
    /// The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub conference_recording_status_callback_method: Option<String>,
    /// The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
    pub conference_status_callback: Option<String>,
    /// The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.
    pub conference_status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub conference_status_callback_method: Option<String>,
    /// Whether to trim leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
    pub conference_trim: Option<String>,
    /// The caller ID of the call to the worker when executing a Dequeue instruction.
    pub dequeue_from: Option<String>,
    /// The SID of the Activity resource to start after executing a Dequeue instruction.
    pub dequeue_post_work_activity_sid: Option<String>,
    /// Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.
    pub dequeue_record: Option<String>,
    /// The call progress events sent via webhooks as a result of a Dequeue instruction.
    pub dequeue_status_callback_event: Option<Vec<String>>,
    /// The callback URL for completed call event when executing a Dequeue instruction.
    pub dequeue_status_callback_url: Option<String>,
    /// The timeout for call when executing a Dequeue instruction.
    pub dequeue_timeout: Option<i32>,
    /// The contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
    pub dequeue_to: Option<String>,
    /// Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.
    pub early_media: Option<bool>,
    /// Whether to end the conference when the customer leaves.
    pub end_conference_on_customer_exit: Option<bool>,
    /// Whether to end the conference when the agent leaves.
    pub end_conference_on_exit: Option<bool>,
    /// The caller ID of the call to the worker when executing a Conference instruction.
    pub from: Option<String>,
    /// The assignment instruction for the reservation.
    pub instruction: Option<String>,
    /// The maximum number of participants allowed in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
    pub max_participants: Option<i32>,
    /// Whether the agent is muted in the conference. Defaults to `false`.
    pub muted: Option<bool>,
    /// The new worker activity SID after executing a Conference instruction.
    pub post_work_activity_sid: Option<String>,
    /// Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.
    pub record: Option<bool>,
    /// The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
    pub recording_channels: Option<String>,
    /// The URL that we should call using the `recording_status_callback_method` when the recording status changes.
    pub recording_status_callback: Option<String>,
    /// The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub recording_status_callback_method: Option<String>,
    /// Whether the reservation should be accepted when executing a Redirect instruction.
    pub redirect_accept: Option<bool>,
    /// The Call SID of the call parked in the queue when executing a Redirect instruction.
    pub redirect_call_sid: Option<String>,
    /// TwiML URI to redirect the call to when executing the Redirect instruction.
    pub redirect_url: Option<String>,
    /// The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
    pub region: Option<String>,
    /// The new status of the reservation. Can be: `pending`, `accepted`, `rejected`, `timeout`, `canceled`, or `rescinded`.
    pub reservation_status: Option<String>,
    /// The SIP password for authentication.
    pub sip_auth_password: Option<String>,
    /// The SIP username used for authentication.
    pub sip_auth_username: Option<String>,
    /// Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
    pub start_conference_on_enter: Option<bool>,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.
    pub status_callback_event: Option<Vec<String>>,
    /// The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
    pub status_callback_method: Option<String>,
    /// The timeout for a call when executing a Conference instruction.
    pub timeout: Option<i32>,
    /// The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
    pub to: Option<String>,
    /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
    pub wait_method: Option<String>,
    /// The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
    pub wait_url: Option<String>,
    /// The new worker activity SID if rejecting a reservation.
    pub worker_activity_sid: Option<String>
}

/// struct for passing parameters to the method `update_workflow`
#[derive(Clone, Debug, Default)]
pub struct UpdateWorkflowParams {
    /// The SID of the Workspace with the Workflow to update.
    pub workspace_sid: String,
    /// The SID of the Workflow resource to update.
    pub sid: String,
    /// The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.
    pub assignment_callback_url: Option<String>,
    /// A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.
    pub configuration: Option<String>,
    /// The URL that we should call when a call to the `assignment_callback_url` fails.
    pub fallback_assignment_callback_url: Option<String>,
    /// A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.
    pub friendly_name: Option<String>,
    /// Whether or not to re-evaluate Tasks. The default is `false`, which means Tasks in the Workflow will not be processed through the assignment loop again.
    pub re_evaluate_tasks: Option<String>,
    /// How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.
    pub task_reservation_timeout: Option<i32>
}

/// struct for passing parameters to the method `update_workspace`
#[derive(Clone, Debug, Default)]
pub struct UpdateWorkspaceParams {
    /// The SID of the Workspace resource to update.
    pub sid: String,
    /// The SID of the Activity that will be used when new Workers are created in the Workspace.
    pub default_activity_sid: Option<String>,
    /// The URL we should call when an event occurs. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information.
    pub event_callback_url: Option<String>,
    /// The list of Workspace events for which to call event_callback_url. For example if `EventsFilter=task.created,task.canceled,worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.
    pub events_filter: Option<String>,
    /// A descriptive string that you create to describe the Workspace resource. For example: `Sales Call Center` or `Customer Support Team`.
    pub friendly_name: Option<String>,
    /// Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. However, all workspaces should be maintained as multi-tasking. There is no default when omitting this parameter. A multi-tasking Workspace can't be updated to single-tasking unless it is not a Flex Project and another (legacy) single-tasking Workspace exists. Multi-tasking allows Workers to handle multiple Tasks simultaneously. In multi-tasking mode, each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. In single-tasking mode (legacy mode), each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).
    pub multi_task_enabled: Option<bool>,
    /// The type of TaskQueue to prioritize when Workers are receiving Tasks from both types of TaskQueues. Can be: `LIFO` or `FIFO`. For more information, see [Queue Ordering](https://www.twilio.com/docs/taskrouter/queue-ordering-last-first-out-lifo).
    pub prioritize_queue_order: Option<String>,
    /// The SID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.
    pub timeout_activity_sid: Option<String>
}


/// struct for typed successes of method `create_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateActivitySuccess {
    Status201(crate::models::TaskrouterV1WorkspaceActivity),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskSuccess {
    Status201(crate::models::TaskrouterV1WorkspaceTask),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_task_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskChannelSuccess {
    Status201(crate::models::TaskrouterV1WorkspaceTaskChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_task_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskQueueSuccess {
    Status201(crate::models::TaskrouterV1WorkspaceTaskQueue),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_worker`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWorkerSuccess {
    Status201(crate::models::TaskrouterV1WorkspaceWorker),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_workflow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWorkflowSuccess {
    Status201(crate::models::TaskrouterV1WorkspaceWorkflow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_workspace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWorkspaceSuccess {
    Status201(crate::models::TaskrouterV1Workspace),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteActivitySuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTaskSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_task_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTaskChannelSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_task_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTaskQueueSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_worker`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWorkerSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_workflow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWorkflowSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_workspace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWorkspaceSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchActivitySuccess {
    Status200(crate::models::TaskrouterV1WorkspaceActivity),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_event`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEventSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceEvent),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTask),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_task_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskChannelSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTaskChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_task_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskQueueSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTaskQueue),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_task_queue_cumulative_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskQueueCumulativeStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_task_queue_real_time_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskQueueRealTimeStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_task_queue_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskQueueStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_task_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskReservationSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTaskTaskReservation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_worker`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkerSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorker),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_worker_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkerChannelSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkerWorkerChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_worker_instance_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkerInstanceStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_worker_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkerReservationSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkerWorkerReservation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_worker_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkerStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkerWorkerStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_workers_cumulative_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkersCumulativeStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_workers_real_time_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkersRealTimeStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_workflow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkflowSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkflow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_workflow_cumulative_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkflowCumulativeStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_workflow_real_time_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkflowRealTimeStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_workflow_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkflowStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkflowWorkflowStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_workspace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkspaceSuccess {
    Status200(crate::models::TaskrouterV1Workspace),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_workspace_cumulative_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkspaceCumulativeStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkspaceCumulativeStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_workspace_real_time_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkspaceRealTimeStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkspaceRealTimeStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_workspace_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkspaceStatisticsSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkspaceStatistics),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListActivitySuccess {
    Status200(crate::models::ListActivityResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_event`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEventSuccess {
    Status200(crate::models::ListEventResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskSuccess {
    Status200(crate::models::ListTaskResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_task_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskChannelSuccess {
    Status200(crate::models::ListTaskChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_task_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskQueueSuccess {
    Status200(crate::models::ListTaskQueueResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_task_queues_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskQueuesStatisticsSuccess {
    Status200(crate::models::ListTaskQueuesStatisticsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_task_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskReservationSuccess {
    Status200(crate::models::ListTaskReservationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_worker`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkerSuccess {
    Status200(crate::models::ListWorkerResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_worker_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkerChannelSuccess {
    Status200(crate::models::ListWorkerChannelResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_worker_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkerReservationSuccess {
    Status200(crate::models::ListWorkerReservationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_workflow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkflowSuccess {
    Status200(crate::models::ListWorkflowResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_workspace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkspaceSuccess {
    Status200(crate::models::ListWorkspaceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateActivitySuccess {
    Status200(crate::models::TaskrouterV1WorkspaceActivity),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTask),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_task_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskChannelSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTaskChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_task_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskQueueSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTaskQueue),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_task_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskReservationSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceTaskTaskReservation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_worker`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkerSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorker),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_worker_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkerChannelSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkerWorkerChannel),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_worker_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkerReservationSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkerWorkerReservation),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_workflow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkflowSuccess {
    Status200(crate::models::TaskrouterV1WorkspaceWorkflow),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_workspace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkspaceSuccess {
    Status200(crate::models::TaskrouterV1Workspace),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateActivityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_task_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_task_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTaskQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_worker`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWorkerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_workflow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWorkflowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_workspace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWorkspaceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteActivityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_task_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTaskChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_task_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTaskQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_worker`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWorkerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_workflow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWorkflowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_workspace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWorkspaceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchActivityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_event`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_task_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_task_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_task_queue_cumulative_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskQueueCumulativeStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_task_queue_real_time_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskQueueRealTimeStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_task_queue_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskQueueStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_task_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTaskReservationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_worker`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_worker_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkerChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_worker_instance_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkerInstanceStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_worker_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkerReservationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_worker_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkerStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_workers_cumulative_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkersCumulativeStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_workers_real_time_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkersRealTimeStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_workflow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkflowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_workflow_cumulative_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkflowCumulativeStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_workflow_real_time_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkflowRealTimeStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_workflow_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkflowStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_workspace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkspaceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_workspace_cumulative_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkspaceCumulativeStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_workspace_real_time_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkspaceRealTimeStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_workspace_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWorkspaceStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListActivityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_event`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_task_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_task_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_task_queues_statistics`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskQueuesStatisticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_task_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTaskReservationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_worker`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_worker_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkerChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_worker_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkerReservationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_workflow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkflowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_workspace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkspaceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_activity`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateActivityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_task`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_task_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_task_queue`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskQueueError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_task_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTaskReservationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_worker`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_worker_channel`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkerChannelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_worker_reservation`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkerReservationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_workflow`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkflowError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_workspace`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkspaceError {
    UnknownValue(serde_json::Value),
}


pub async fn create_activity(configuration: &configuration::Configuration, params: CreateActivityParams) -> Result<ResponseContent<CreateActivitySuccess>, Error<CreateActivityError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let friendly_name = params.friendly_name;
    let available = params.available;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Activities", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = available {
        local_var_form_params.insert("Available", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateActivitySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateActivityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_task(configuration: &configuration::Configuration, params: CreateTaskParams) -> Result<ResponseContent<CreateTaskSuccess>, Error<CreateTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let attributes = params.attributes;
    let priority = params.priority;
    let task_channel = params.task_channel;
    let timeout = params.timeout;
    let workflow_sid = params.workflow_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Tasks", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = priority {
        local_var_form_params.insert("Priority", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = task_channel {
        local_var_form_params.insert("TaskChannel", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timeout {
        local_var_form_params.insert("Timeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = workflow_sid {
        local_var_form_params.insert("WorkflowSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateTaskSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_task_channel(configuration: &configuration::Configuration, params: CreateTaskChannelParams) -> Result<ResponseContent<CreateTaskChannelSuccess>, Error<CreateTaskChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let friendly_name = params.friendly_name;
    let unique_name = params.unique_name;
    let channel_optimized_routing = params.channel_optimized_routing;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskChannels", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel_optimized_routing {
        local_var_form_params.insert("ChannelOptimizedRouting", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("UniqueName", unique_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateTaskChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateTaskChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_task_queue(configuration: &configuration::Configuration, params: CreateTaskQueueParams) -> Result<ResponseContent<CreateTaskQueueSuccess>, Error<CreateTaskQueueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let friendly_name = params.friendly_name;
    let assignment_activity_sid = params.assignment_activity_sid;
    let max_reserved_workers = params.max_reserved_workers;
    let reservation_activity_sid = params.reservation_activity_sid;
    let target_workers = params.target_workers;
    let task_order = params.task_order;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskQueues", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = assignment_activity_sid {
        local_var_form_params.insert("AssignmentActivitySid", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = max_reserved_workers {
        local_var_form_params.insert("MaxReservedWorkers", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reservation_activity_sid {
        local_var_form_params.insert("ReservationActivitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = target_workers {
        local_var_form_params.insert("TargetWorkers", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = task_order {
        local_var_form_params.insert("TaskOrder", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateTaskQueueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateTaskQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_worker(configuration: &configuration::Configuration, params: CreateWorkerParams) -> Result<ResponseContent<CreateWorkerSuccess>, Error<CreateWorkerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let friendly_name = params.friendly_name;
    let activity_sid = params.activity_sid;
    let attributes = params.attributes;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = activity_sid {
        local_var_form_params.insert("ActivitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateWorkerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateWorkerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_workflow(configuration: &configuration::Configuration, params: CreateWorkflowParams) -> Result<ResponseContent<CreateWorkflowSuccess>, Error<CreateWorkflowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let configuration = params.configuration;
    let friendly_name = params.friendly_name;
    let assignment_callback_url = params.assignment_callback_url;
    let fallback_assignment_callback_url = params.fallback_assignment_callback_url;
    let task_reservation_timeout = params.task_reservation_timeout;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workflows", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = assignment_callback_url {
        local_var_form_params.insert("AssignmentCallbackUrl", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Configuration", configuration.to_string());
    if let Some(local_var_param_value) = fallback_assignment_callback_url {
        local_var_form_params.insert("FallbackAssignmentCallbackUrl", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = task_reservation_timeout {
        local_var_form_params.insert("TaskReservationTimeout", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateWorkflowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateWorkflowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_workspace(configuration: &configuration::Configuration, params: CreateWorkspaceParams) -> Result<ResponseContent<CreateWorkspaceSuccess>, Error<CreateWorkspaceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let event_callback_url = params.event_callback_url;
    let events_filter = params.events_filter;
    let multi_task_enabled = params.multi_task_enabled;
    let prioritize_queue_order = params.prioritize_queue_order;
    let template = params.template;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = event_callback_url {
        local_var_form_params.insert("EventCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = events_filter {
        local_var_form_params.insert("EventsFilter", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = multi_task_enabled {
        local_var_form_params.insert("MultiTaskEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = prioritize_queue_order {
        local_var_form_params.insert("PrioritizeQueueOrder", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = template {
        local_var_form_params.insert("Template", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateWorkspaceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateWorkspaceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_activity(configuration: &configuration::Configuration, params: DeleteActivityParams) -> Result<ResponseContent<DeleteActivitySuccess>, Error<DeleteActivityError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteActivitySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteActivityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_task(configuration: &configuration::Configuration, params: DeleteTaskParams) -> Result<ResponseContent<DeleteTaskSuccess>, Error<DeleteTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;
    let if_match = params.if_match;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = if_match {
        local_var_req_builder = local_var_req_builder.header("If-Match", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteTaskSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_task_channel(configuration: &configuration::Configuration, params: DeleteTaskChannelParams) -> Result<ResponseContent<DeleteTaskChannelSuccess>, Error<DeleteTaskChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteTaskChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteTaskChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_task_queue(configuration: &configuration::Configuration, params: DeleteTaskQueueParams) -> Result<ResponseContent<DeleteTaskQueueSuccess>, Error<DeleteTaskQueueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteTaskQueueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteTaskQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_worker(configuration: &configuration::Configuration, params: DeleteWorkerParams) -> Result<ResponseContent<DeleteWorkerSuccess>, Error<DeleteWorkerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteWorkerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteWorkerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_workflow(configuration: &configuration::Configuration, params: DeleteWorkflowParams) -> Result<ResponseContent<DeleteWorkflowSuccess>, Error<DeleteWorkflowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteWorkflowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteWorkflowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_workspace(configuration: &configuration::Configuration, params: DeleteWorkspaceParams) -> Result<ResponseContent<DeleteWorkspaceSuccess>, Error<DeleteWorkspaceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteWorkspaceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteWorkspaceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_activity(configuration: &configuration::Configuration, params: FetchActivityParams) -> Result<ResponseContent<FetchActivitySuccess>, Error<FetchActivityError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchActivitySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchActivityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_event(configuration: &configuration::Configuration, params: FetchEventParams) -> Result<ResponseContent<FetchEventSuccess>, Error<FetchEventError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Events/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchEventSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchEventError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_task(configuration: &configuration::Configuration, params: FetchTaskParams) -> Result<ResponseContent<FetchTaskSuccess>, Error<FetchTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTaskSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_task_channel(configuration: &configuration::Configuration, params: FetchTaskChannelParams) -> Result<ResponseContent<FetchTaskChannelSuccess>, Error<FetchTaskChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTaskChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTaskChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_task_queue(configuration: &configuration::Configuration, params: FetchTaskQueueParams) -> Result<ResponseContent<FetchTaskQueueSuccess>, Error<FetchTaskQueueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTaskQueueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTaskQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_task_queue_cumulative_statistics(configuration: &configuration::Configuration, params: FetchTaskQueueCumulativeStatisticsParams) -> Result<ResponseContent<FetchTaskQueueCumulativeStatisticsSuccess>, Error<FetchTaskQueueCumulativeStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let task_queue_sid = params.task_queue_sid;
    let end_date = params.end_date;
    let minutes = params.minutes;
    let start_date = params.start_date;
    let task_channel = params.task_channel;
    let split_by_wait_time = params.split_by_wait_time;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/CumulativeStatistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), TaskQueueSid=crate::apis::urlencode(task_queue_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = split_by_wait_time {
        local_var_req_builder = local_var_req_builder.query(&[("SplitByWaitTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTaskQueueCumulativeStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTaskQueueCumulativeStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_task_queue_real_time_statistics(configuration: &configuration::Configuration, params: FetchTaskQueueRealTimeStatisticsParams) -> Result<ResponseContent<FetchTaskQueueRealTimeStatisticsSuccess>, Error<FetchTaskQueueRealTimeStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let task_queue_sid = params.task_queue_sid;
    let task_channel = params.task_channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/RealTimeStatistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), TaskQueueSid=crate::apis::urlencode(task_queue_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTaskQueueRealTimeStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTaskQueueRealTimeStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_task_queue_statistics(configuration: &configuration::Configuration, params: FetchTaskQueueStatisticsParams) -> Result<ResponseContent<FetchTaskQueueStatisticsSuccess>, Error<FetchTaskQueueStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let task_queue_sid = params.task_queue_sid;
    let end_date = params.end_date;
    let minutes = params.minutes;
    let start_date = params.start_date;
    let task_channel = params.task_channel;
    let split_by_wait_time = params.split_by_wait_time;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/Statistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), TaskQueueSid=crate::apis::urlencode(task_queue_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = split_by_wait_time {
        local_var_req_builder = local_var_req_builder.query(&[("SplitByWaitTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTaskQueueStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTaskQueueStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_task_reservation(configuration: &configuration::Configuration, params: FetchTaskReservationParams) -> Result<ResponseContent<FetchTaskReservationSuccess>, Error<FetchTaskReservationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let task_sid = params.task_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), TaskSid=crate::apis::urlencode(task_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTaskReservationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTaskReservationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_worker(configuration: &configuration::Configuration, params: FetchWorkerParams) -> Result<ResponseContent<FetchWorkerSuccess>, Error<FetchWorkerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_worker_channel(configuration: &configuration::Configuration, params: FetchWorkerChannelParams) -> Result<ResponseContent<FetchWorkerChannelSuccess>, Error<FetchWorkerChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let worker_sid = params.worker_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), WorkerSid=crate::apis::urlencode(worker_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkerChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkerChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_worker_instance_statistics(configuration: &configuration::Configuration, params: FetchWorkerInstanceStatisticsParams) -> Result<ResponseContent<FetchWorkerInstanceStatisticsSuccess>, Error<FetchWorkerInstanceStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let worker_sid = params.worker_sid;
    let minutes = params.minutes;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let task_channel = params.task_channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Statistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), WorkerSid=crate::apis::urlencode(worker_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkerInstanceStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkerInstanceStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_worker_reservation(configuration: &configuration::Configuration, params: FetchWorkerReservationParams) -> Result<ResponseContent<FetchWorkerReservationSuccess>, Error<FetchWorkerReservationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let worker_sid = params.worker_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), WorkerSid=crate::apis::urlencode(worker_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkerReservationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkerReservationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_worker_statistics(configuration: &configuration::Configuration, params: FetchWorkerStatisticsParams) -> Result<ResponseContent<FetchWorkerStatisticsSuccess>, Error<FetchWorkerStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let minutes = params.minutes;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let task_queue_sid = params.task_queue_sid;
    let task_queue_name = params.task_queue_name;
    let friendly_name = params.friendly_name;
    let task_channel = params.task_channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/Statistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_queue_sid {
        local_var_req_builder = local_var_req_builder.query(&[("TaskQueueSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_queue_name {
        local_var_req_builder = local_var_req_builder.query(&[("TaskQueueName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkerStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkerStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_workers_cumulative_statistics(configuration: &configuration::Configuration, params: FetchWorkersCumulativeStatisticsParams) -> Result<ResponseContent<FetchWorkersCumulativeStatisticsSuccess>, Error<FetchWorkersCumulativeStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let end_date = params.end_date;
    let minutes = params.minutes;
    let start_date = params.start_date;
    let task_channel = params.task_channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/CumulativeStatistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkersCumulativeStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkersCumulativeStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_workers_real_time_statistics(configuration: &configuration::Configuration, params: FetchWorkersRealTimeStatisticsParams) -> Result<ResponseContent<FetchWorkersRealTimeStatisticsSuccess>, Error<FetchWorkersRealTimeStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let task_channel = params.task_channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/RealTimeStatistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkersRealTimeStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkersRealTimeStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_workflow(configuration: &configuration::Configuration, params: FetchWorkflowParams) -> Result<ResponseContent<FetchWorkflowSuccess>, Error<FetchWorkflowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkflowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkflowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_workflow_cumulative_statistics(configuration: &configuration::Configuration, params: FetchWorkflowCumulativeStatisticsParams) -> Result<ResponseContent<FetchWorkflowCumulativeStatisticsSuccess>, Error<FetchWorkflowCumulativeStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let workflow_sid = params.workflow_sid;
    let end_date = params.end_date;
    let minutes = params.minutes;
    let start_date = params.start_date;
    let task_channel = params.task_channel;
    let split_by_wait_time = params.split_by_wait_time;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/CumulativeStatistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), WorkflowSid=crate::apis::urlencode(workflow_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = split_by_wait_time {
        local_var_req_builder = local_var_req_builder.query(&[("SplitByWaitTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkflowCumulativeStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkflowCumulativeStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_workflow_real_time_statistics(configuration: &configuration::Configuration, params: FetchWorkflowRealTimeStatisticsParams) -> Result<ResponseContent<FetchWorkflowRealTimeStatisticsSuccess>, Error<FetchWorkflowRealTimeStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let workflow_sid = params.workflow_sid;
    let task_channel = params.task_channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/RealTimeStatistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), WorkflowSid=crate::apis::urlencode(workflow_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkflowRealTimeStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkflowRealTimeStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_workflow_statistics(configuration: &configuration::Configuration, params: FetchWorkflowStatisticsParams) -> Result<ResponseContent<FetchWorkflowStatisticsSuccess>, Error<FetchWorkflowStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let workflow_sid = params.workflow_sid;
    let minutes = params.minutes;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let task_channel = params.task_channel;
    let split_by_wait_time = params.split_by_wait_time;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/Statistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), WorkflowSid=crate::apis::urlencode(workflow_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = split_by_wait_time {
        local_var_req_builder = local_var_req_builder.query(&[("SplitByWaitTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkflowStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkflowStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_workspace(configuration: &configuration::Configuration, params: FetchWorkspaceParams) -> Result<ResponseContent<FetchWorkspaceSuccess>, Error<FetchWorkspaceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkspaceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkspaceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_workspace_cumulative_statistics(configuration: &configuration::Configuration, params: FetchWorkspaceCumulativeStatisticsParams) -> Result<ResponseContent<FetchWorkspaceCumulativeStatisticsSuccess>, Error<FetchWorkspaceCumulativeStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let end_date = params.end_date;
    let minutes = params.minutes;
    let start_date = params.start_date;
    let task_channel = params.task_channel;
    let split_by_wait_time = params.split_by_wait_time;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/CumulativeStatistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = split_by_wait_time {
        local_var_req_builder = local_var_req_builder.query(&[("SplitByWaitTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkspaceCumulativeStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkspaceCumulativeStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_workspace_real_time_statistics(configuration: &configuration::Configuration, params: FetchWorkspaceRealTimeStatisticsParams) -> Result<ResponseContent<FetchWorkspaceRealTimeStatisticsSuccess>, Error<FetchWorkspaceRealTimeStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let task_channel = params.task_channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/RealTimeStatistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkspaceRealTimeStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkspaceRealTimeStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_workspace_statistics(configuration: &configuration::Configuration, params: FetchWorkspaceStatisticsParams) -> Result<ResponseContent<FetchWorkspaceStatisticsSuccess>, Error<FetchWorkspaceStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let minutes = params.minutes;
    let start_date = params.start_date;
    let end_date = params.end_date;
    let task_channel = params.task_channel;
    let split_by_wait_time = params.split_by_wait_time;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Statistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = split_by_wait_time {
        local_var_req_builder = local_var_req_builder.query(&[("SplitByWaitTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWorkspaceStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWorkspaceStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_activity(configuration: &configuration::Configuration, params: ListActivityParams) -> Result<ResponseContent<ListActivitySuccess>, Error<ListActivityError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let friendly_name = params.friendly_name;
    let available = params.available;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Activities", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = available {
        local_var_req_builder = local_var_req_builder.query(&[("Available", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListActivitySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListActivityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_event(configuration: &configuration::Configuration, params: ListEventParams) -> Result<ResponseContent<ListEventSuccess>, Error<ListEventError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let end_date = params.end_date;
    let event_type = params.event_type;
    let minutes = params.minutes;
    let reservation_sid = params.reservation_sid;
    let start_date = params.start_date;
    let task_queue_sid = params.task_queue_sid;
    let task_sid = params.task_sid;
    let worker_sid = params.worker_sid;
    let workflow_sid = params.workflow_sid;
    let task_channel = params.task_channel;
    let sid = params.sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Events", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = event_type {
        local_var_req_builder = local_var_req_builder.query(&[("EventType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = reservation_sid {
        local_var_req_builder = local_var_req_builder.query(&[("ReservationSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_queue_sid {
        local_var_req_builder = local_var_req_builder.query(&[("TaskQueueSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_sid {
        local_var_req_builder = local_var_req_builder.query(&[("TaskSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = worker_sid {
        local_var_req_builder = local_var_req_builder.query(&[("WorkerSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = workflow_sid {
        local_var_req_builder = local_var_req_builder.query(&[("WorkflowSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sid {
        local_var_req_builder = local_var_req_builder.query(&[("Sid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListEventSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListEventError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_task(configuration: &configuration::Configuration, params: ListTaskParams) -> Result<ResponseContent<ListTaskSuccess>, Error<ListTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let priority = params.priority;
    let assignment_status = params.assignment_status;
    let workflow_sid = params.workflow_sid;
    let workflow_name = params.workflow_name;
    let task_queue_sid = params.task_queue_sid;
    let task_queue_name = params.task_queue_name;
    let evaluate_task_attributes = params.evaluate_task_attributes;
    let ordering = params.ordering;
    let has_addons = params.has_addons;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Tasks", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = priority {
        local_var_req_builder = local_var_req_builder.query(&[("Priority", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = assignment_status {
        local_var_req_builder = local_var_req_builder.query(&[("AssignmentStatus", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = workflow_sid {
        local_var_req_builder = local_var_req_builder.query(&[("WorkflowSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = workflow_name {
        local_var_req_builder = local_var_req_builder.query(&[("WorkflowName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_queue_sid {
        local_var_req_builder = local_var_req_builder.query(&[("TaskQueueSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_queue_name {
        local_var_req_builder = local_var_req_builder.query(&[("TaskQueueName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = evaluate_task_attributes {
        local_var_req_builder = local_var_req_builder.query(&[("EvaluateTaskAttributes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("Ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_addons {
        local_var_req_builder = local_var_req_builder.query(&[("HasAddons", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListTaskSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_task_channel(configuration: &configuration::Configuration, params: ListTaskChannelParams) -> Result<ResponseContent<ListTaskChannelSuccess>, Error<ListTaskChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskChannels", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListTaskChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListTaskChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_task_queue(configuration: &configuration::Configuration, params: ListTaskQueueParams) -> Result<ResponseContent<ListTaskQueueSuccess>, Error<ListTaskQueueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let friendly_name = params.friendly_name;
    let evaluate_worker_attributes = params.evaluate_worker_attributes;
    let worker_sid = params.worker_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskQueues", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = evaluate_worker_attributes {
        local_var_req_builder = local_var_req_builder.query(&[("EvaluateWorkerAttributes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = worker_sid {
        local_var_req_builder = local_var_req_builder.query(&[("WorkerSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListTaskQueueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListTaskQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_task_queues_statistics(configuration: &configuration::Configuration, params: ListTaskQueuesStatisticsParams) -> Result<ResponseContent<ListTaskQueuesStatisticsSuccess>, Error<ListTaskQueuesStatisticsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let end_date = params.end_date;
    let friendly_name = params.friendly_name;
    let minutes = params.minutes;
    let start_date = params.start_date;
    let task_channel = params.task_channel;
    let split_by_wait_time = params.split_by_wait_time;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskQueues/Statistics", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("EndDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = minutes {
        local_var_req_builder = local_var_req_builder.query(&[("Minutes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("StartDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_channel {
        local_var_req_builder = local_var_req_builder.query(&[("TaskChannel", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = split_by_wait_time {
        local_var_req_builder = local_var_req_builder.query(&[("SplitByWaitTime", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListTaskQueuesStatisticsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListTaskQueuesStatisticsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_task_reservation(configuration: &configuration::Configuration, params: ListTaskReservationParams) -> Result<ResponseContent<ListTaskReservationSuccess>, Error<ListTaskReservationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let task_sid = params.task_sid;
    let reservation_status = params.reservation_status;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), TaskSid=crate::apis::urlencode(task_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = reservation_status {
        local_var_req_builder = local_var_req_builder.query(&[("ReservationStatus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListTaskReservationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListTaskReservationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_worker(configuration: &configuration::Configuration, params: ListWorkerParams) -> Result<ResponseContent<ListWorkerSuccess>, Error<ListWorkerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let activity_name = params.activity_name;
    let activity_sid = params.activity_sid;
    let available = params.available;
    let friendly_name = params.friendly_name;
    let target_workers_expression = params.target_workers_expression;
    let task_queue_name = params.task_queue_name;
    let task_queue_sid = params.task_queue_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = activity_name {
        local_var_req_builder = local_var_req_builder.query(&[("ActivityName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = activity_sid {
        local_var_req_builder = local_var_req_builder.query(&[("ActivitySid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = available {
        local_var_req_builder = local_var_req_builder.query(&[("Available", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = target_workers_expression {
        local_var_req_builder = local_var_req_builder.query(&[("TargetWorkersExpression", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_queue_name {
        local_var_req_builder = local_var_req_builder.query(&[("TaskQueueName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = task_queue_sid {
        local_var_req_builder = local_var_req_builder.query(&[("TaskQueueSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListWorkerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListWorkerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_worker_channel(configuration: &configuration::Configuration, params: ListWorkerChannelParams) -> Result<ResponseContent<ListWorkerChannelSuccess>, Error<ListWorkerChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let worker_sid = params.worker_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), WorkerSid=crate::apis::urlencode(worker_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListWorkerChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListWorkerChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_worker_reservation(configuration: &configuration::Configuration, params: ListWorkerReservationParams) -> Result<ResponseContent<ListWorkerReservationSuccess>, Error<ListWorkerReservationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let worker_sid = params.worker_sid;
    let reservation_status = params.reservation_status;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), WorkerSid=crate::apis::urlencode(worker_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = reservation_status {
        local_var_req_builder = local_var_req_builder.query(&[("ReservationStatus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListWorkerReservationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListWorkerReservationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_workflow(configuration: &configuration::Configuration, params: ListWorkflowParams) -> Result<ResponseContent<ListWorkflowSuccess>, Error<ListWorkflowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let friendly_name = params.friendly_name;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workflows", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListWorkflowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListWorkflowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_workspace(configuration: &configuration::Configuration, params: ListWorkspaceParams) -> Result<ResponseContent<ListWorkspaceSuccess>, Error<ListWorkspaceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListWorkspaceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListWorkspaceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_activity(configuration: &configuration::Configuration, params: UpdateActivityParams) -> Result<ResponseContent<UpdateActivitySuccess>, Error<UpdateActivityError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateActivitySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateActivityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_task(configuration: &configuration::Configuration, params: UpdateTaskParams) -> Result<ResponseContent<UpdateTaskSuccess>, Error<UpdateTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;
    let if_match = params.if_match;
    let assignment_status = params.assignment_status;
    let attributes = params.attributes;
    let priority = params.priority;
    let reason = params.reason;
    let task_channel = params.task_channel;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = if_match {
        local_var_req_builder = local_var_req_builder.header("If-Match", local_var_param_value.to_string());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = assignment_status {
        local_var_form_params.insert("AssignmentStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = priority {
        local_var_form_params.insert("Priority", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reason {
        local_var_form_params.insert("Reason", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = task_channel {
        local_var_form_params.insert("TaskChannel", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateTaskSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_task_channel(configuration: &configuration::Configuration, params: UpdateTaskChannelParams) -> Result<ResponseContent<UpdateTaskChannelSuccess>, Error<UpdateTaskChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;
    let channel_optimized_routing = params.channel_optimized_routing;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = channel_optimized_routing {
        local_var_form_params.insert("ChannelOptimizedRouting", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateTaskChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateTaskChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_task_queue(configuration: &configuration::Configuration, params: UpdateTaskQueueParams) -> Result<ResponseContent<UpdateTaskQueueSuccess>, Error<UpdateTaskQueueError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;
    let assignment_activity_sid = params.assignment_activity_sid;
    let friendly_name = params.friendly_name;
    let max_reserved_workers = params.max_reserved_workers;
    let reservation_activity_sid = params.reservation_activity_sid;
    let target_workers = params.target_workers;
    let task_order = params.task_order;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = assignment_activity_sid {
        local_var_form_params.insert("AssignmentActivitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = max_reserved_workers {
        local_var_form_params.insert("MaxReservedWorkers", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reservation_activity_sid {
        local_var_form_params.insert("ReservationActivitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = target_workers {
        local_var_form_params.insert("TargetWorkers", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = task_order {
        local_var_form_params.insert("TaskOrder", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateTaskQueueSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateTaskQueueError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_task_reservation(configuration: &configuration::Configuration, params: UpdateTaskReservationParams) -> Result<ResponseContent<UpdateTaskReservationSuccess>, Error<UpdateTaskReservationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let task_sid = params.task_sid;
    let sid = params.sid;
    let beep = params.beep;
    let beep_on_customer_entrance = params.beep_on_customer_entrance;
    let call_accept = params.call_accept;
    let call_from = params.call_from;
    let call_record = params.call_record;
    let call_status_callback_url = params.call_status_callback_url;
    let call_timeout = params.call_timeout;
    let call_to = params.call_to;
    let call_url = params.call_url;
    let conference_record = params.conference_record;
    let conference_recording_status_callback = params.conference_recording_status_callback;
    let conference_recording_status_callback_method = params.conference_recording_status_callback_method;
    let conference_status_callback = params.conference_status_callback;
    let conference_status_callback_event = params.conference_status_callback_event;
    let conference_status_callback_method = params.conference_status_callback_method;
    let conference_trim = params.conference_trim;
    let dequeue_from = params.dequeue_from;
    let dequeue_post_work_activity_sid = params.dequeue_post_work_activity_sid;
    let dequeue_record = params.dequeue_record;
    let dequeue_status_callback_event = params.dequeue_status_callback_event;
    let dequeue_status_callback_url = params.dequeue_status_callback_url;
    let dequeue_timeout = params.dequeue_timeout;
    let dequeue_to = params.dequeue_to;
    let early_media = params.early_media;
    let end_conference_on_customer_exit = params.end_conference_on_customer_exit;
    let end_conference_on_exit = params.end_conference_on_exit;
    let from = params.from;
    let instruction = params.instruction;
    let max_participants = params.max_participants;
    let muted = params.muted;
    let post_work_activity_sid = params.post_work_activity_sid;
    let record = params.record;
    let recording_channels = params.recording_channels;
    let recording_status_callback = params.recording_status_callback;
    let recording_status_callback_method = params.recording_status_callback_method;
    let redirect_accept = params.redirect_accept;
    let redirect_call_sid = params.redirect_call_sid;
    let redirect_url = params.redirect_url;
    let region = params.region;
    let reservation_status = params.reservation_status;
    let sip_auth_password = params.sip_auth_password;
    let sip_auth_username = params.sip_auth_username;
    let start_conference_on_enter = params.start_conference_on_enter;
    let status_callback = params.status_callback;
    let status_callback_event = params.status_callback_event;
    let status_callback_method = params.status_callback_method;
    let supervisor = params.supervisor;
    let supervisor_mode = params.supervisor_mode;
    let timeout = params.timeout;
    let to = params.to;
    let wait_method = params.wait_method;
    let wait_url = params.wait_url;
    let worker_activity_sid = params.worker_activity_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), TaskSid=crate::apis::urlencode(task_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = beep {
        local_var_form_params.insert("Beep", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = beep_on_customer_entrance {
        local_var_form_params.insert("BeepOnCustomerEntrance", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_accept {
        local_var_form_params.insert("CallAccept", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_from {
        local_var_form_params.insert("CallFrom", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_record {
        local_var_form_params.insert("CallRecord", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_status_callback_url {
        local_var_form_params.insert("CallStatusCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_timeout {
        local_var_form_params.insert("CallTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_to {
        local_var_form_params.insert("CallTo", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_url {
        local_var_form_params.insert("CallUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_record {
        local_var_form_params.insert("ConferenceRecord", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_recording_status_callback {
        local_var_form_params.insert("ConferenceRecordingStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_recording_status_callback_method {
        local_var_form_params.insert("ConferenceRecordingStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback {
        local_var_form_params.insert("ConferenceStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback_event {
        local_var_form_params.insert("ConferenceStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback_method {
        local_var_form_params.insert("ConferenceStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_trim {
        local_var_form_params.insert("ConferenceTrim", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_from {
        local_var_form_params.insert("DequeueFrom", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_post_work_activity_sid {
        local_var_form_params.insert("DequeuePostWorkActivitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_record {
        local_var_form_params.insert("DequeueRecord", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_status_callback_event {
        local_var_form_params.insert("DequeueStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = dequeue_status_callback_url {
        local_var_form_params.insert("DequeueStatusCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_timeout {
        local_var_form_params.insert("DequeueTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_to {
        local_var_form_params.insert("DequeueTo", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = early_media {
        local_var_form_params.insert("EarlyMedia", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = end_conference_on_customer_exit {
        local_var_form_params.insert("EndConferenceOnCustomerExit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = end_conference_on_exit {
        local_var_form_params.insert("EndConferenceOnExit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = from {
        local_var_form_params.insert("From", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = instruction {
        local_var_form_params.insert("Instruction", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = max_participants {
        local_var_form_params.insert("MaxParticipants", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = muted {
        local_var_form_params.insert("Muted", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = post_work_activity_sid {
        local_var_form_params.insert("PostWorkActivitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = record {
        local_var_form_params.insert("Record", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_channels {
        local_var_form_params.insert("RecordingChannels", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback {
        local_var_form_params.insert("RecordingStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback_method {
        local_var_form_params.insert("RecordingStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = redirect_accept {
        local_var_form_params.insert("RedirectAccept", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = redirect_call_sid {
        local_var_form_params.insert("RedirectCallSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = redirect_url {
        local_var_form_params.insert("RedirectUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = region {
        local_var_form_params.insert("Region", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reservation_status {
        local_var_form_params.insert("ReservationStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_auth_password {
        local_var_form_params.insert("SipAuthPassword", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_auth_username {
        local_var_form_params.insert("SipAuthUsername", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = start_conference_on_enter {
        local_var_form_params.insert("StartConferenceOnEnter", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_event {
        local_var_form_params.insert("StatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = supervisor {
        local_var_form_params.insert("Supervisor", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = supervisor_mode {
        local_var_form_params.insert("SupervisorMode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timeout {
        local_var_form_params.insert("Timeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = to {
        local_var_form_params.insert("To", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_method {
        local_var_form_params.insert("WaitMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_url {
        local_var_form_params.insert("WaitUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = worker_activity_sid {
        local_var_form_params.insert("WorkerActivitySid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateTaskReservationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateTaskReservationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_worker(configuration: &configuration::Configuration, params: UpdateWorkerParams) -> Result<ResponseContent<UpdateWorkerSuccess>, Error<UpdateWorkerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;
    let activity_sid = params.activity_sid;
    let attributes = params.attributes;
    let friendly_name = params.friendly_name;
    let reject_pending_reservations = params.reject_pending_reservations;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = activity_sid {
        local_var_form_params.insert("ActivitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = attributes {
        local_var_form_params.insert("Attributes", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reject_pending_reservations {
        local_var_form_params.insert("RejectPendingReservations", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateWorkerSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateWorkerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_worker_channel(configuration: &configuration::Configuration, params: UpdateWorkerChannelParams) -> Result<ResponseContent<UpdateWorkerChannelSuccess>, Error<UpdateWorkerChannelError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let worker_sid = params.worker_sid;
    let sid = params.sid;
    let available = params.available;
    let capacity = params.capacity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), WorkerSid=crate::apis::urlencode(worker_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = available {
        local_var_form_params.insert("Available", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = capacity {
        local_var_form_params.insert("Capacity", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateWorkerChannelSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateWorkerChannelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_worker_reservation(configuration: &configuration::Configuration, params: UpdateWorkerReservationParams) -> Result<ResponseContent<UpdateWorkerReservationSuccess>, Error<UpdateWorkerReservationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let worker_sid = params.worker_sid;
    let sid = params.sid;
    let beep = params.beep;
    let beep_on_customer_entrance = params.beep_on_customer_entrance;
    let call_accept = params.call_accept;
    let call_from = params.call_from;
    let call_record = params.call_record;
    let call_status_callback_url = params.call_status_callback_url;
    let call_timeout = params.call_timeout;
    let call_to = params.call_to;
    let call_url = params.call_url;
    let conference_record = params.conference_record;
    let conference_recording_status_callback = params.conference_recording_status_callback;
    let conference_recording_status_callback_method = params.conference_recording_status_callback_method;
    let conference_status_callback = params.conference_status_callback;
    let conference_status_callback_event = params.conference_status_callback_event;
    let conference_status_callback_method = params.conference_status_callback_method;
    let conference_trim = params.conference_trim;
    let dequeue_from = params.dequeue_from;
    let dequeue_post_work_activity_sid = params.dequeue_post_work_activity_sid;
    let dequeue_record = params.dequeue_record;
    let dequeue_status_callback_event = params.dequeue_status_callback_event;
    let dequeue_status_callback_url = params.dequeue_status_callback_url;
    let dequeue_timeout = params.dequeue_timeout;
    let dequeue_to = params.dequeue_to;
    let early_media = params.early_media;
    let end_conference_on_customer_exit = params.end_conference_on_customer_exit;
    let end_conference_on_exit = params.end_conference_on_exit;
    let from = params.from;
    let instruction = params.instruction;
    let max_participants = params.max_participants;
    let muted = params.muted;
    let post_work_activity_sid = params.post_work_activity_sid;
    let record = params.record;
    let recording_channels = params.recording_channels;
    let recording_status_callback = params.recording_status_callback;
    let recording_status_callback_method = params.recording_status_callback_method;
    let redirect_accept = params.redirect_accept;
    let redirect_call_sid = params.redirect_call_sid;
    let redirect_url = params.redirect_url;
    let region = params.region;
    let reservation_status = params.reservation_status;
    let sip_auth_password = params.sip_auth_password;
    let sip_auth_username = params.sip_auth_username;
    let start_conference_on_enter = params.start_conference_on_enter;
    let status_callback = params.status_callback;
    let status_callback_event = params.status_callback_event;
    let status_callback_method = params.status_callback_method;
    let timeout = params.timeout;
    let to = params.to;
    let wait_method = params.wait_method;
    let wait_url = params.wait_url;
    let worker_activity_sid = params.worker_activity_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), WorkerSid=crate::apis::urlencode(worker_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = beep {
        local_var_form_params.insert("Beep", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = beep_on_customer_entrance {
        local_var_form_params.insert("BeepOnCustomerEntrance", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_accept {
        local_var_form_params.insert("CallAccept", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_from {
        local_var_form_params.insert("CallFrom", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_record {
        local_var_form_params.insert("CallRecord", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_status_callback_url {
        local_var_form_params.insert("CallStatusCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_timeout {
        local_var_form_params.insert("CallTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_to {
        local_var_form_params.insert("CallTo", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_url {
        local_var_form_params.insert("CallUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_record {
        local_var_form_params.insert("ConferenceRecord", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_recording_status_callback {
        local_var_form_params.insert("ConferenceRecordingStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_recording_status_callback_method {
        local_var_form_params.insert("ConferenceRecordingStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback {
        local_var_form_params.insert("ConferenceStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback_event {
        local_var_form_params.insert("ConferenceStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback_method {
        local_var_form_params.insert("ConferenceStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_trim {
        local_var_form_params.insert("ConferenceTrim", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_from {
        local_var_form_params.insert("DequeueFrom", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_post_work_activity_sid {
        local_var_form_params.insert("DequeuePostWorkActivitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_record {
        local_var_form_params.insert("DequeueRecord", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_status_callback_event {
        local_var_form_params.insert("DequeueStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = dequeue_status_callback_url {
        local_var_form_params.insert("DequeueStatusCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_timeout {
        local_var_form_params.insert("DequeueTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dequeue_to {
        local_var_form_params.insert("DequeueTo", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = early_media {
        local_var_form_params.insert("EarlyMedia", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = end_conference_on_customer_exit {
        local_var_form_params.insert("EndConferenceOnCustomerExit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = end_conference_on_exit {
        local_var_form_params.insert("EndConferenceOnExit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = from {
        local_var_form_params.insert("From", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = instruction {
        local_var_form_params.insert("Instruction", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = max_participants {
        local_var_form_params.insert("MaxParticipants", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = muted {
        local_var_form_params.insert("Muted", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = post_work_activity_sid {
        local_var_form_params.insert("PostWorkActivitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = record {
        local_var_form_params.insert("Record", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_channels {
        local_var_form_params.insert("RecordingChannels", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback {
        local_var_form_params.insert("RecordingStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback_method {
        local_var_form_params.insert("RecordingStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = redirect_accept {
        local_var_form_params.insert("RedirectAccept", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = redirect_call_sid {
        local_var_form_params.insert("RedirectCallSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = redirect_url {
        local_var_form_params.insert("RedirectUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = region {
        local_var_form_params.insert("Region", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reservation_status {
        local_var_form_params.insert("ReservationStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_auth_password {
        local_var_form_params.insert("SipAuthPassword", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_auth_username {
        local_var_form_params.insert("SipAuthUsername", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = start_conference_on_enter {
        local_var_form_params.insert("StartConferenceOnEnter", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_event {
        local_var_form_params.insert("StatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timeout {
        local_var_form_params.insert("Timeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = to {
        local_var_form_params.insert("To", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_method {
        local_var_form_params.insert("WaitMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_url {
        local_var_form_params.insert("WaitUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = worker_activity_sid {
        local_var_form_params.insert("WorkerActivitySid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateWorkerReservationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateWorkerReservationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_workflow(configuration: &configuration::Configuration, params: UpdateWorkflowParams) -> Result<ResponseContent<UpdateWorkflowSuccess>, Error<UpdateWorkflowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workspace_sid = params.workspace_sid;
    let sid = params.sid;
    let assignment_callback_url = params.assignment_callback_url;
    let configuration = params.configuration;
    let fallback_assignment_callback_url = params.fallback_assignment_callback_url;
    let friendly_name = params.friendly_name;
    let re_evaluate_tasks = params.re_evaluate_tasks;
    let task_reservation_timeout = params.task_reservation_timeout;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}", local_var_configuration.base_path, WorkspaceSid=crate::apis::urlencode(workspace_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = assignment_callback_url {
        local_var_form_params.insert("AssignmentCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = configuration {
        local_var_form_params.insert("Configuration", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = fallback_assignment_callback_url {
        local_var_form_params.insert("FallbackAssignmentCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = re_evaluate_tasks {
        local_var_form_params.insert("ReEvaluateTasks", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = task_reservation_timeout {
        local_var_form_params.insert("TaskReservationTimeout", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateWorkflowSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateWorkflowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_workspace(configuration: &configuration::Configuration, params: UpdateWorkspaceParams) -> Result<ResponseContent<UpdateWorkspaceSuccess>, Error<UpdateWorkspaceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let default_activity_sid = params.default_activity_sid;
    let event_callback_url = params.event_callback_url;
    let events_filter = params.events_filter;
    let friendly_name = params.friendly_name;
    let multi_task_enabled = params.multi_task_enabled;
    let prioritize_queue_order = params.prioritize_queue_order;
    let timeout_activity_sid = params.timeout_activity_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Workspaces/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = default_activity_sid {
        local_var_form_params.insert("DefaultActivitySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = event_callback_url {
        local_var_form_params.insert("EventCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = events_filter {
        local_var_form_params.insert("EventsFilter", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = multi_task_enabled {
        local_var_form_params.insert("MultiTaskEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = prioritize_queue_order {
        local_var_form_params.insert("PrioritizeQueueOrder", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timeout_activity_sid {
        local_var_form_params.insert("TimeoutActivitySid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateWorkspaceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateWorkspaceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

