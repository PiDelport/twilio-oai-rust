/*
 * Twilio - Trunking
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_credential_list`]
#[derive(Clone, Debug, Default)]
pub struct CreateCredentialListParams {
    /// The SID of the Trunk to associate the credential list with.
    pub trunk_sid: String,
    /// The SID of the [Credential List](https://www.twilio.com/docs/voice/sip/api/sip-credentiallist-resource) that you want to associate with the trunk. Once associated, we will authenticate access to the trunk against this list.
    pub credential_list_sid: String
}

/// struct for passing parameters to the method [`create_ip_access_control_list`]
#[derive(Clone, Debug, Default)]
pub struct CreateIpAccessControlListParams {
    /// The SID of the Trunk to associate the IP Access Control List with.
    pub trunk_sid: String,
    /// The SID of the [IP Access Control List](https://www.twilio.com/docs/voice/sip/api/sip-ipaccesscontrollist-resource) that you want to associate with the trunk.
    pub ip_access_control_list_sid: String
}

/// struct for passing parameters to the method [`create_origination_url`]
#[derive(Clone, Debug, Default)]
pub struct CreateOriginationUrlParams {
    /// The SID of the Trunk to associate the resource with.
    pub trunk_sid: String,
    /// Whether the URL is enabled. The default is `true`.
    pub enabled: bool,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: String,
    /// The relative importance of the URI. Can be an integer from 0 to 65535, inclusive, and the default is 10. The lowest number represents the most important URI.
    pub priority: i32,
    /// The SIP address you want Twilio to route your Origination calls to. This must be a `sip:` schema.
    pub sip_url: String,
    /// The value that determines the relative share of the load the URI should receive compared to other URIs with the same priority. Can be an integer from 1 to 65535, inclusive, and the default is 10. URLs with higher values receive more load than those with lower ones with the same priority.
    pub weight: i32
}

/// struct for passing parameters to the method [`create_phone_number`]
#[derive(Clone, Debug, Default)]
pub struct CreatePhoneNumberParams {
    /// The SID of the Trunk to associate the phone number with.
    pub trunk_sid: String,
    /// The SID of the [Incoming Phone Number](https://www.twilio.com/docs/phone-numbers/api/incomingphonenumber-resource) that you want to associate with the trunk.
    pub phone_number_sid: String
}

/// struct for passing parameters to the method [`create_trunk`]
#[derive(Clone, Debug, Default)]
pub struct CreateTrunkParams {
    /// Whether Caller ID Name (CNAM) lookup should be enabled for the trunk. If enabled, all inbound calls to the SIP Trunk from the United States and Canada automatically perform a CNAM Lookup and display Caller ID data on your phone. See [CNAM Lookups](https://www.twilio.com/docs/sip-trunking#CNAM) for more information.
    pub cnam_lookup_enabled: Option<bool>,
    /// The HTTP method we should use to call the `disaster_recovery_url`. Can be: `GET` or `POST`.
    pub disaster_recovery_method: Option<String>,
    /// The URL we should call using the `disaster_recovery_method` if an error occurs while sending SIP traffic towards the configured Origination URL. We retrieve TwiML from the URL and execute the instructions like any other normal TwiML call. See [Disaster Recovery](https://www.twilio.com/docs/sip-trunking#disaster-recovery) for more information.
    pub disaster_recovery_url: Option<String>,
    /// The unique address you reserve on Twilio to which you route your SIP traffic. Domain names can contain letters, digits, and `-` and must end with `pstn.twilio.com`. See [Termination Settings](https://www.twilio.com/docs/sip-trunking#termination) for more information.
    pub domain_name: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// Whether Secure Trunking is enabled for the trunk. If enabled, all calls going through the trunk will be secure using SRTP for media and TLS for signaling. If disabled, then RTP will be used for media. See [Secure Trunking](https://www.twilio.com/docs/sip-trunking#securetrunking) for more information.
    pub secure: Option<bool>,
    /// The call transfer settings for the trunk. Can be: `enable-all`, `sip-only` and `disable-all`. See [Transfer](https://www.twilio.com/docs/sip-trunking/call-transfer) for more information.
    pub transfer_mode: Option<String>
}

/// struct for passing parameters to the method [`delete_credential_list`]
#[derive(Clone, Debug, Default)]
pub struct DeleteCredentialListParams {
    /// The SID of the Trunk from which to delete the credential list.
    pub trunk_sid: String,
    /// The unique string that we created to identify the CredentialList resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_ip_access_control_list`]
#[derive(Clone, Debug, Default)]
pub struct DeleteIpAccessControlListParams {
    /// The SID of the Trunk from which to delete the IP Access Control List.
    pub trunk_sid: String,
    /// The unique string that we created to identify the IpAccessControlList resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_origination_url`]
#[derive(Clone, Debug, Default)]
pub struct DeleteOriginationUrlParams {
    /// The SID of the Trunk from which to delete the OriginationUrl.
    pub trunk_sid: String,
    /// The unique string that we created to identify the OriginationUrl resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_phone_number`]
#[derive(Clone, Debug, Default)]
pub struct DeletePhoneNumberParams {
    /// The SID of the Trunk from which to delete the PhoneNumber resource.
    pub trunk_sid: String,
    /// The unique string that we created to identify the PhoneNumber resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_trunk`]
#[derive(Clone, Debug, Default)]
pub struct DeleteTrunkParams {
    /// The unique string that we created to identify the Trunk resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_credential_list`]
#[derive(Clone, Debug, Default)]
pub struct FetchCredentialListParams {
    /// The SID of the Trunk from which to fetch the credential list.
    pub trunk_sid: String,
    /// The unique string that we created to identify the CredentialList resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_ip_access_control_list`]
#[derive(Clone, Debug, Default)]
pub struct FetchIpAccessControlListParams {
    /// The SID of the Trunk from which to fetch the IP Access Control List.
    pub trunk_sid: String,
    /// The unique string that we created to identify the IpAccessControlList resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_origination_url`]
#[derive(Clone, Debug, Default)]
pub struct FetchOriginationUrlParams {
    /// The SID of the Trunk from which to fetch the OriginationUrl.
    pub trunk_sid: String,
    /// The unique string that we created to identify the OriginationUrl resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_phone_number`]
#[derive(Clone, Debug, Default)]
pub struct FetchPhoneNumberParams {
    /// The SID of the Trunk from which to fetch the PhoneNumber resource.
    pub trunk_sid: String,
    /// The unique string that we created to identify the PhoneNumber resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_recording`]
#[derive(Clone, Debug, Default)]
pub struct FetchRecordingParams {
    /// The SID of the Trunk from which to fetch the recording settings.
    pub trunk_sid: String
}

/// struct for passing parameters to the method [`fetch_trunk`]
#[derive(Clone, Debug, Default)]
pub struct FetchTrunkParams {
    /// The unique string that we created to identify the Trunk resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`list_credential_list`]
#[derive(Clone, Debug, Default)]
pub struct ListCredentialListParams {
    /// The SID of the Trunk from which to read the credential lists.
    pub trunk_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_ip_access_control_list`]
#[derive(Clone, Debug, Default)]
pub struct ListIpAccessControlListParams {
    /// The SID of the Trunk from which to read the IP Access Control Lists.
    pub trunk_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_origination_url`]
#[derive(Clone, Debug, Default)]
pub struct ListOriginationUrlParams {
    /// The SID of the Trunk from which to read the OriginationUrl.
    pub trunk_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_phone_number`]
#[derive(Clone, Debug, Default)]
pub struct ListPhoneNumberParams {
    /// The SID of the Trunk from which to read the PhoneNumber resources.
    pub trunk_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_trunk`]
#[derive(Clone, Debug, Default)]
pub struct ListTrunkParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`update_origination_url`]
#[derive(Clone, Debug, Default)]
pub struct UpdateOriginationUrlParams {
    /// The SID of the Trunk from which to update the OriginationUrl.
    pub trunk_sid: String,
    /// The unique string that we created to identify the OriginationUrl resource to update.
    pub sid: String,
    /// Whether the URL is enabled. The default is `true`.
    pub enabled: Option<bool>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// The relative importance of the URI. Can be an integer from 0 to 65535, inclusive, and the default is 10. The lowest number represents the most important URI.
    pub priority: Option<i32>,
    /// The SIP address you want Twilio to route your Origination calls to. This must be a `sip:` schema. `sips` is NOT supported.
    pub sip_url: Option<String>,
    /// The value that determines the relative share of the load the URI should receive compared to other URIs with the same priority. Can be an integer from 1 to 65535, inclusive, and the default is 10. URLs with higher values receive more load than those with lower ones with the same priority.
    pub weight: Option<i32>
}

/// struct for passing parameters to the method [`update_recording`]
#[derive(Clone, Debug, Default)]
pub struct UpdateRecordingParams {
    /// The SID of the Trunk that will have its recording settings updated.
    pub trunk_sid: String,
    /// The recording mode for the trunk. Can be do-not-record (default), record-from-ringing, record-from-answer, record-from-ringing-dual, or record-from-answer-dual.
    pub mode: Option<String>,
    /// The recording trim setting for the trunk. Can be do-not-trim (default) or trim-silence.
    pub trim: Option<String>
}

/// struct for passing parameters to the method [`update_trunk`]
#[derive(Clone, Debug, Default)]
pub struct UpdateTrunkParams {
    /// The unique string that we created to identify the OriginationUrl resource to update.
    pub sid: String,
    /// Whether Caller ID Name (CNAM) lookup should be enabled for the trunk. If enabled, all inbound calls to the SIP Trunk from the United States and Canada automatically perform a CNAM Lookup and display Caller ID data on your phone. See [CNAM Lookups](https://www.twilio.com/docs/sip-trunking#CNAM) for more information.
    pub cnam_lookup_enabled: Option<bool>,
    /// The HTTP method we should use to call the `disaster_recovery_url`. Can be: `GET` or `POST`.
    pub disaster_recovery_method: Option<String>,
    /// The URL we should call using the `disaster_recovery_method` if an error occurs while sending SIP traffic towards the configured Origination URL. We retrieve TwiML from the URL and execute the instructions like any other normal TwiML call. See [Disaster Recovery](https://www.twilio.com/docs/sip-trunking#disaster-recovery) for more information.
    pub disaster_recovery_url: Option<String>,
    /// The unique address you reserve on Twilio to which you route your SIP traffic. Domain names can contain letters, digits, and `-` and must end with `pstn.twilio.com`. See [Termination Settings](https://www.twilio.com/docs/sip-trunking#termination) for more information.
    pub domain_name: Option<String>,
    /// A descriptive string that you create to describe the resource. It can be up to 64 characters long.
    pub friendly_name: Option<String>,
    /// Whether Secure Trunking is enabled for the trunk. If enabled, all calls going through the trunk will be secure using SRTP for media and TLS for signaling. If disabled, then RTP will be used for media. See [Secure Trunking](https://www.twilio.com/docs/sip-trunking#securetrunking) for more information.
    pub secure: Option<bool>,
    /// The call transfer settings for the trunk. Can be: `enable-all`, `sip-only` and `disable-all`. See [Transfer](https://www.twilio.com/docs/sip-trunking/call-transfer) for more information.
    pub transfer_mode: Option<String>
}


/// struct for typed successes of method [`create_credential_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialListSuccess {
    Status201(crate::models::TrunkingV1TrunkCredentialList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_ip_access_control_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIpAccessControlListSuccess {
    Status201(crate::models::TrunkingV1TrunkIpAccessControlList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_origination_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOriginationUrlSuccess {
    Status201(crate::models::TrunkingV1TrunkOriginationUrl),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_phone_number`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePhoneNumberSuccess {
    Status201(crate::models::TrunkingV1TrunkPhoneNumber),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_trunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTrunkSuccess {
    Status201(crate::models::TrunkingV1Trunk),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_credential_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialListSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_ip_access_control_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIpAccessControlListSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_origination_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOriginationUrlSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_phone_number`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePhoneNumberSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_trunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTrunkSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_credential_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialListSuccess {
    Status200(crate::models::TrunkingV1TrunkCredentialList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_ip_access_control_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchIpAccessControlListSuccess {
    Status200(crate::models::TrunkingV1TrunkIpAccessControlList),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_origination_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchOriginationUrlSuccess {
    Status200(crate::models::TrunkingV1TrunkOriginationUrl),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_phone_number`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchPhoneNumberSuccess {
    Status200(crate::models::TrunkingV1TrunkPhoneNumber),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingSuccess {
    Status200(crate::models::TrunkingV1TrunkRecording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_trunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTrunkSuccess {
    Status200(crate::models::TrunkingV1Trunk),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_credential_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialListSuccess {
    Status200(crate::models::ListCredentialListResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_ip_access_control_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIpAccessControlListSuccess {
    Status200(crate::models::ListIpAccessControlListResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_origination_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOriginationUrlSuccess {
    Status200(crate::models::ListOriginationUrlResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_phone_number`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPhoneNumberSuccess {
    Status200(crate::models::ListPhoneNumberResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_trunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTrunkSuccess {
    Status200(crate::models::ListTrunkResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_origination_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOriginationUrlSuccess {
    Status200(crate::models::TrunkingV1TrunkOriginationUrl),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRecordingSuccess {
    Status202(crate::models::TrunkingV1TrunkRecording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_trunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTrunkSuccess {
    Status200(crate::models::TrunkingV1Trunk),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_credential_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCredentialListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_ip_access_control_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIpAccessControlListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_origination_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOriginationUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_phone_number`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePhoneNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_trunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTrunkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_credential_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCredentialListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_ip_access_control_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIpAccessControlListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_origination_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOriginationUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_phone_number`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePhoneNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_trunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTrunkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_credential_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCredentialListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_ip_access_control_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchIpAccessControlListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_origination_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchOriginationUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_phone_number`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchPhoneNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_trunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTrunkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_credential_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCredentialListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_ip_access_control_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIpAccessControlListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_origination_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOriginationUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_phone_number`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPhoneNumberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_trunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTrunkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_origination_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOriginationUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_trunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTrunkError {
    UnknownValue(serde_json::Value),
}


pub async fn create_credential_list(configuration: &configuration::Configuration, params: CreateCredentialListParams) -> Result<ResponseContent<CreateCredentialListSuccess>, Error<CreateCredentialListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let credential_list_sid = params.credential_list_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/CredentialLists", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("CredentialListSid", credential_list_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCredentialListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCredentialListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Associate an IP Access Control List with a Trunk
pub async fn create_ip_access_control_list(configuration: &configuration::Configuration, params: CreateIpAccessControlListParams) -> Result<ResponseContent<CreateIpAccessControlListSuccess>, Error<CreateIpAccessControlListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let ip_access_control_list_sid = params.ip_access_control_list_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/IpAccessControlLists", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("IpAccessControlListSid", ip_access_control_list_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateIpAccessControlListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateIpAccessControlListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_origination_url(configuration: &configuration::Configuration, params: CreateOriginationUrlParams) -> Result<ResponseContent<CreateOriginationUrlSuccess>, Error<CreateOriginationUrlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let enabled = params.enabled;
    let friendly_name = params.friendly_name;
    let priority = params.priority;
    let sip_url = params.sip_url;
    let weight = params.weight;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/OriginationUrls", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Enabled", enabled.to_string());
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_form_params.insert("Priority", priority.to_string());
    local_var_form_params.insert("SipUrl", sip_url.to_string());
    local_var_form_params.insert("Weight", weight.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateOriginationUrlSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateOriginationUrlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_phone_number(configuration: &configuration::Configuration, params: CreatePhoneNumberParams) -> Result<ResponseContent<CreatePhoneNumberSuccess>, Error<CreatePhoneNumberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let phone_number_sid = params.phone_number_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/PhoneNumbers", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("PhoneNumberSid", phone_number_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreatePhoneNumberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreatePhoneNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_trunk(configuration: &configuration::Configuration, params: CreateTrunkParams) -> Result<ResponseContent<CreateTrunkSuccess>, Error<CreateTrunkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let cnam_lookup_enabled = params.cnam_lookup_enabled;
    let disaster_recovery_method = params.disaster_recovery_method;
    let disaster_recovery_url = params.disaster_recovery_url;
    let domain_name = params.domain_name;
    let friendly_name = params.friendly_name;
    let secure = params.secure;
    let transfer_mode = params.transfer_mode;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = cnam_lookup_enabled {
        local_var_form_params.insert("CnamLookupEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = disaster_recovery_method {
        local_var_form_params.insert("DisasterRecoveryMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = disaster_recovery_url {
        local_var_form_params.insert("DisasterRecoveryUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = domain_name {
        local_var_form_params.insert("DomainName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secure {
        local_var_form_params.insert("Secure", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = transfer_mode {
        local_var_form_params.insert("TransferMode", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateTrunkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateTrunkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_credential_list(configuration: &configuration::Configuration, params: DeleteCredentialListParams) -> Result<ResponseContent<DeleteCredentialListSuccess>, Error<DeleteCredentialListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/CredentialLists/{Sid}", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCredentialListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCredentialListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an associated IP Access Control List from a Trunk
pub async fn delete_ip_access_control_list(configuration: &configuration::Configuration, params: DeleteIpAccessControlListParams) -> Result<ResponseContent<DeleteIpAccessControlListSuccess>, Error<DeleteIpAccessControlListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/IpAccessControlLists/{Sid}", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteIpAccessControlListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteIpAccessControlListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_origination_url(configuration: &configuration::Configuration, params: DeleteOriginationUrlParams) -> Result<ResponseContent<DeleteOriginationUrlSuccess>, Error<DeleteOriginationUrlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteOriginationUrlSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteOriginationUrlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_phone_number(configuration: &configuration::Configuration, params: DeletePhoneNumberParams) -> Result<ResponseContent<DeletePhoneNumberSuccess>, Error<DeletePhoneNumberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/PhoneNumbers/{Sid}", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeletePhoneNumberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeletePhoneNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_trunk(configuration: &configuration::Configuration, params: DeleteTrunkParams) -> Result<ResponseContent<DeleteTrunkSuccess>, Error<DeleteTrunkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteTrunkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteTrunkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_credential_list(configuration: &configuration::Configuration, params: FetchCredentialListParams) -> Result<ResponseContent<FetchCredentialListSuccess>, Error<FetchCredentialListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/CredentialLists/{Sid}", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCredentialListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCredentialListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_ip_access_control_list(configuration: &configuration::Configuration, params: FetchIpAccessControlListParams) -> Result<ResponseContent<FetchIpAccessControlListSuccess>, Error<FetchIpAccessControlListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/IpAccessControlLists/{Sid}", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchIpAccessControlListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchIpAccessControlListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_origination_url(configuration: &configuration::Configuration, params: FetchOriginationUrlParams) -> Result<ResponseContent<FetchOriginationUrlSuccess>, Error<FetchOriginationUrlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchOriginationUrlSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchOriginationUrlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_phone_number(configuration: &configuration::Configuration, params: FetchPhoneNumberParams) -> Result<ResponseContent<FetchPhoneNumberSuccess>, Error<FetchPhoneNumberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/PhoneNumbers/{Sid}", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchPhoneNumberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchPhoneNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_recording(configuration: &configuration::Configuration, params: FetchRecordingParams) -> Result<ResponseContent<FetchRecordingSuccess>, Error<FetchRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/Recording", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_trunk(configuration: &configuration::Configuration, params: FetchTrunkParams) -> Result<ResponseContent<FetchTrunkSuccess>, Error<FetchTrunkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchTrunkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchTrunkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_credential_list(configuration: &configuration::Configuration, params: ListCredentialListParams) -> Result<ResponseContent<ListCredentialListSuccess>, Error<ListCredentialListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/CredentialLists", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCredentialListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCredentialListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all IP Access Control Lists for a Trunk
pub async fn list_ip_access_control_list(configuration: &configuration::Configuration, params: ListIpAccessControlListParams) -> Result<ResponseContent<ListIpAccessControlListSuccess>, Error<ListIpAccessControlListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/IpAccessControlLists", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListIpAccessControlListSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListIpAccessControlListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_origination_url(configuration: &configuration::Configuration, params: ListOriginationUrlParams) -> Result<ResponseContent<ListOriginationUrlSuccess>, Error<ListOriginationUrlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/OriginationUrls", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListOriginationUrlSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListOriginationUrlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_phone_number(configuration: &configuration::Configuration, params: ListPhoneNumberParams) -> Result<ResponseContent<ListPhoneNumberSuccess>, Error<ListPhoneNumberError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/PhoneNumbers", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListPhoneNumberSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListPhoneNumberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_trunk(configuration: &configuration::Configuration, params: ListTrunkParams) -> Result<ResponseContent<ListTrunkSuccess>, Error<ListTrunkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListTrunkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListTrunkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_origination_url(configuration: &configuration::Configuration, params: UpdateOriginationUrlParams) -> Result<ResponseContent<UpdateOriginationUrlSuccess>, Error<UpdateOriginationUrlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let sid = params.sid;
    let enabled = params.enabled;
    let friendly_name = params.friendly_name;
    let priority = params.priority;
    let sip_url = params.sip_url;
    let weight = params.weight;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = enabled {
        local_var_form_params.insert("Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = priority {
        local_var_form_params.insert("Priority", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_url {
        local_var_form_params.insert("SipUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = weight {
        local_var_form_params.insert("Weight", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateOriginationUrlSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateOriginationUrlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_recording(configuration: &configuration::Configuration, params: UpdateRecordingParams) -> Result<ResponseContent<UpdateRecordingSuccess>, Error<UpdateRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trunk_sid = params.trunk_sid;
    let mode = params.mode;
    let trim = params.trim;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{TrunkSid}/Recording", local_var_configuration.base_path, TrunkSid=crate::apis::urlencode(trunk_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = mode {
        local_var_form_params.insert("Mode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trim {
        local_var_form_params.insert("Trim", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRecordingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_trunk(configuration: &configuration::Configuration, params: UpdateTrunkParams) -> Result<ResponseContent<UpdateTrunkSuccess>, Error<UpdateTrunkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let cnam_lookup_enabled = params.cnam_lookup_enabled;
    let disaster_recovery_method = params.disaster_recovery_method;
    let disaster_recovery_url = params.disaster_recovery_url;
    let domain_name = params.domain_name;
    let friendly_name = params.friendly_name;
    let secure = params.secure;
    let transfer_mode = params.transfer_mode;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Trunks/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = cnam_lookup_enabled {
        local_var_form_params.insert("CnamLookupEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = disaster_recovery_method {
        local_var_form_params.insert("DisasterRecoveryMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = disaster_recovery_url {
        local_var_form_params.insert("DisasterRecoveryUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = domain_name {
        local_var_form_params.insert("DomainName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = secure {
        local_var_form_params.insert("Secure", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = transfer_mode {
        local_var_form_params.insert("TransferMode", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateTrunkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateTrunkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

