/*
 * Twilio - Verify
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_access_token`]
#[derive(Clone, Debug, Default)]
pub struct CreateAccessTokenParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// The Type of this Factor. Eg. `push`
    pub factor_type: String,
    /// The unique external identifier for the Entity of the Service. This identifier should be immutable, not PII, and generated by your external system, such as your user's UUID, GUID, or SID.
    pub identity: String
}

/// struct for passing parameters to the method [`create_bucket`]
#[derive(Clone, Debug, Default)]
pub struct CreateBucketParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) the resource is associated with.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Rate Limit resource.
    pub rate_limit_sid: String,
    /// Number of seconds that the rate limit will be enforced over.
    pub interval: i32,
    /// Maximum number of requests permitted in during the interval.
    pub max: i32
}

/// struct for passing parameters to the method [`create_challenge`]
#[derive(Clone, Debug, Default)]
pub struct CreateChallengeParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Challenge. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// The unique SID identifier of the Factor.
    pub factor_sid: String,
    /// Optional payload used to verify the Challenge upon creation. Only used with a Factor of type `totp` to carry the TOTP code that needs to be verified. For `TOTP` this value must be between 3 and 8 characters long.
    pub auth_payload: Option<String>,
    /// A list of objects that describe the Fields included in the Challenge. Each object contains the label and value of the field, the label can be up to 36 characters in length and the value can be up to 128 characters in length. Used when `factor_type` is `push`. There can be up to 20 details fields.
    pub details_fields: Option<Vec<serde_json::Value>>,
    /// Shown to the user when the push notification arrives. Required when `factor_type` is `push`. Can be up to 256 characters in length
    pub details_message: Option<String>,
    /// The date-time when this Challenge expires, given in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. The default value is five (5) minutes after Challenge creation. The max value is sixty (60) minutes after creation.
    pub expiration_date: Option<String>,
    /// Details provided to give context about the Challenge. Not shown to the end user. It must be a stringified JSON with only strings values eg. `{\\\"ip\\\": \\\"172.168.1.234\\\"}`. Can be up to 1024 characters in length
    pub hidden_details: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`create_entity`]
#[derive(Clone, Debug, Default)]
pub struct CreateEntityParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// The unique external identifier for the Entity of the Service. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String
}

/// struct for passing parameters to the method [`create_messaging_configuration`]
#[derive(Clone, Debug, Default)]
pub struct CreateMessagingConfigurationParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) that the resource is associated with.
    pub service_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country this configuration will be applied to. If this is a global configuration, Country will take the value `all`.
    pub country: String,
    /// The SID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) to be used to send SMS to the country of this configuration.
    pub messaging_service_sid: String
}

/// struct for passing parameters to the method [`create_new_factor`]
#[derive(Clone, Debug, Default)]
pub struct CreateNewFactorParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Factor. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// The Type of this Factor. Currently `push` and `totp` are supported. For `totp` to work, you need to contact [Twilio sales](https://www.twilio.com/help/sales) first to have the Verify TOTP feature enabled for your Twilio account.
    pub factor_type: String,
    /// The friendly name of this Factor. This can be any string up to 64 characters, meant for humans to distinguish between Factors. For `factor_type` `push`, this could be a device name. For `factor_type` `totp`, this value is used as the “account name” in constructing the `binding.uri` property. At the same time, we recommend avoiding providing PII.
    pub friendly_name: String,
    /// The algorithm used when `factor_type` is `push`. Algorithm supported: `ES256`
    pub binding_alg: Option<String>,
    /// The Ecdsa public key in PKIX, ASN.1 DER format encoded in Base64.  Required when `factor_type` is `push`
    pub binding_public_key: Option<String>,
    /// The shared secret for TOTP factors encoded in Base32. This can be provided when creating the Factor, otherwise it will be generated.  Used when `factor_type` is `totp`
    pub binding_secret: Option<String>,
    /// The algorithm used to derive the TOTP codes. Can be `sha1`, `sha256` or `sha512`. Defaults to `sha1`.  Used when `factor_type` is `totp`
    pub config_alg: Option<String>,
    /// The ID that uniquely identifies your app in the Google or Apple store, such as `com.example.myapp`. It can be up to 100 characters long.  Required when `factor_type` is `push`.
    pub config_app_id: Option<String>,
    /// Number of digits for generated TOTP codes. Must be between 3 and 8, inclusive. The default value is defined at the service level in the property `totp.code_length`. If not configured defaults to 6.  Used when `factor_type` is `totp`
    pub config_code_length: Option<i32>,
    /// The transport technology used to generate the Notification Token. Can be `apn` or `fcm`.  Required when `factor_type` is `push`.
    pub config_notification_platform: Option<String>,
    /// For APN, the device token. For FCM the registration token. It used to send the push notifications. Must be between 32 and 255 characters long.  Required when `factor_type` is `push`.
    pub config_notification_token: Option<String>,
    /// The Verify Push SDK version used to configure the factor  Required when `factor_type` is `push`
    pub config_sdk_version: Option<String>,
    /// The number of time-steps, past and future, that are valid for validation of TOTP codes. Must be between 0 and 2, inclusive. The default value is defined at the service level in the property `totp.skew`. If not configured defaults to 1.  Used when `factor_type` is `totp`
    pub config_skew: Option<i32>,
    /// Defines how often, in seconds, are TOTP codes generated. i.e, a new TOTP code is generated every time_step seconds. Must be between 20 and 60 seconds, inclusive. The default value is defined at the service level in the property `totp.time_step`. Defaults to 30 seconds if not configured.  Used when `factor_type` is `totp`
    pub config_time_step: Option<i32>
}

/// struct for passing parameters to the method [`create_notification`]
#[derive(Clone, Debug, Default)]
pub struct CreateNotificationParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Challenge. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// The unique SID identifier of the Challenge.
    pub challenge_sid: String,
    /// How long, in seconds, the notification is valid. Can be an integer between 0 and 300. Default is 300. Delivery is attempted until the TTL elapses, even if the device is offline. 0 means that the notification delivery is attempted immediately, only once, and is not stored for future delivery.
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method [`create_rate_limit`]
#[derive(Clone, Debug, Default)]
pub struct CreateRateLimitParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) the resource is associated with.
    pub service_sid: String,
    /// Provides a unique and addressable name to be assigned to this Rate Limit, assigned by the developer, to be optionally used in addition to SID. **This value should not contain PII.**
    pub unique_name: String,
    /// Description of this Rate Limit
    pub description: Option<String>
}

/// struct for passing parameters to the method [`create_service`]
#[derive(Clone, Debug, Default)]
pub struct CreateServiceParams {
    /// A descriptive string that you create to describe the verification service. It can be up to 30 characters long. **This value should not contain PII.**
    pub friendly_name: String,
    /// The length of the verification code to generate. Must be an integer value between 4 and 10, inclusive.
    pub code_length: Option<i32>,
    /// Whether to allow sending verifications with a custom code instead of a randomly generated one. Not available for all customers.
    pub custom_code_enabled: Option<bool>,
    /// Whether to add a security warning at the end of an SMS verification body. Disabled by default and applies only to SMS. Example SMS body: `Your AppName verification code is: 1234. Don’t share this code with anyone; our employees will never ask for the code`
    pub do_not_share_warning_enabled: Option<bool>,
    /// Whether to ask the user to press a number before delivering the verify code in a phone call.
    pub dtmf_input_required: Option<bool>,
    /// Whether to perform a lookup with each verification started and return info about the phone number.
    pub lookup_enabled: Option<bool>,
    /// Whether to pass PSD2 transaction parameters when starting a verification.
    pub psd2_enabled: Option<bool>,
    /// Optional configuration for the Push factors. Set the APN Credential for this service. This will allow to send push notifications to iOS devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
    pub push_apn_credential_sid: Option<String>,
    /// Optional configuration for the Push factors. Set the FCM Credential for this service. This will allow to send push notifications to Android devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
    pub push_fcm_credential_sid: Option<String>,
    /// Optional configuration for the Push factors. If true, include the date in the Challenge's reponse. Otherwise, the date is omitted from the response. See [Challenge](https://www.twilio.com/docs/verify/api/challenge) resource’s details parameter for more info. Default: true
    pub push_include_date: Option<bool>,
    /// Whether to skip sending SMS verifications to landlines. Requires `lookup_enabled`.
    pub skip_sms_to_landlines: Option<bool>,
    /// Optional configuration for the TOTP factors. Number of digits for generated TOTP codes. Must be between 3 and 8, inclusive. Defaults to 6
    pub totp_code_length: Option<i32>,
    /// Optional configuration for the TOTP factors. Set TOTP Issuer for this service. This will allow to configure the issuer of the TOTP URI. Defaults to the service friendly name if not provided.
    pub totp_issuer: Option<String>,
    /// Optional configuration for the TOTP factors. The number of time-steps, past and future, that are valid for validation of TOTP codes. Must be between 0 and 2, inclusive. Defaults to 1
    pub totp_skew: Option<i32>,
    /// Optional configuration for the TOTP factors. Defines how often, in seconds, are TOTP codes generated. i.e, a new TOTP code is generated every time_step seconds. Must be between 20 and 60 seconds, inclusive. Defaults to 30 seconds
    pub totp_time_step: Option<i32>,
    /// The name of an alternative text-to-speech service to use in phone calls. Applies only to TTS languages.
    pub tts_name: Option<String>
}

/// struct for passing parameters to the method [`create_verification`]
#[derive(Clone, Debug, Default)]
pub struct CreateVerificationParams {
    /// The SID of the verification [Service](https://www.twilio.com/docs/verify/api/service) to create the resource under.
    pub service_sid: String,
    /// The verification method to use. Can be: [`email`](https://www.twilio.com/docs/verify/email), `sms` or `call`.
    pub channel: String,
    /// The phone number or [email](https://www.twilio.com/docs/verify/email) to verify. Phone numbers must be in [E.164 format](https://www.twilio.com/docs/glossary/what-e164).
    pub to: String,
    /// The amount of the associated PSD2 compliant transaction. Requires the PSD2 Service flag enabled.
    pub amount: Option<String>,
    /// Your [App Hash](https://developers.google.com/identity/sms-retriever/verify#computing_your_apps_hash_string) to be appended at the end of your verification SMS body. Applies only to SMS. Example SMS body: `<#> Your AppName verification code is: 1234 He42w354ol9`.
    pub app_hash: Option<String>,
    /// [`email`](https://www.twilio.com/docs/verify/email) channel configuration in json format. Must include 'from' and 'from_name'.
    pub channel_configuration: Option<serde_json::Value>,
    /// A pre-generated code to use for verification. The code can be between 4 and 10 characters, inclusive.
    pub custom_code: Option<String>,
    /// A custom user defined friendly name that overwrites the existing one in the verification message
    pub custom_friendly_name: Option<String>,
    /// The text of a custom message to use for the verification.
    pub custom_message: Option<String>,
    /// The locale to use for the verification SMS or call. Can be: `af`, `ar`, `ca`, `cs`, `da`, `de`, `el`, `en`, `en-GB`, `es`, `fi`, `fr`, `he`, `hi`, `hr`, `hu`, `id`, `it`, `ja`, `ko`, `ms`, `nb`, `nl`, `pl`, `pt`, `pr-BR`, `ro`, `ru`, `sv`, `th`, `tl`, `tr`, `vi`, `zh`, `zh-CN`, or `zh-HK.`
    pub locale: Option<String>,
    /// The payee of the associated PSD2 compliant transaction. Requires the PSD2 Service flag enabled.
    pub payee: Option<String>,
    /// The custom key-value pairs of Programmable Rate Limits. Keys correspond to `unique_name` fields defined when [creating your Rate Limit](https://www.twilio.com/docs/verify/api/service-rate-limits). Associated value pairs represent values in the request that you are rate limiting on. You may include multiple Rate Limit values in each request.
    pub rate_limits: Option<serde_json::Value>,
    /// The digits to send after a phone call is answered, for example, to dial an extension. For more information, see the Programmable Voice documentation of [sendDigits](https://www.twilio.com/docs/voice/twiml/number#attributes-sendDigits).
    pub send_digits: Option<String>
}

/// struct for passing parameters to the method [`create_verification_check`]
#[derive(Clone, Debug, Default)]
pub struct CreateVerificationCheckParams {
    /// The SID of the verification [Service](https://www.twilio.com/docs/verify/api/service) to create the resource under.
    pub service_sid: String,
    /// The 4-10 character string being verified.
    pub code: String,
    /// The amount of the associated PSD2 compliant transaction. Requires the PSD2 Service flag enabled.
    pub amount: Option<String>,
    /// The payee of the associated PSD2 compliant transaction. Requires the PSD2 Service flag enabled.
    pub payee: Option<String>,
    /// The phone number or [email](https://www.twilio.com/docs/verify/email) to verify. Either this parameter or the `verification_sid` must be specified. Phone numbers must be in [E.164 format](https://www.twilio.com/docs/glossary/what-e164).
    pub to: Option<String>,
    /// A SID that uniquely identifies the Verification Check. Either this parameter or the `to` phone number/[email](https://www.twilio.com/docs/verify/email) must be specified.
    pub verification_sid: Option<String>
}

/// struct for passing parameters to the method [`create_webhook`]
#[derive(Clone, Debug, Default)]
pub struct CreateWebhookParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// The array of events that this Webhook is subscribed to. Possible event types: `*, factor.deleted, factor.created, factor.verified, challenge.approved, challenge.denied`
    pub event_types: Vec<String>,
    /// The string that you assigned to describe the webhook. **This value should not contain PII.**
    pub friendly_name: String,
    /// The URL associated with this Webhook.
    pub webhook_url: String,
    /// The webhook status. Default value is `enabled`. One of: `enabled` or `disabled`
    pub status: Option<String>,
    /// The webhook version. Default value is `v2` which includes all the latest fields. Version `v1` is legacy and may be removed in the future.
    pub version: Option<String>
}

/// struct for passing parameters to the method [`delete_bucket`]
#[derive(Clone, Debug, Default)]
pub struct DeleteBucketParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) the resource is associated with.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Rate Limit resource.
    pub rate_limit_sid: String,
    /// A 34 character string that uniquely identifies this Bucket.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_entity`]
#[derive(Clone, Debug, Default)]
pub struct DeleteEntityParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// The unique external identifier for the Entity of the Service. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String
}

/// struct for passing parameters to the method [`delete_factor`]
#[derive(Clone, Debug, Default)]
pub struct DeleteFactorParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Factor. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// A 34 character string that uniquely identifies this Factor.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_messaging_configuration`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMessagingConfigurationParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) that the resource is associated with.
    pub service_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country this configuration will be applied to. If this is a global configuration, Country will take the value `all`.
    pub country: String
}

/// struct for passing parameters to the method [`delete_rate_limit`]
#[derive(Clone, Debug, Default)]
pub struct DeleteRateLimitParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) the resource is associated with.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Rate Limit resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_service`]
#[derive(Clone, Debug, Default)]
pub struct DeleteServiceParams {
    /// The Twilio-provided string that uniquely identifies the Verification Service resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`delete_webhook`]
#[derive(Clone, Debug, Default)]
pub struct DeleteWebhookParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Webhook resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_bucket`]
#[derive(Clone, Debug, Default)]
pub struct FetchBucketParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) the resource is associated with.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Rate Limit resource.
    pub rate_limit_sid: String,
    /// A 34 character string that uniquely identifies this Bucket.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_challenge`]
#[derive(Clone, Debug, Default)]
pub struct FetchChallengeParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Challenges. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// A 34 character string that uniquely identifies this Challenge.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_entity`]
#[derive(Clone, Debug, Default)]
pub struct FetchEntityParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// The unique external identifier for the Entity of the Service. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String
}

/// struct for passing parameters to the method [`fetch_factor`]
#[derive(Clone, Debug, Default)]
pub struct FetchFactorParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Factor. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// A 34 character string that uniquely identifies this Factor.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_form`]
#[derive(Clone, Debug, Default)]
pub struct FetchFormParams {
    /// The Type of this Form. Currently only `form-push` is supported.
    pub form_type: String
}

/// struct for passing parameters to the method [`fetch_messaging_configuration`]
#[derive(Clone, Debug, Default)]
pub struct FetchMessagingConfigurationParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) that the resource is associated with.
    pub service_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country this configuration will be applied to. If this is a global configuration, Country will take the value `all`.
    pub country: String
}

/// struct for passing parameters to the method [`fetch_rate_limit`]
#[derive(Clone, Debug, Default)]
pub struct FetchRateLimitParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) the resource is associated with.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Rate Limit resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service`]
#[derive(Clone, Debug, Default)]
pub struct FetchServiceParams {
    /// The Twilio-provided string that uniquely identifies the Verification Service resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_verification`]
#[derive(Clone, Debug, Default)]
pub struct FetchVerificationParams {
    /// The SID of the verification [Service](https://www.twilio.com/docs/verify/api/service) to fetch the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Verification resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_verification_attempt`]
#[derive(Clone, Debug, Default)]
pub struct FetchVerificationAttemptParams {
    /// The unique SID identifier of a Verification Attempt
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_webhook`]
#[derive(Clone, Debug, Default)]
pub struct FetchWebhookParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Webhook resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`list_bucket`]
#[derive(Clone, Debug, Default)]
pub struct ListBucketParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) the resource is associated with.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Rate Limit resource.
    pub rate_limit_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_challenge`]
#[derive(Clone, Debug, Default)]
pub struct ListChallengeParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Challenge. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// The unique SID identifier of the Factor.
    pub factor_sid: Option<String>,
    /// The Status of the Challenges to fetch. One of `pending`, `expired`, `approved` or `denied`.
    pub status: Option<String>,
    /// The desired sort order of the Challenges list. One of `asc` or `desc` for ascending and descending respectively. Defaults to `asc`.
    pub order: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_entity`]
#[derive(Clone, Debug, Default)]
pub struct ListEntityParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_factor`]
#[derive(Clone, Debug, Default)]
pub struct ListFactorParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Factors. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_messaging_configuration`]
#[derive(Clone, Debug, Default)]
pub struct ListMessagingConfigurationParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) that the resource is associated with.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_rate_limit`]
#[derive(Clone, Debug, Default)]
pub struct ListRateLimitParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) the resource is associated with.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_service`]
#[derive(Clone, Debug, Default)]
pub struct ListServiceParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_verification_attempt`]
#[derive(Clone, Debug, Default)]
pub struct ListVerificationAttemptParams {
    /// Datetime filter used to query Verification Attempts created after this datetime.
    pub date_created_after: Option<String>,
    /// Datetime filter used to query Verification Attempts created before this datetime.
    pub date_created_before: Option<String>,
    /// Destination of a verification. Depending on the type of channel, it could be a phone number in E.164 format or an email address.
    pub channel_data_to: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_verification_template`]
#[derive(Clone, Debug, Default)]
pub struct ListVerificationTemplateParams {
    /// String filter used to query templates with a given friendly name
    pub friendly_name: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`list_webhook`]
#[derive(Clone, Debug, Default)]
pub struct ListWebhookParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`update_bucket`]
#[derive(Clone, Debug, Default)]
pub struct UpdateBucketParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) the resource is associated with.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Rate Limit resource.
    pub rate_limit_sid: String,
    /// A 34 character string that uniquely identifies this Bucket.
    pub sid: String,
    /// Number of seconds that the rate limit will be enforced over.
    pub interval: Option<i32>,
    /// Maximum number of requests permitted in during the interval.
    pub max: Option<i32>
}

/// struct for passing parameters to the method [`update_challenge`]
#[derive(Clone, Debug, Default)]
pub struct UpdateChallengeParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Challenge. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// A 34 character string that uniquely identifies this Challenge.
    pub sid: String,
    /// The optional payload needed to verify the Challenge. E.g., a TOTP would use the numeric code. For `TOTP` this value must be between 3 and 8 characters long. For `Push` this value can be up to 5456 characters in length
    pub auth_payload: Option<String>
}

/// struct for passing parameters to the method [`update_factor`]
#[derive(Clone, Debug, Default)]
pub struct UpdateFactorParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Factor. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// A 34 character string that uniquely identifies this Factor.
    pub sid: String,
    /// The optional payload needed to verify the Factor for the first time. E.g. for a TOTP, the numeric code.
    pub auth_payload: Option<String>,
    /// The algorithm used to derive the TOTP codes. Can be `sha1`, `sha256` or `sha512`
    pub config_alg: Option<String>,
    /// Number of digits for generated TOTP codes. Must be between 3 and 8, inclusive
    pub config_code_length: Option<i32>,
    /// For APN, the device token. For FCM the registration token. It used to send the push notifications. Required when `factor_type` is `push`. If specified, this value must be between 32 and 255 characters long.
    pub config_notification_token: Option<String>,
    /// The Verify Push SDK version used to configure the factor
    pub config_sdk_version: Option<String>,
    /// The number of time-steps, past and future, that are valid for validation of TOTP codes. Must be between 0 and 2, inclusive
    pub config_skew: Option<i32>,
    /// Defines how often, in seconds, are TOTP codes generated. i.e, a new TOTP code is generated every time_step seconds. Must be between 20 and 60 seconds, inclusive
    pub config_time_step: Option<i32>,
    /// The new friendly name of this Factor. It can be up to 64 characters.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method [`update_messaging_configuration`]
#[derive(Clone, Debug, Default)]
pub struct UpdateMessagingConfigurationParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) that the resource is associated with.
    pub service_sid: String,
    /// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country this configuration will be applied to. If this is a global configuration, Country will take the value `all`.
    pub country: String,
    /// The SID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) to be used to send SMS to the country of this configuration.
    pub messaging_service_sid: String
}

/// struct for passing parameters to the method [`update_rate_limit`]
#[derive(Clone, Debug, Default)]
pub struct UpdateRateLimitParams {
    /// The SID of the [Service](https://www.twilio.com/docs/verify/api/service) the resource is associated with.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Rate Limit resource to fetch.
    pub sid: String,
    /// Description of this Rate Limit
    pub description: Option<String>
}

/// struct for passing parameters to the method [`update_service`]
#[derive(Clone, Debug, Default)]
pub struct UpdateServiceParams {
    /// The Twilio-provided string that uniquely identifies the Service resource to update.
    pub sid: String,
    /// The length of the verification code to generate. Must be an integer value between 4 and 10, inclusive.
    pub code_length: Option<i32>,
    /// Whether to allow sending verifications with a custom code instead of a randomly generated one. Not available for all customers.
    pub custom_code_enabled: Option<bool>,
    /// Whether to add a privacy warning at the end of an SMS. **Disabled by default and applies only for SMS.**
    pub do_not_share_warning_enabled: Option<bool>,
    /// Whether to ask the user to press a number before delivering the verify code in a phone call.
    pub dtmf_input_required: Option<bool>,
    /// A descriptive string that you create to describe the verification service. It can be up to 30 characters long. **This value should not contain PII.**
    pub friendly_name: Option<String>,
    /// Whether to perform a lookup with each verification started and return info about the phone number.
    pub lookup_enabled: Option<bool>,
    /// Whether to pass PSD2 transaction parameters when starting a verification.
    pub psd2_enabled: Option<bool>,
    /// Optional configuration for the Push factors. Set the APN Credential for this service. This will allow to send push notifications to iOS devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
    pub push_apn_credential_sid: Option<String>,
    /// Optional configuration for the Push factors. Set the FCM Credential for this service. This will allow to send push notifications to Android devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
    pub push_fcm_credential_sid: Option<String>,
    /// Optional configuration for the Push factors. If true, include the date in the Challenge's reponse. Otherwise, the date is omitted from the response. See [Challenge](https://www.twilio.com/docs/verify/api/challenge) resource’s details parameter for more info. Default: true
    pub push_include_date: Option<bool>,
    /// Whether to skip sending SMS verifications to landlines. Requires `lookup_enabled`.
    pub skip_sms_to_landlines: Option<bool>,
    /// Optional configuration for the TOTP factors. Number of digits for generated TOTP codes. Must be between 3 and 8, inclusive. Defaults to 6
    pub totp_code_length: Option<i32>,
    /// Optional configuration for the TOTP factors. Set TOTP Issuer for this service. This will allow to configure the issuer of the TOTP URI.
    pub totp_issuer: Option<String>,
    /// Optional configuration for the TOTP factors. The number of time-steps, past and future, that are valid for validation of TOTP codes. Must be between 0 and 2, inclusive. Defaults to 1
    pub totp_skew: Option<i32>,
    /// Optional configuration for the TOTP factors. Defines how often, in seconds, are TOTP codes generated. i.e, a new TOTP code is generated every time_step seconds. Must be between 20 and 60 seconds, inclusive. Defaults to 30 seconds
    pub totp_time_step: Option<i32>,
    /// The name of an alternative text-to-speech service to use in phone calls. Applies only to TTS languages.
    pub tts_name: Option<String>
}

/// struct for passing parameters to the method [`update_verification`]
#[derive(Clone, Debug, Default)]
pub struct UpdateVerificationParams {
    /// The SID of the verification [Service](https://www.twilio.com/docs/verify/api/service) to update the resource from.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Verification resource to update.
    pub sid: String,
    /// The new status of the resource. Can be: `canceled` or `approved`.
    pub status: String
}

/// struct for passing parameters to the method [`update_webhook`]
#[derive(Clone, Debug, Default)]
pub struct UpdateWebhookParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// The Twilio-provided string that uniquely identifies the Webhook resource to update.
    pub sid: String,
    /// The array of events that this Webhook is subscribed to. Possible event types: `*, factor.deleted, factor.created, factor.verified, challenge.approved, challenge.denied`
    pub event_types: Option<Vec<String>>,
    /// The string that you assigned to describe the webhook. **This value should not contain PII.**
    pub friendly_name: Option<String>,
    /// The webhook status. Default value is `enabled`. One of: `enabled` or `disabled`
    pub status: Option<String>,
    /// The webhook version. Default value is `v2` which includes all the latest fields. Version `v1` is legacy and may be removed in the future.
    pub version: Option<String>,
    /// The URL associated with this Webhook.
    pub webhook_url: Option<String>
}


/// struct for typed successes of method [`create_access_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAccessTokenSuccess {
    Status201(crate::models::VerifyV2ServiceAccessToken),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_bucket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBucketSuccess {
    Status201(crate::models::VerifyV2ServiceRateLimitBucket),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChallengeSuccess {
    Status201(crate::models::VerifyV2ServiceEntityChallenge),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_entity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEntitySuccess {
    Status201(crate::models::VerifyV2ServiceEntity),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_messaging_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessagingConfigurationSuccess {
    Status201(crate::models::VerifyV2ServiceMessagingConfiguration),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_new_factor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNewFactorSuccess {
    Status201(crate::models::VerifyV2ServiceEntityNewFactor),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNotificationSuccess {
    Status201(crate::models::VerifyV2ServiceEntityChallengeNotification),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_rate_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRateLimitSuccess {
    Status201(crate::models::VerifyV2ServiceRateLimit),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceSuccess {
    Status201(crate::models::VerifyV2Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_verification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVerificationSuccess {
    Status201(crate::models::VerifyV2ServiceVerification),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_verification_check`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVerificationCheckSuccess {
    Status201(crate::models::VerifyV2ServiceVerificationCheck),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebhookSuccess {
    Status201(crate::models::VerifyV2ServiceWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_bucket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBucketSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_entity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEntitySuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_factor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFactorSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_messaging_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessagingConfigurationSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_rate_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRateLimitSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebhookSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_bucket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBucketSuccess {
    Status200(crate::models::VerifyV2ServiceRateLimitBucket),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChallengeSuccess {
    Status200(crate::models::VerifyV2ServiceEntityChallenge),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_entity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEntitySuccess {
    Status200(crate::models::VerifyV2ServiceEntity),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_factor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFactorSuccess {
    Status200(crate::models::VerifyV2ServiceEntityFactor),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_form`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFormSuccess {
    Status200(crate::models::VerifyV2Form),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_messaging_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessagingConfigurationSuccess {
    Status200(crate::models::VerifyV2ServiceMessagingConfiguration),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_rate_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRateLimitSuccess {
    Status200(crate::models::VerifyV2ServiceRateLimit),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceSuccess {
    Status200(crate::models::VerifyV2Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_verification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchVerificationSuccess {
    Status200(crate::models::VerifyV2ServiceVerification),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_verification_attempt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchVerificationAttemptSuccess {
    Status200(crate::models::VerifyV2VerificationAttempt),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWebhookSuccess {
    Status200(crate::models::VerifyV2ServiceWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_bucket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBucketSuccess {
    Status200(crate::models::ListBucketResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChallengeSuccess {
    Status200(crate::models::ListChallengeResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_entity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEntitySuccess {
    Status200(crate::models::ListEntityResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_factor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFactorSuccess {
    Status200(crate::models::ListFactorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_messaging_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessagingConfigurationSuccess {
    Status200(crate::models::ListMessagingConfigurationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_rate_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRateLimitSuccess {
    Status200(crate::models::ListRateLimitResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceSuccess {
    Status200(crate::models::ListServiceResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_verification_attempt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListVerificationAttemptSuccess {
    Status200(crate::models::ListVerificationAttemptResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_verification_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListVerificationTemplateSuccess {
    Status200(crate::models::ListVerificationTemplateResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWebhookSuccess {
    Status200(crate::models::ListWebhookResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_bucket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateBucketSuccess {
    Status200(crate::models::VerifyV2ServiceRateLimitBucket),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChallengeSuccess {
    Status200(crate::models::VerifyV2ServiceEntityChallenge),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_factor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFactorSuccess {
    Status200(crate::models::VerifyV2ServiceEntityFactor),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_messaging_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessagingConfigurationSuccess {
    Status200(crate::models::VerifyV2ServiceMessagingConfiguration),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_rate_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRateLimitSuccess {
    Status200(crate::models::VerifyV2ServiceRateLimit),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceSuccess {
    Status200(crate::models::VerifyV2Service),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_verification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateVerificationSuccess {
    Status200(crate::models::VerifyV2ServiceVerification),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebhookSuccess {
    Status200(crate::models::VerifyV2ServiceWebhook),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_access_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAccessTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_bucket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBucketError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChallengeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_entity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEntityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_messaging_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMessagingConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_new_factor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNewFactorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_notification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNotificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_rate_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRateLimitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_verification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVerificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_verification_check`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVerificationCheckError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_bucket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBucketError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_entity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEntityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_factor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFactorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_messaging_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessagingConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_rate_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRateLimitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_bucket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchBucketError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChallengeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_entity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchEntityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_factor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFactorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_form`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFormError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_messaging_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchMessagingConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_rate_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRateLimitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_verification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchVerificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_verification_attempt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchVerificationAttemptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_bucket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListBucketError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChallengeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_entity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEntityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_factor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFactorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_messaging_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessagingConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_rate_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRateLimitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_verification_attempt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListVerificationAttemptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_verification_template`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListVerificationTemplateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWebhookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_bucket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateBucketError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChallengeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_factor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFactorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_messaging_configuration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMessagingConfigurationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_rate_limit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRateLimitError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_verification`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateVerificationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebhookError {
    UnknownValue(serde_json::Value),
}


/// Create a new enrollment Access Token for the Entity
pub async fn create_access_token(configuration: &configuration::Configuration, params: CreateAccessTokenParams) -> Result<ResponseContent<CreateAccessTokenSuccess>, Error<CreateAccessTokenError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let factor_type = params.factor_type;
    let identity = params.identity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/AccessTokens", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("FactorType", factor_type.to_string());
    local_var_form_params.insert("Identity", identity.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateAccessTokenSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateAccessTokenError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Bucket for a Rate Limit
pub async fn create_bucket(configuration: &configuration::Configuration, params: CreateBucketParams) -> Result<ResponseContent<CreateBucketSuccess>, Error<CreateBucketError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let rate_limit_sid = params.rate_limit_sid;
    let interval = params.interval;
    let max = params.max;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), RateLimitSid=crate::apis::urlencode(rate_limit_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Interval", interval.to_string());
    local_var_form_params.insert("Max", max.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateBucketSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateBucketError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Challenge for the Factor
pub async fn create_challenge(configuration: &configuration::Configuration, params: CreateChallengeParams) -> Result<ResponseContent<CreateChallengeSuccess>, Error<CreateChallengeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let factor_sid = params.factor_sid;
    let auth_payload = params.auth_payload;
    let details_fields = params.details_fields;
    let details_message = params.details_message;
    let expiration_date = params.expiration_date;
    let hidden_details = params.hidden_details;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = auth_payload {
        local_var_form_params.insert("AuthPayload", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = details_fields {
        local_var_form_params.insert("Details.Fields", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = details_message {
        local_var_form_params.insert("Details.Message", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = expiration_date {
        local_var_form_params.insert("ExpirationDate", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FactorSid", factor_sid.to_string());
    if let Some(local_var_param_value) = hidden_details {
        local_var_form_params.insert("HiddenDetails", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateChallengeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateChallengeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Entity for the Service
pub async fn create_entity(configuration: &configuration::Configuration, params: CreateEntityParams) -> Result<ResponseContent<CreateEntitySuccess>, Error<CreateEntityError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Identity", identity.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateEntitySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateEntityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new MessagingConfiguration for a service.
pub async fn create_messaging_configuration(configuration: &configuration::Configuration, params: CreateMessagingConfigurationParams) -> Result<ResponseContent<CreateMessagingConfigurationSuccess>, Error<CreateMessagingConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let country = params.country;
    let messaging_service_sid = params.messaging_service_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/MessagingConfigurations", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Country", country.to_string());
    local_var_form_params.insert("MessagingServiceSid", messaging_service_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateMessagingConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateMessagingConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Factor for the Entity
pub async fn create_new_factor(configuration: &configuration::Configuration, params: CreateNewFactorParams) -> Result<ResponseContent<CreateNewFactorSuccess>, Error<CreateNewFactorError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let factor_type = params.factor_type;
    let friendly_name = params.friendly_name;
    let binding_alg = params.binding_alg;
    let binding_public_key = params.binding_public_key;
    let binding_secret = params.binding_secret;
    let config_alg = params.config_alg;
    let config_app_id = params.config_app_id;
    let config_code_length = params.config_code_length;
    let config_notification_platform = params.config_notification_platform;
    let config_notification_token = params.config_notification_token;
    let config_sdk_version = params.config_sdk_version;
    let config_skew = params.config_skew;
    let config_time_step = params.config_time_step;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Factors", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = binding_alg {
        local_var_form_params.insert("Binding.Alg", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = binding_public_key {
        local_var_form_params.insert("Binding.PublicKey", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = binding_secret {
        local_var_form_params.insert("Binding.Secret", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_alg {
        local_var_form_params.insert("Config.Alg", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_app_id {
        local_var_form_params.insert("Config.AppId", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_code_length {
        local_var_form_params.insert("Config.CodeLength", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_notification_platform {
        local_var_form_params.insert("Config.NotificationPlatform", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_notification_token {
        local_var_form_params.insert("Config.NotificationToken", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_sdk_version {
        local_var_form_params.insert("Config.SdkVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_skew {
        local_var_form_params.insert("Config.Skew", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_time_step {
        local_var_form_params.insert("Config.TimeStep", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FactorType", factor_type.to_string());
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateNewFactorSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateNewFactorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Notification for the corresponding Challenge
pub async fn create_notification(configuration: &configuration::Configuration, params: CreateNotificationParams) -> Result<ResponseContent<CreateNotificationSuccess>, Error<CreateNotificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let challenge_sid = params.challenge_sid;
    let ttl = params.ttl;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{ChallengeSid}/Notifications", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity), ChallengeSid=crate::apis::urlencode(challenge_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = ttl {
        local_var_form_params.insert("Ttl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateNotificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateNotificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Rate Limit for a Service
pub async fn create_rate_limit(configuration: &configuration::Configuration, params: CreateRateLimitParams) -> Result<ResponseContent<CreateRateLimitSuccess>, Error<CreateRateLimitError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let unique_name = params.unique_name;
    let description = params.description;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/RateLimits", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = description {
        local_var_form_params.insert("Description", local_var_param_value.to_string());
    }
    local_var_form_params.insert("UniqueName", unique_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRateLimitSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRateLimitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Verification Service.
pub async fn create_service(configuration: &configuration::Configuration, params: CreateServiceParams) -> Result<ResponseContent<CreateServiceSuccess>, Error<CreateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let code_length = params.code_length;
    let custom_code_enabled = params.custom_code_enabled;
    let do_not_share_warning_enabled = params.do_not_share_warning_enabled;
    let dtmf_input_required = params.dtmf_input_required;
    let lookup_enabled = params.lookup_enabled;
    let psd2_enabled = params.psd2_enabled;
    let push_apn_credential_sid = params.push_apn_credential_sid;
    let push_fcm_credential_sid = params.push_fcm_credential_sid;
    let push_include_date = params.push_include_date;
    let skip_sms_to_landlines = params.skip_sms_to_landlines;
    let totp_code_length = params.totp_code_length;
    let totp_issuer = params.totp_issuer;
    let totp_skew = params.totp_skew;
    let totp_time_step = params.totp_time_step;
    let tts_name = params.tts_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = code_length {
        local_var_form_params.insert("CodeLength", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = custom_code_enabled {
        local_var_form_params.insert("CustomCodeEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = do_not_share_warning_enabled {
        local_var_form_params.insert("DoNotShareWarningEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dtmf_input_required {
        local_var_form_params.insert("DtmfInputRequired", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = lookup_enabled {
        local_var_form_params.insert("LookupEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = psd2_enabled {
        local_var_form_params.insert("Psd2Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = push_apn_credential_sid {
        local_var_form_params.insert("Push.ApnCredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = push_fcm_credential_sid {
        local_var_form_params.insert("Push.FcmCredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = push_include_date {
        local_var_form_params.insert("Push.IncludeDate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = skip_sms_to_landlines {
        local_var_form_params.insert("SkipSmsToLandlines", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = totp_code_length {
        local_var_form_params.insert("Totp.CodeLength", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = totp_issuer {
        local_var_form_params.insert("Totp.Issuer", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = totp_skew {
        local_var_form_params.insert("Totp.Skew", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = totp_time_step {
        local_var_form_params.insert("Totp.TimeStep", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = tts_name {
        local_var_form_params.insert("TtsName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Verification using a Service
pub async fn create_verification(configuration: &configuration::Configuration, params: CreateVerificationParams) -> Result<ResponseContent<CreateVerificationSuccess>, Error<CreateVerificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let channel = params.channel;
    let to = params.to;
    let amount = params.amount;
    let app_hash = params.app_hash;
    let channel_configuration = params.channel_configuration;
    let custom_code = params.custom_code;
    let custom_friendly_name = params.custom_friendly_name;
    let custom_message = params.custom_message;
    let locale = params.locale;
    let payee = params.payee;
    let rate_limits = params.rate_limits;
    let send_digits = params.send_digits;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Verifications", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = amount {
        local_var_form_params.insert("Amount", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = app_hash {
        local_var_form_params.insert("AppHash", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Channel", channel.to_string());
    if let Some(local_var_param_value) = channel_configuration {
        local_var_form_params.insert("ChannelConfiguration", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = custom_code {
        local_var_form_params.insert("CustomCode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = custom_friendly_name {
        local_var_form_params.insert("CustomFriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = custom_message {
        local_var_form_params.insert("CustomMessage", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = locale {
        local_var_form_params.insert("Locale", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = payee {
        local_var_form_params.insert("Payee", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = rate_limits {
        local_var_form_params.insert("RateLimits", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = send_digits {
        local_var_form_params.insert("SendDigits", local_var_param_value.to_string());
    }
    local_var_form_params.insert("To", to.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateVerificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateVerificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// challenge a specific Verification Check.
pub async fn create_verification_check(configuration: &configuration::Configuration, params: CreateVerificationCheckParams) -> Result<ResponseContent<CreateVerificationCheckSuccess>, Error<CreateVerificationCheckError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let code = params.code;
    let amount = params.amount;
    let payee = params.payee;
    let to = params.to;
    let verification_sid = params.verification_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/VerificationCheck", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = amount {
        local_var_form_params.insert("Amount", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Code", code.to_string());
    if let Some(local_var_param_value) = payee {
        local_var_form_params.insert("Payee", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = to {
        local_var_form_params.insert("To", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = verification_sid {
        local_var_form_params.insert("VerificationSid", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateVerificationCheckSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateVerificationCheckError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Webhook for the Service
pub async fn create_webhook(configuration: &configuration::Configuration, params: CreateWebhookParams) -> Result<ResponseContent<CreateWebhookSuccess>, Error<CreateWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let event_types = params.event_types;
    let friendly_name = params.friendly_name;
    let webhook_url = params.webhook_url;
    let status = params.status;
    let version = params.version;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Webhooks", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("EventTypes", event_types.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = version {
        local_var_form_params.insert("Version", local_var_param_value.to_string());
    }
    local_var_form_params.insert("WebhookUrl", webhook_url.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Bucket.
pub async fn delete_bucket(configuration: &configuration::Configuration, params: DeleteBucketParams) -> Result<ResponseContent<DeleteBucketSuccess>, Error<DeleteBucketError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let rate_limit_sid = params.rate_limit_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), RateLimitSid=crate::apis::urlencode(rate_limit_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteBucketSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteBucketError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Entity.
pub async fn delete_entity(configuration: &configuration::Configuration, params: DeleteEntityParams) -> Result<ResponseContent<DeleteEntitySuccess>, Error<DeleteEntityError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteEntitySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteEntityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Factor.
pub async fn delete_factor(configuration: &configuration::Configuration, params: DeleteFactorParams) -> Result<ResponseContent<DeleteFactorSuccess>, Error<DeleteFactorError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteFactorSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteFactorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific MessagingConfiguration.
pub async fn delete_messaging_configuration(configuration: &configuration::Configuration, params: DeleteMessagingConfigurationParams) -> Result<ResponseContent<DeleteMessagingConfigurationSuccess>, Error<DeleteMessagingConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let country = params.country;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Country=crate::apis::urlencode(country));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteMessagingConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteMessagingConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Rate Limit.
pub async fn delete_rate_limit(configuration: &configuration::Configuration, params: DeleteRateLimitParams) -> Result<ResponseContent<DeleteRateLimitSuccess>, Error<DeleteRateLimitError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/RateLimits/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRateLimitSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRateLimitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Verification Service Instance.
pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<ResponseContent<DeleteServiceSuccess>, Error<DeleteServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific Webhook.
pub async fn delete_webhook(configuration: &configuration::Configuration, params: DeleteWebhookParams) -> Result<ResponseContent<DeleteWebhookSuccess>, Error<DeleteWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Webhooks/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Bucket.
pub async fn fetch_bucket(configuration: &configuration::Configuration, params: FetchBucketParams) -> Result<ResponseContent<FetchBucketSuccess>, Error<FetchBucketError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let rate_limit_sid = params.rate_limit_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), RateLimitSid=crate::apis::urlencode(rate_limit_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchBucketSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchBucketError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Challenge.
pub async fn fetch_challenge(configuration: &configuration::Configuration, params: FetchChallengeParams) -> Result<ResponseContent<FetchChallengeSuccess>, Error<FetchChallengeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchChallengeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchChallengeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Entity.
pub async fn fetch_entity(configuration: &configuration::Configuration, params: FetchEntityParams) -> Result<ResponseContent<FetchEntitySuccess>, Error<FetchEntityError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchEntitySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchEntityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Factor.
pub async fn fetch_factor(configuration: &configuration::Configuration, params: FetchFactorParams) -> Result<ResponseContent<FetchFactorSuccess>, Error<FetchFactorError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFactorSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFactorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the forms for a specific Form Type.
pub async fn fetch_form(configuration: &configuration::Configuration, params: FetchFormParams) -> Result<ResponseContent<FetchFormSuccess>, Error<FetchFormError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let form_type = params.form_type;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Forms/{FormType}", local_var_configuration.base_path, FormType=crate::apis::urlencode(form_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchFormSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchFormError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific MessagingConfiguration.
pub async fn fetch_messaging_configuration(configuration: &configuration::Configuration, params: FetchMessagingConfigurationParams) -> Result<ResponseContent<FetchMessagingConfigurationSuccess>, Error<FetchMessagingConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let country = params.country;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Country=crate::apis::urlencode(country));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchMessagingConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchMessagingConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Rate Limit.
pub async fn fetch_rate_limit(configuration: &configuration::Configuration, params: FetchRateLimitParams) -> Result<ResponseContent<FetchRateLimitSuccess>, Error<FetchRateLimitError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/RateLimits/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRateLimitSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRateLimitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch specific Verification Service Instance.
pub async fn fetch_service(configuration: &configuration::Configuration, params: FetchServiceParams) -> Result<ResponseContent<FetchServiceSuccess>, Error<FetchServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Verification
pub async fn fetch_verification(configuration: &configuration::Configuration, params: FetchVerificationParams) -> Result<ResponseContent<FetchVerificationSuccess>, Error<FetchVerificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Verifications/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchVerificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchVerificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific verification attempt.
pub async fn fetch_verification_attempt(configuration: &configuration::Configuration, params: FetchVerificationAttemptParams) -> Result<ResponseContent<FetchVerificationAttemptSuccess>, Error<FetchVerificationAttemptError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Attempts/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchVerificationAttemptSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchVerificationAttemptError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a specific Webhook.
pub async fn fetch_webhook(configuration: &configuration::Configuration, params: FetchWebhookParams) -> Result<ResponseContent<FetchWebhookSuccess>, Error<FetchWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Webhooks/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Buckets for a Rate Limit.
pub async fn list_bucket(configuration: &configuration::Configuration, params: ListBucketParams) -> Result<ResponseContent<ListBucketSuccess>, Error<ListBucketError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let rate_limit_sid = params.rate_limit_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), RateLimitSid=crate::apis::urlencode(rate_limit_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListBucketSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListBucketError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Challenges for a Factor.
pub async fn list_challenge(configuration: &configuration::Configuration, params: ListChallengeParams) -> Result<ResponseContent<ListChallengeSuccess>, Error<ListChallengeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let factor_sid = params.factor_sid;
    let status = params.status;
    let order = params.order;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = factor_sid {
        local_var_req_builder = local_var_req_builder.query(&[("FactorSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("Order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListChallengeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListChallengeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Entities for a Service.
pub async fn list_entity(configuration: &configuration::Configuration, params: ListEntityParams) -> Result<ResponseContent<ListEntitySuccess>, Error<ListEntityError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListEntitySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListEntityError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Factors for an Entity.
pub async fn list_factor(configuration: &configuration::Configuration, params: ListFactorParams) -> Result<ResponseContent<ListFactorSuccess>, Error<ListFactorError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Factors", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListFactorSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListFactorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Messaging Configurations for a Service.
pub async fn list_messaging_configuration(configuration: &configuration::Configuration, params: ListMessagingConfigurationParams) -> Result<ResponseContent<ListMessagingConfigurationSuccess>, Error<ListMessagingConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/MessagingConfigurations", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListMessagingConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListMessagingConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Rate Limits for a service.
pub async fn list_rate_limit(configuration: &configuration::Configuration, params: ListRateLimitParams) -> Result<ResponseContent<ListRateLimitSuccess>, Error<ListRateLimitError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/RateLimits", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRateLimitSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRateLimitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Verification Services for an account.
pub async fn list_service(configuration: &configuration::Configuration, params: ListServiceParams) -> Result<ResponseContent<ListServiceSuccess>, Error<ListServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all the verification attempts for a given Account.
pub async fn list_verification_attempt(configuration: &configuration::Configuration, params: ListVerificationAttemptParams) -> Result<ResponseContent<ListVerificationAttemptSuccess>, Error<ListVerificationAttemptError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let date_created_after = params.date_created_after;
    let date_created_before = params.date_created_before;
    let channel_data_to = params.channel_data_to;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Attempts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = date_created_after {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreatedAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_before {
        local_var_req_builder = local_var_req_builder.query(&[("DateCreatedBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = channel_data_to {
        local_var_req_builder = local_var_req_builder.query(&[("ChannelData.To", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListVerificationAttemptSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListVerificationAttemptError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all the available templates for a given Account.
pub async fn list_verification_template(configuration: &configuration::Configuration, params: ListVerificationTemplateParams) -> Result<ResponseContent<ListVerificationTemplateSuccess>, Error<ListVerificationTemplateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Templates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder = local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListVerificationTemplateSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListVerificationTemplateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of all Webhooks for a Service.
pub async fn list_webhook(configuration: &configuration::Configuration, params: ListWebhookParams) -> Result<ResponseContent<ListWebhookSuccess>, Error<ListWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Webhooks", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Bucket.
pub async fn update_bucket(configuration: &configuration::Configuration, params: UpdateBucketParams) -> Result<ResponseContent<UpdateBucketSuccess>, Error<UpdateBucketError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let rate_limit_sid = params.rate_limit_sid;
    let sid = params.sid;
    let interval = params.interval;
    let max = params.max;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), RateLimitSid=crate::apis::urlencode(rate_limit_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = interval {
        local_var_form_params.insert("Interval", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = max {
        local_var_form_params.insert("Max", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateBucketSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateBucketError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Verify a specific Challenge.
pub async fn update_challenge(configuration: &configuration::Configuration, params: UpdateChallengeParams) -> Result<ResponseContent<UpdateChallengeSuccess>, Error<UpdateChallengeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let sid = params.sid;
    let auth_payload = params.auth_payload;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = auth_payload {
        local_var_form_params.insert("AuthPayload", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateChallengeSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateChallengeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Factor. This endpoint can be used to Verify a Factor if passed an `AuthPayload` param.
pub async fn update_factor(configuration: &configuration::Configuration, params: UpdateFactorParams) -> Result<ResponseContent<UpdateFactorSuccess>, Error<UpdateFactorError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let identity = params.identity;
    let sid = params.sid;
    let auth_payload = params.auth_payload;
    let config_alg = params.config_alg;
    let config_code_length = params.config_code_length;
    let config_notification_token = params.config_notification_token;
    let config_sdk_version = params.config_sdk_version;
    let config_skew = params.config_skew;
    let config_time_step = params.config_time_step;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Identity=crate::apis::urlencode(identity), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = auth_payload {
        local_var_form_params.insert("AuthPayload", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_alg {
        local_var_form_params.insert("Config.Alg", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_code_length {
        local_var_form_params.insert("Config.CodeLength", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_notification_token {
        local_var_form_params.insert("Config.NotificationToken", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_sdk_version {
        local_var_form_params.insert("Config.SdkVersion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_skew {
        local_var_form_params.insert("Config.Skew", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = config_time_step {
        local_var_form_params.insert("Config.TimeStep", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateFactorSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateFactorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific MessagingConfiguration
pub async fn update_messaging_configuration(configuration: &configuration::Configuration, params: UpdateMessagingConfigurationParams) -> Result<ResponseContent<UpdateMessagingConfigurationSuccess>, Error<UpdateMessagingConfigurationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let country = params.country;
    let messaging_service_sid = params.messaging_service_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Country=crate::apis::urlencode(country));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("MessagingServiceSid", messaging_service_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateMessagingConfigurationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateMessagingConfigurationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Rate Limit.
pub async fn update_rate_limit(configuration: &configuration::Configuration, params: UpdateRateLimitParams) -> Result<ResponseContent<UpdateRateLimitSuccess>, Error<UpdateRateLimitError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let description = params.description;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/RateLimits/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = description {
        local_var_form_params.insert("Description", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRateLimitSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRateLimitError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a specific Verification Service.
pub async fn update_service(configuration: &configuration::Configuration, params: UpdateServiceParams) -> Result<ResponseContent<UpdateServiceSuccess>, Error<UpdateServiceError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let code_length = params.code_length;
    let custom_code_enabled = params.custom_code_enabled;
    let do_not_share_warning_enabled = params.do_not_share_warning_enabled;
    let dtmf_input_required = params.dtmf_input_required;
    let friendly_name = params.friendly_name;
    let lookup_enabled = params.lookup_enabled;
    let psd2_enabled = params.psd2_enabled;
    let push_apn_credential_sid = params.push_apn_credential_sid;
    let push_fcm_credential_sid = params.push_fcm_credential_sid;
    let push_include_date = params.push_include_date;
    let skip_sms_to_landlines = params.skip_sms_to_landlines;
    let totp_code_length = params.totp_code_length;
    let totp_issuer = params.totp_issuer;
    let totp_skew = params.totp_skew;
    let totp_time_step = params.totp_time_step;
    let tts_name = params.tts_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = code_length {
        local_var_form_params.insert("CodeLength", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = custom_code_enabled {
        local_var_form_params.insert("CustomCodeEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = do_not_share_warning_enabled {
        local_var_form_params.insert("DoNotShareWarningEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = dtmf_input_required {
        local_var_form_params.insert("DtmfInputRequired", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = lookup_enabled {
        local_var_form_params.insert("LookupEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = psd2_enabled {
        local_var_form_params.insert("Psd2Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = push_apn_credential_sid {
        local_var_form_params.insert("Push.ApnCredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = push_fcm_credential_sid {
        local_var_form_params.insert("Push.FcmCredentialSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = push_include_date {
        local_var_form_params.insert("Push.IncludeDate", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = skip_sms_to_landlines {
        local_var_form_params.insert("SkipSmsToLandlines", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = totp_code_length {
        local_var_form_params.insert("Totp.CodeLength", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = totp_issuer {
        local_var_form_params.insert("Totp.Issuer", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = totp_skew {
        local_var_form_params.insert("Totp.Skew", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = totp_time_step {
        local_var_form_params.insert("Totp.TimeStep", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = tts_name {
        local_var_form_params.insert("TtsName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateServiceSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateServiceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a Verification status
pub async fn update_verification(configuration: &configuration::Configuration, params: UpdateVerificationParams) -> Result<ResponseContent<UpdateVerificationSuccess>, Error<UpdateVerificationError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let status = params.status;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Verifications/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateVerificationSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateVerificationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_webhook(configuration: &configuration::Configuration, params: UpdateWebhookParams) -> Result<ResponseContent<UpdateWebhookSuccess>, Error<UpdateWebhookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let service_sid = params.service_sid;
    let sid = params.sid;
    let event_types = params.event_types;
    let friendly_name = params.friendly_name;
    let status = params.status;
    let version = params.version;
    let webhook_url = params.webhook_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/Services/{ServiceSid}/Webhooks/{Sid}", local_var_configuration.base_path, ServiceSid=crate::apis::urlencode(service_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = event_types {
        local_var_form_params.insert("EventTypes", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = version {
        local_var_form_params.insert("Version", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = webhook_url {
        local_var_form_params.insert("WebhookUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateWebhookSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateWebhookError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

