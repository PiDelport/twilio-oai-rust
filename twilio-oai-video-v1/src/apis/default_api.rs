/*
 * Twilio - Video
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for passing parameters to the method [`create_composition`]
#[derive(Clone, Debug, Default)]
pub struct CreateCompositionParams {
    /// The SID of the Group Room with the media tracks to be used as composition sources.
    pub room_sid: String,
    /// An array of track names from the same group room to merge into the new composition. Can include zero or more track names. The new composition includes all audio sources specified in `audio_sources` except for those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which will match zero or more characters in a track name. For example, `student*` includes `student` as well as `studentTeam`. Please, be aware that either video_layout or audio_sources have to be provided to get a valid creation request
    pub audio_sources: Option<Vec<String>>,
    /// An array of track names to exclude. The new composition includes all audio sources specified in `audio_sources` except for those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which will match zero or more characters in a track name. For example, `student*` excludes `student` as well as `studentTeam`. This parameter can also be empty.
    pub audio_sources_excluded: Option<Vec<String>>,
    /// The container format of the composition's media files. Can be: `mp4` or `webm` and the default is `webm`. If you specify `mp4` or `webm`, you must also specify one or more `audio_sources` and/or a `video_layout` element that contains a valid `video_sources` list, otherwise an error occurs.
    pub format: Option<String>,
    /// A string that describes the columns (width) and rows (height) of the generated composed video in pixels. Defaults to `640x480`.  The string's format is `{width}x{height}` where:   * 16 <= `{width}` <= 1280 * 16 <= `{height}` <= 1280 * `{width}` * `{height}` <= 921,600  Typical values are:   * HD = `1280x720` * PAL = `1024x576` * VGA = `640x480` * CIF = `320x240`  Note that the `resolution` imposes an aspect ratio to the resulting composition. When the original video tracks are constrained by the aspect ratio, they are scaled to fit. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
    pub resolution: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application on every composition event. If not provided, status callback events will not be dispatched.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
    pub status_callback_method: Option<String>,
    /// Whether to clip the intervals where there is no active media in the composition. The default is `true`. Compositions with `trim` enabled are shorter when the Room is created and no Participant joins for a while as well as if all the Participants leave the room and join later, because those gaps will be removed. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
    pub trim: Option<bool>,
    /// An object that describes the video layout of the composition in terms of regions. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info. Please, be aware that either video_layout or audio_sources have to be provided to get a valid creation request
    pub video_layout: Option<serde_json::Value>,
}

/// struct for passing parameters to the method [`create_composition_hook`]
#[derive(Clone, Debug, Default)]
pub struct CreateCompositionHookParams {
    /// A descriptive string that you create to describe the resource. It can be up to  100 characters long and it must be unique within the account.
    pub friendly_name: String,
    /// An array of track names from the same group room to merge into the compositions created by the composition hook. Can include zero or more track names. A composition triggered by the composition hook includes all audio sources specified in `audio_sources` except those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which matches zero or more characters in a track name. For example, `student*` includes tracks named `student` as well as `studentTeam`.
    pub audio_sources: Option<Vec<String>>,
    /// An array of track names to exclude. A composition triggered by the composition hook includes all audio sources specified in `audio_sources` except for those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which matches zero or more characters in a track name. For example, `student*` excludes `student` as well as `studentTeam`. This parameter can also be empty.
    pub audio_sources_excluded: Option<Vec<String>>,
    /// Whether the composition hook is active. When `true`, the composition hook will be triggered for every completed Group Room in the account. When `false`, the composition hook will never be triggered.
    pub enabled: Option<bool>,
    /// The container format of the media files used by the compositions created by the composition hook. Can be: `mp4` or `webm` and the default is `webm`. If `mp4` or `webm`, `audio_sources` must have one or more tracks and/or a `video_layout` element must contain a valid `video_sources` list, otherwise an error occurs.
    pub format: Option<String>,
    /// A string that describes the columns (width) and rows (height) of the generated composed video in pixels. Defaults to `640x480`.  The string's format is `{width}x{height}` where:   * 16 <= `{width}` <= 1280 * 16 <= `{height}` <= 1280 * `{width}` * `{height}` <= 921,600  Typical values are:   * HD = `1280x720` * PAL = `1024x576` * VGA = `640x480` * CIF = `320x240`  Note that the `resolution` imposes an aspect ratio to the resulting composition. When the original video tracks are constrained by the aspect ratio, they are scaled to fit. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
    pub resolution: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application on every composition event. If not provided, status callback events will not be dispatched.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
    pub status_callback_method: Option<String>,
    /// Whether to clip the intervals where there is no active media in the Compositions triggered by the composition hook. The default is `true`. Compositions with `trim` enabled are shorter when the Room is created and no Participant joins for a while as well as if all the Participants leave the room and join later, because those gaps will be removed. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
    pub trim: Option<bool>,
    /// An object that describes the video layout of the composition hook in terms of regions. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
    pub video_layout: Option<serde_json::Value>,
}

/// struct for passing parameters to the method [`create_composition_settings`]
#[derive(Clone, Debug, Default)]
pub struct CreateCompositionSettingsParams {
    /// A descriptive string that you create to describe the resource and show to the user in the console
    pub friendly_name: String,
    /// The SID of the stored Credential resource.
    pub aws_credentials_sid: Option<String>,
    /// The URL of the AWS S3 bucket where the compositions should be stored. We only support DNS-compliant URLs like `https://documentation-example-twilio-bucket/compositions`, where `compositions` is the path in which you want the compositions to be stored. This URL accepts only URI-valid characters, as described in the <a href='https://tools.ietf.org/html/rfc3986#section-2'>RFC 3986</a>.
    pub aws_s3_url: Option<String>,
    /// Whether all compositions should be written to the `aws_s3_url`. When `false`, all compositions are stored in our cloud.
    pub aws_storage_enabled: Option<bool>,
    /// Whether all compositions should be stored in an encrypted form. The default is `false`.
    pub encryption_enabled: Option<bool>,
    /// The SID of the Public Key resource to use for encryption.
    pub encryption_key_sid: Option<String>,
}

/// struct for passing parameters to the method [`create_recording_settings`]
#[derive(Clone, Debug, Default)]
pub struct CreateRecordingSettingsParams {
    /// A descriptive string that you create to describe the resource and be shown to users in the console
    pub friendly_name: String,
    /// The SID of the stored Credential resource.
    pub aws_credentials_sid: Option<String>,
    /// The URL of the AWS S3 bucket where the recordings should be stored. We only support DNS-compliant URLs like `https://documentation-example-twilio-bucket/recordings`, where `recordings` is the path in which you want the recordings to be stored. This URL accepts only URI-valid characters, as described in the <a href='https://tools.ietf.org/html/rfc3986#section-2'>RFC 3986</a>.
    pub aws_s3_url: Option<String>,
    /// Whether all recordings should be written to the `aws_s3_url`. When `false`, all recordings are stored in our cloud.
    pub aws_storage_enabled: Option<bool>,
    /// Whether all recordings should be stored in an encrypted form. The default is `false`.
    pub encryption_enabled: Option<bool>,
    /// The SID of the Public Key resource to use for encryption.
    pub encryption_key_sid: Option<String>,
}

/// struct for passing parameters to the method [`create_room`]
#[derive(Clone, Debug, Default)]
pub struct CreateRoomParams {
    /// Deprecated, now always considered to be true.
    pub enable_turn: Option<bool>,
    /// The maximum number of concurrent Participants allowed in the room. Peer-to-peer rooms can have up to 10 Participants. Small Group rooms can have up to 4 Participants. Group rooms can have up to 50 Participants.
    pub max_participants: Option<i32>,
    /// The region for the media server in Group Rooms.  Can be: one of the [available Media Regions](https://www.twilio.com/docs/video/ip-address-whitelisting#group-rooms-media-servers). ***This feature is not available in `peer-to-peer` rooms.***
    pub media_region: Option<String>,
    /// Whether to start recording when Participants connect. ***This feature is not available in `peer-to-peer` rooms.***
    pub record_participants_on_connect: Option<bool>,
    /// A collection of Recording Rules that describe how to include or exclude matching tracks for recording
    pub recording_rules: Option<serde_json::Value>,
    /// The URL we should call using the `status_callback_method` to send status information to your application on every room event. See [Status Callbacks](https://www.twilio.com/docs/video/api/status-callbacks) for more info.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be `POST` or `GET`.
    pub status_callback_method: Option<String>,
    /// The type of room. Can be: `go`, `peer-to-peer`, `group-small`, or `group`. The default value is `group`.
    pub _type: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used as a `room_sid` in place of the resource's `sid` in the URL to address the resource. This value is unique for `in-progress` rooms. SDK clients can use this name to connect to the room. REST API clients can use this name in place of the Room SID to interact with the room as long as the room is `in-progress`.
    pub unique_name: Option<String>,
    /// An array of the video codecs that are supported when publishing a track in the room.  Can be: `VP8` and `H264`.  ***This feature is not available in `peer-to-peer` rooms***
    pub video_codecs: Option<Vec<String>>,
}

/// struct for passing parameters to the method [`delete_composition`]
#[derive(Clone, Debug, Default)]
pub struct DeleteCompositionParams {
    /// The SID of the Composition resource to delete.
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_composition_hook`]
#[derive(Clone, Debug, Default)]
pub struct DeleteCompositionHookParams {
    /// The SID of the CompositionHook resource to delete.
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_recording`]
#[derive(Clone, Debug, Default)]
pub struct DeleteRecordingParams {
    /// The SID of the Recording resource to delete.
    pub sid: String,
}

/// struct for passing parameters to the method [`delete_room_recording`]
#[derive(Clone, Debug, Default)]
pub struct DeleteRoomRecordingParams {
    /// The SID of the room with the RoomRecording resource to delete.
    pub room_sid: String,
    /// The SID of the RoomRecording resource to delete.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_composition`]
#[derive(Clone, Debug, Default)]
pub struct FetchCompositionParams {
    /// The SID of the Composition resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_composition_hook`]
#[derive(Clone, Debug, Default)]
pub struct FetchCompositionHookParams {
    /// The SID of the CompositionHook resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_recording`]
#[derive(Clone, Debug, Default)]
pub struct FetchRecordingParams {
    /// The SID of the Recording resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_room`]
#[derive(Clone, Debug, Default)]
pub struct FetchRoomParams {
    /// The SID of the Room resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_room_participant`]
#[derive(Clone, Debug, Default)]
pub struct FetchRoomParticipantParams {
    /// The SID of the room with the Participant resource to fetch.
    pub room_sid: String,
    /// The SID of the RoomParticipant resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_room_participant_published_track`]
#[derive(Clone, Debug, Default)]
pub struct FetchRoomParticipantPublishedTrackParams {
    /// The SID of the Room resource where the Track resource to fetch is published.
    pub room_sid: String,
    /// The SID of the Participant resource with the published track to fetch.
    pub participant_sid: String,
    /// The SID of the RoomParticipantPublishedTrack resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_room_participant_subscribe_rule`]
#[derive(Clone, Debug, Default)]
pub struct FetchRoomParticipantSubscribeRuleParams {
    /// The SID of the Room resource where the subscribe rules to fetch apply.
    pub room_sid: String,
    /// The SID of the Participant resource with the subscribe rules to fetch.
    pub participant_sid: String,
}

/// struct for passing parameters to the method [`fetch_room_participant_subscribed_track`]
#[derive(Clone, Debug, Default)]
pub struct FetchRoomParticipantSubscribedTrackParams {
    /// The SID of the Room where the Track resource to fetch is subscribed.
    pub room_sid: String,
    /// The SID of the participant that subscribes to the Track resource to fetch.
    pub participant_sid: String,
    /// The SID of the RoomParticipantSubscribedTrack resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_room_recording`]
#[derive(Clone, Debug, Default)]
pub struct FetchRoomRecordingParams {
    /// The SID of the Room resource with the recording to fetch.
    pub room_sid: String,
    /// The SID of the RoomRecording resource to fetch.
    pub sid: String,
}

/// struct for passing parameters to the method [`fetch_room_recording_rule`]
#[derive(Clone, Debug, Default)]
pub struct FetchRoomRecordingRuleParams {
    /// The SID of the Room resource where the recording rules to fetch apply.
    pub room_sid: String,
}

/// struct for passing parameters to the method [`list_composition`]
#[derive(Clone, Debug, Default)]
pub struct ListCompositionParams {
    /// Read only Composition resources with this status. Can be: `enqueued`, `processing`, `completed`, `deleted`, or `failed`.
    pub status: Option<String>,
    /// Read only Composition resources created on or after this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time with time zone.
    pub date_created_after: Option<String>,
    /// Read only Composition resources created before this ISO 8601 date-time with time zone.
    pub date_created_before: Option<String>,
    /// Read only Composition resources with this Room SID.
    pub room_sid: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_composition_hook`]
#[derive(Clone, Debug, Default)]
pub struct ListCompositionHookParams {
    /// Read only CompositionHook resources with an `enabled` value that matches this parameter.
    pub enabled: Option<bool>,
    /// Read only CompositionHook resources created on or after this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime with time zone.
    pub date_created_after: Option<String>,
    /// Read only CompositionHook resources created before this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime with time zone.
    pub date_created_before: Option<String>,
    /// Read only CompositionHook resources with friendly names that match this string. The match is not case sensitive and can include asterisk `*` characters as wildcard match.
    pub friendly_name: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_recording`]
#[derive(Clone, Debug, Default)]
pub struct ListRecordingParams {
    /// Read only the recordings that have this status. Can be: `processing`, `completed`, or `deleted`.
    pub status: Option<String>,
    /// Read only the recordings that have this `source_sid`.
    pub source_sid: Option<String>,
    /// Read only recordings with this `grouping_sid`, which may include a `participant_sid` and/or a `room_sid`.
    pub grouping_sid: Option<Vec<String>>,
    /// Read only recordings that started on or after this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time with time zone.
    pub date_created_after: Option<String>,
    /// Read only recordings that started before this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time with time zone, given as `YYYY-MM-DDThh:mm:ss+|-hh:mm` or `YYYY-MM-DDThh:mm:ssZ`.
    pub date_created_before: Option<String>,
    /// Read only recordings that have this media type. Can be either `audio` or `video`.
    pub media_type: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_room`]
#[derive(Clone, Debug, Default)]
pub struct ListRoomParams {
    /// Read only the rooms with this status. Can be: `in-progress` (default) or `completed`
    pub status: Option<String>,
    /// Read only rooms with the this `unique_name`.
    pub unique_name: Option<String>,
    /// Read only rooms that started on or after this date, given as `YYYY-MM-DD`.
    pub date_created_after: Option<String>,
    /// Read only rooms that started before this date, given as `YYYY-MM-DD`.
    pub date_created_before: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_room_participant`]
#[derive(Clone, Debug, Default)]
pub struct ListRoomParticipantParams {
    /// The SID of the room with the Participant resources to read.
    pub room_sid: String,
    /// Read only the participants with this status. Can be: `connected` or `disconnected`. For `in-progress` Rooms the default Status is `connected`, for `completed` Rooms only `disconnected` Participants are returned.
    pub status: Option<String>,
    /// Read only the Participants with this [User](https://www.twilio.com/docs/chat/rest/user-resource) `identity` value.
    pub identity: Option<String>,
    /// Read only Participants that started after this date in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#UTC) format.
    pub date_created_after: Option<String>,
    /// Read only Participants that started before this date in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#UTC) format.
    pub date_created_before: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_room_participant_published_track`]
#[derive(Clone, Debug, Default)]
pub struct ListRoomParticipantPublishedTrackParams {
    /// The SID of the Room resource where the Track resources to read are published.
    pub room_sid: String,
    /// The SID of the Participant resource with the published tracks to read.
    pub participant_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_room_participant_subscribed_track`]
#[derive(Clone, Debug, Default)]
pub struct ListRoomParticipantSubscribedTrackParams {
    /// The SID of the Room resource with the Track resources to read.
    pub room_sid: String,
    /// The SID of the participant that subscribes to the Track resources to read.
    pub participant_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`list_room_recording`]
#[derive(Clone, Debug, Default)]
pub struct ListRoomRecordingParams {
    /// The SID of the room with the RoomRecording resources to read.
    pub room_sid: String,
    /// Read only the recordings with this status. Can be: `processing`, `completed`, or `deleted`.
    pub status: Option<String>,
    /// Read only the recordings that have this `source_sid`.
    pub source_sid: Option<String>,
    /// Read only recordings that started on or after this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime with time zone.
    pub date_created_after: Option<String>,
    /// Read only Recordings that started before this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime with time zone.
    pub date_created_before: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
}

/// struct for passing parameters to the method [`update_composition_hook`]
#[derive(Clone, Debug, Default)]
pub struct UpdateCompositionHookParams {
    /// The SID of the CompositionHook resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the resource. It can be up to  100 characters long and it must be unique within the account.
    pub friendly_name: String,
    /// An array of track names from the same group room to merge into the compositions created by the composition hook. Can include zero or more track names. A composition triggered by the composition hook includes all audio sources specified in `audio_sources` except those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which matches zero or more characters in a track name. For example, `student*` includes tracks named `student` as well as `studentTeam`.
    pub audio_sources: Option<Vec<String>>,
    /// An array of track names to exclude. A composition triggered by the composition hook includes all audio sources specified in `audio_sources` except for those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which matches zero or more characters in a track name. For example, `student*` excludes `student` as well as `studentTeam`. This parameter can also be empty.
    pub audio_sources_excluded: Option<Vec<String>>,
    /// Whether the composition hook is active. When `true`, the composition hook will be triggered for every completed Group Room in the account. When `false`, the composition hook never triggers.
    pub enabled: Option<bool>,
    /// The container format of the media files used by the compositions created by the composition hook. Can be: `mp4` or `webm` and the default is `webm`. If `mp4` or `webm`, `audio_sources` must have one or more tracks and/or a `video_layout` element must contain a valid `video_sources` list, otherwise an error occurs.
    pub format: Option<String>,
    /// A string that describes the columns (width) and rows (height) of the generated composed video in pixels. Defaults to `640x480`.  The string's format is `{width}x{height}` where:   * 16 <= `{width}` <= 1280 * 16 <= `{height}` <= 1280 * `{width}` * `{height}` <= 921,600  Typical values are:   * HD = `1280x720` * PAL = `1024x576` * VGA = `640x480` * CIF = `320x240`  Note that the `resolution` imposes an aspect ratio to the resulting composition. When the original video tracks are constrained by the aspect ratio, they are scaled to fit. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
    pub resolution: Option<String>,
    /// The URL we should call using the `status_callback_method` to send status information to your application on every composition event. If not provided, status callback events will not be dispatched.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
    pub status_callback_method: Option<String>,
    /// Whether to clip the intervals where there is no active media in the compositions triggered by the composition hook. The default is `true`. Compositions with `trim` enabled are shorter when the Room is created and no Participant joins for a while as well as if all the Participants leave the room and join later, because those gaps will be removed. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
    pub trim: Option<bool>,
    /// A JSON object that describes the video layout of the composition hook in terms of regions. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
    pub video_layout: Option<serde_json::Value>,
}

/// struct for passing parameters to the method [`update_room`]
#[derive(Clone, Debug, Default)]
pub struct UpdateRoomParams {
    /// The SID of the Room resource to update.
    pub sid: String,
    /// The new status of the resource. Set to `completed` to end the room.
    pub status: String,
}

/// struct for passing parameters to the method [`update_room_participant`]
#[derive(Clone, Debug, Default)]
pub struct UpdateRoomParticipantParams {
    /// The SID of the room with the participant to update.
    pub room_sid: String,
    /// The SID of the RoomParticipant resource to update.
    pub sid: String,
    /// The new status of the resource. Can be: `connected` or `disconnected`. For `in-progress` Rooms the default Status is `connected`, for `completed` Rooms only `disconnected` Participants are returned.
    pub status: Option<String>,
}

/// struct for passing parameters to the method [`update_room_participant_subscribe_rule`]
#[derive(Clone, Debug, Default)]
pub struct UpdateRoomParticipantSubscribeRuleParams {
    /// The SID of the Room resource where the subscribe rules to update apply.
    pub room_sid: String,
    /// The SID of the Participant resource to update the Subscribe Rules.
    pub participant_sid: String,
    /// A JSON-encoded array of subscribe rules. See the [Specifying Subscribe Rules](https://www.twilio.com/docs/video/api/track-subscriptions#specifying-sr) section for further information.
    pub rules: Option<serde_json::Value>,
}

/// struct for passing parameters to the method [`update_room_recording_rule`]
#[derive(Clone, Debug, Default)]
pub struct UpdateRoomRecordingRuleParams {
    /// The SID of the Room resource where the recording rules to update apply.
    pub room_sid: String,
    /// A JSON-encoded array of recording rules.
    pub rules: Option<serde_json::Value>,
}

/// struct for typed successes of method [`create_composition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCompositionSuccess {
    Status201(crate::models::VideoV1Composition),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_composition_hook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCompositionHookSuccess {
    Status201(crate::models::VideoV1CompositionHook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_composition_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCompositionSettingsSuccess {
    Status201(crate::models::VideoV1CompositionSettings),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_recording_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRecordingSettingsSuccess {
    Status201(crate::models::VideoV1RecordingSettings),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_room`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoomSuccess {
    Status201(crate::models::VideoV1Room),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_composition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCompositionSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_composition_hook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCompositionHookSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_room_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoomRecordingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_composition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCompositionSuccess {
    Status200(crate::models::VideoV1Composition),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_composition_hook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCompositionHookSuccess {
    Status200(crate::models::VideoV1CompositionHook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_composition_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCompositionSettingsSuccess {
    Status200(crate::models::VideoV1CompositionSettings),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingSuccess {
    Status200(crate::models::VideoV1Recording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_recording_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingSettingsSuccess {
    Status200(crate::models::VideoV1RecordingSettings),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_room`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomSuccess {
    Status200(crate::models::VideoV1Room),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_room_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomParticipantSuccess {
    Status200(crate::models::VideoV1RoomRoomParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_room_participant_published_track`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomParticipantPublishedTrackSuccess {
    Status200(crate::models::VideoV1RoomRoomParticipantRoomParticipantPublishedTrack),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_room_participant_subscribe_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomParticipantSubscribeRuleSuccess {
    Status200(crate::models::VideoV1RoomRoomParticipantRoomParticipantSubscribeRule),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_room_participant_subscribed_track`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomParticipantSubscribedTrackSuccess {
    Status200(crate::models::VideoV1RoomRoomParticipantRoomParticipantSubscribedTrack),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_room_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomRecordingSuccess {
    Status200(crate::models::VideoV1RoomRoomRecording),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`fetch_room_recording_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomRecordingRuleSuccess {
    Status200(crate::models::VideoV1RoomRoomRecordingRule),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_composition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCompositionSuccess {
    Status200(crate::models::ListCompositionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_composition_hook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCompositionHookSuccess {
    Status200(crate::models::ListCompositionHookResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingSuccess {
    Status200(crate::models::ListRecordingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_room`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoomSuccess {
    Status200(crate::models::ListRoomResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_room_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoomParticipantSuccess {
    Status200(crate::models::ListRoomParticipantResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_room_participant_published_track`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoomParticipantPublishedTrackSuccess {
    Status200(crate::models::ListRoomParticipantPublishedTrackResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_room_participant_subscribed_track`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoomParticipantSubscribedTrackSuccess {
    Status200(crate::models::ListRoomParticipantSubscribedTrackResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_room_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoomRecordingSuccess {
    Status200(crate::models::ListRoomRecordingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_composition_hook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCompositionHookSuccess {
    Status200(crate::models::VideoV1CompositionHook),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_room`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoomSuccess {
    Status200(crate::models::VideoV1Room),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_room_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoomParticipantSuccess {
    Status200(crate::models::VideoV1RoomRoomParticipant),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_room_participant_subscribe_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoomParticipantSubscribeRuleSuccess {
    Status202(crate::models::VideoV1RoomRoomParticipantRoomParticipantSubscribeRule),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_room_recording_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoomRecordingRuleSuccess {
    Status202(crate::models::VideoV1RoomRoomRecordingRule),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_composition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCompositionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_composition_hook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCompositionHookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_composition_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCompositionSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_recording_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRecordingSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_room`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRoomError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_composition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCompositionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_composition_hook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCompositionHookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_room_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRoomRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_composition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCompositionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_composition_hook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCompositionHookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_composition_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCompositionSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_recording_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRecordingSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_room`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_room_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_room_participant_published_track`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomParticipantPublishedTrackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_room_participant_subscribe_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomParticipantSubscribeRuleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_room_participant_subscribed_track`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomParticipantSubscribedTrackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_room_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_room_recording_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRoomRecordingRuleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_composition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCompositionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_composition_hook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCompositionHookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_room`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoomError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_room_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoomParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_room_participant_published_track`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoomParticipantPublishedTrackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_room_participant_subscribed_track`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoomParticipantSubscribedTrackError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_room_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRoomRecordingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_composition_hook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCompositionHookError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_room`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoomError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_room_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoomParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_room_participant_subscribe_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoomParticipantSubscribeRuleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_room_recording_rule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoomRecordingRuleError {
    UnknownValue(serde_json::Value),
}

pub async fn create_composition(
    configuration: &configuration::Configuration,
    params: CreateCompositionParams,
) -> Result<ResponseContent<CreateCompositionSuccess>, Error<CreateCompositionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let audio_sources = params.audio_sources;
    let audio_sources_excluded = params.audio_sources_excluded;
    let format = params.format;
    let resolution = params.resolution;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let trim = params.trim;
    let video_layout = params.video_layout;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Compositions", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = audio_sources {
        local_var_form_params.insert(
            "AudioSources",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = audio_sources_excluded {
        local_var_form_params.insert(
            "AudioSourcesExcluded",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = format {
        local_var_form_params.insert("Format", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = resolution {
        local_var_form_params.insert("Resolution", local_var_param_value.to_string());
    }
    local_var_form_params.insert("RoomSid", room_sid.to_string());
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trim {
        local_var_form_params.insert("Trim", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = video_layout {
        local_var_form_params.insert("VideoLayout", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCompositionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCompositionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_composition_hook(
    configuration: &configuration::Configuration,
    params: CreateCompositionHookParams,
) -> Result<ResponseContent<CreateCompositionHookSuccess>, Error<CreateCompositionHookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let audio_sources = params.audio_sources;
    let audio_sources_excluded = params.audio_sources_excluded;
    let enabled = params.enabled;
    let format = params.format;
    let resolution = params.resolution;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let trim = params.trim;
    let video_layout = params.video_layout;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/CompositionHooks", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = audio_sources {
        local_var_form_params.insert(
            "AudioSources",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = audio_sources_excluded {
        local_var_form_params.insert(
            "AudioSourcesExcluded",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = enabled {
        local_var_form_params.insert("Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = format {
        local_var_form_params.insert("Format", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = resolution {
        local_var_form_params.insert("Resolution", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trim {
        local_var_form_params.insert("Trim", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = video_layout {
        local_var_form_params.insert("VideoLayout", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCompositionHookSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCompositionHookError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_composition_settings(
    configuration: &configuration::Configuration,
    params: CreateCompositionSettingsParams,
) -> Result<ResponseContent<CreateCompositionSettingsSuccess>, Error<CreateCompositionSettingsError>>
{
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let aws_credentials_sid = params.aws_credentials_sid;
    let aws_s3_url = params.aws_s3_url;
    let aws_storage_enabled = params.aws_storage_enabled;
    let encryption_enabled = params.encryption_enabled;
    let encryption_key_sid = params.encryption_key_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/CompositionSettings/Default",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = aws_credentials_sid {
        local_var_form_params.insert("AwsCredentialsSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = aws_s3_url {
        local_var_form_params.insert("AwsS3Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = aws_storage_enabled {
        local_var_form_params.insert("AwsStorageEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = encryption_enabled {
        local_var_form_params.insert("EncryptionEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = encryption_key_sid {
        local_var_form_params.insert("EncryptionKeySid", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCompositionSettingsSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCompositionSettingsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_recording_settings(
    configuration: &configuration::Configuration,
    params: CreateRecordingSettingsParams,
) -> Result<ResponseContent<CreateRecordingSettingsSuccess>, Error<CreateRecordingSettingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;
    let aws_credentials_sid = params.aws_credentials_sid;
    let aws_s3_url = params.aws_s3_url;
    let aws_storage_enabled = params.aws_storage_enabled;
    let encryption_enabled = params.encryption_enabled;
    let encryption_key_sid = params.encryption_key_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/RecordingSettings/Default",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = aws_credentials_sid {
        local_var_form_params.insert("AwsCredentialsSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = aws_s3_url {
        local_var_form_params.insert("AwsS3Url", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = aws_storage_enabled {
        local_var_form_params.insert("AwsStorageEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = encryption_enabled {
        local_var_form_params.insert("EncryptionEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = encryption_key_sid {
        local_var_form_params.insert("EncryptionKeySid", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRecordingSettingsSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRecordingSettingsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_room(
    configuration: &configuration::Configuration,
    params: CreateRoomParams,
) -> Result<ResponseContent<CreateRoomSuccess>, Error<CreateRoomError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let enable_turn = params.enable_turn;
    let max_participants = params.max_participants;
    let media_region = params.media_region;
    let record_participants_on_connect = params.record_participants_on_connect;
    let recording_rules = params.recording_rules;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let _type = params._type;
    let unique_name = params.unique_name;
    let video_codecs = params.video_codecs;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Rooms", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = enable_turn {
        local_var_form_params.insert("EnableTurn", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = max_participants {
        local_var_form_params.insert("MaxParticipants", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = media_region {
        local_var_form_params.insert("MediaRegion", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = record_participants_on_connect {
        local_var_form_params.insert(
            "RecordParticipantsOnConnect",
            local_var_param_value.to_string(),
        );
    }
    if let Some(local_var_param_value) = recording_rules {
        local_var_form_params.insert("RecordingRules", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = _type {
        local_var_form_params.insert("Type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = video_codecs {
        local_var_form_params.insert(
            "VideoCodecs",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRoomSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRoomError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a Recording Composition resource identified by a Composition SID.
pub async fn delete_composition(
    configuration: &configuration::Configuration,
    params: DeleteCompositionParams,
) -> Result<ResponseContent<DeleteCompositionSuccess>, Error<DeleteCompositionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Compositions/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCompositionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCompositionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a Recording CompositionHook resource identified by a `CompositionHook SID`.
pub async fn delete_composition_hook(
    configuration: &configuration::Configuration,
    params: DeleteCompositionHookParams,
) -> Result<ResponseContent<DeleteCompositionHookSuccess>, Error<DeleteCompositionHookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/CompositionHooks/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCompositionHookSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCompositionHookError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a Recording resource identified by a Recording SID.
pub async fn delete_recording(
    configuration: &configuration::Configuration,
    params: DeleteRecordingParams,
) -> Result<ResponseContent<DeleteRecordingSuccess>, Error<DeleteRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Recordings/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRecordingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRecordingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_room_recording(
    configuration: &configuration::Configuration,
    params: DeleteRoomRecordingParams,
) -> Result<ResponseContent<DeleteRoomRecordingSuccess>, Error<DeleteRoomRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Recordings/{Sid}",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRoomRecordingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRoomRecordingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single Composition resource identified by a Composition SID.
pub async fn fetch_composition(
    configuration: &configuration::Configuration,
    params: FetchCompositionParams,
) -> Result<ResponseContent<FetchCompositionSuccess>, Error<FetchCompositionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Compositions/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCompositionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCompositionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single CompositionHook resource identified by a CompositionHook SID.
pub async fn fetch_composition_hook(
    configuration: &configuration::Configuration,
    params: FetchCompositionHookParams,
) -> Result<ResponseContent<FetchCompositionHookSuccess>, Error<FetchCompositionHookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/CompositionHooks/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCompositionHookSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCompositionHookError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_composition_settings(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<FetchCompositionSettingsSuccess>, Error<FetchCompositionSettingsError>>
{
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/CompositionSettings/Default",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCompositionSettingsSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCompositionSettingsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single Recording resource identified by a Recording SID.
pub async fn fetch_recording(
    configuration: &configuration::Configuration,
    params: FetchRecordingParams,
) -> Result<ResponseContent<FetchRecordingSuccess>, Error<FetchRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Recordings/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRecordingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRecordingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_recording_settings(
    configuration: &configuration::Configuration,
) -> Result<ResponseContent<FetchRecordingSettingsSuccess>, Error<FetchRecordingSettingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/RecordingSettings/Default",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRecordingSettingsSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRecordingSettingsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_room(
    configuration: &configuration::Configuration,
    params: FetchRoomParams,
) -> Result<ResponseContent<FetchRoomSuccess>, Error<FetchRoomError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoomSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoomError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_room_participant(
    configuration: &configuration::Configuration,
    params: FetchRoomParticipantParams,
) -> Result<ResponseContent<FetchRoomParticipantSuccess>, Error<FetchRoomParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Participants/{Sid}",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoomParticipantSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoomParticipantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single Track resource represented by TrackName or SID.
pub async fn fetch_room_participant_published_track(
    configuration: &configuration::Configuration,
    params: FetchRoomParticipantPublishedTrackParams,
) -> Result<
    ResponseContent<FetchRoomParticipantPublishedTrackSuccess>,
    Error<FetchRoomParticipantPublishedTrackError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let participant_sid = params.participant_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/PublishedTracks/{Sid}",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid),
        ParticipantSid = crate::apis::urlencode(participant_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoomParticipantPublishedTrackSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoomParticipantPublishedTrackError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of Subscribe Rules for the Participant.
pub async fn fetch_room_participant_subscribe_rule(
    configuration: &configuration::Configuration,
    params: FetchRoomParticipantSubscribeRuleParams,
) -> Result<
    ResponseContent<FetchRoomParticipantSubscribeRuleSuccess>,
    Error<FetchRoomParticipantSubscribeRuleError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let participant_sid = params.participant_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribeRules",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid),
        ParticipantSid = crate::apis::urlencode(participant_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoomParticipantSubscribeRuleSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoomParticipantSubscribeRuleError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a single Track resource represented by `track_sid`.  Note: This is one resource with the Video API that requires a SID, be Track Name on the subscriber side is not guaranteed to be unique.
pub async fn fetch_room_participant_subscribed_track(
    configuration: &configuration::Configuration,
    params: FetchRoomParticipantSubscribedTrackParams,
) -> Result<
    ResponseContent<FetchRoomParticipantSubscribedTrackSuccess>,
    Error<FetchRoomParticipantSubscribedTrackError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let participant_sid = params.participant_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribedTracks/{Sid}",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid),
        ParticipantSid = crate::apis::urlencode(participant_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoomParticipantSubscribedTrackSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoomParticipantSubscribedTrackError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_room_recording(
    configuration: &configuration::Configuration,
    params: FetchRoomRecordingParams,
) -> Result<ResponseContent<FetchRoomRecordingSuccess>, Error<FetchRoomRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let sid = params.sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Recordings/{Sid}",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoomRecordingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoomRecordingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of Recording Rules for the Room.
pub async fn fetch_room_recording_rule(
    configuration: &configuration::Configuration,
    params: FetchRoomRecordingRuleParams,
) -> Result<ResponseContent<FetchRoomRecordingRuleSuccess>, Error<FetchRoomRecordingRuleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/RecordingRules",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRoomRecordingRuleSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRoomRecordingRuleError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List of all Recording compositions.
pub async fn list_composition(
    configuration: &configuration::Configuration,
    params: ListCompositionParams,
) -> Result<ResponseContent<ListCompositionSuccess>, Error<ListCompositionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let status = params.status;
    let date_created_after = params.date_created_after;
    let date_created_before = params.date_created_before;
    let room_sid = params.room_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Compositions", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_after {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_before {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = room_sid {
        local_var_req_builder =
            local_var_req_builder.query(&[("RoomSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCompositionSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCompositionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List of all Recording CompositionHook resources.
pub async fn list_composition_hook(
    configuration: &configuration::Configuration,
    params: ListCompositionHookParams,
) -> Result<ResponseContent<ListCompositionHookSuccess>, Error<ListCompositionHookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let enabled = params.enabled;
    let date_created_after = params.date_created_after;
    let date_created_before = params.date_created_before;
    let friendly_name = params.friendly_name;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/CompositionHooks", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = enabled {
        local_var_req_builder =
            local_var_req_builder.query(&[("Enabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_after {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_before {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friendly_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("FriendlyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCompositionHookSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCompositionHookError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List of all Track recordings.
pub async fn list_recording(
    configuration: &configuration::Configuration,
    params: ListRecordingParams,
) -> Result<ResponseContent<ListRecordingSuccess>, Error<ListRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let status = params.status;
    let source_sid = params.source_sid;
    let grouping_sid = params.grouping_sid;
    let date_created_after = params.date_created_after;
    let date_created_before = params.date_created_before;
    let media_type = params.media_type;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Recordings", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source_sid {
        local_var_req_builder =
            local_var_req_builder.query(&[("SourceSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = grouping_sid {
        local_var_req_builder = local_var_req_builder.query(&[(
            "GroupingSid",
            &local_var_str
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]);
    }
    if let Some(ref local_var_str) = date_created_after {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_before {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = media_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("MediaType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRecordingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRecordingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_room(
    configuration: &configuration::Configuration,
    params: ListRoomParams,
) -> Result<ResponseContent<ListRoomSuccess>, Error<ListRoomError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let status = params.status;
    let unique_name = params.unique_name;
    let date_created_after = params.date_created_after;
    let date_created_before = params.date_created_before;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Rooms", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = unique_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("UniqueName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_after {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_before {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRoomSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRoomError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_room_participant(
    configuration: &configuration::Configuration,
    params: ListRoomParticipantParams,
) -> Result<ResponseContent<ListRoomParticipantSuccess>, Error<ListRoomParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let status = params.status;
    let identity = params.identity;
    let date_created_after = params.date_created_after;
    let date_created_before = params.date_created_before;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Participants",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = identity {
        local_var_req_builder =
            local_var_req_builder.query(&[("Identity", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_after {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_before {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRoomParticipantSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRoomParticipantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of tracks associated with a given Participant. Only `currently` Published Tracks are in the list resource.
pub async fn list_room_participant_published_track(
    configuration: &configuration::Configuration,
    params: ListRoomParticipantPublishedTrackParams,
) -> Result<
    ResponseContent<ListRoomParticipantPublishedTrackSuccess>,
    Error<ListRoomParticipantPublishedTrackError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let participant_sid = params.participant_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/PublishedTracks",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid),
        ParticipantSid = crate::apis::urlencode(participant_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRoomParticipantPublishedTrackSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRoomParticipantPublishedTrackError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of tracks that are subscribed for the participant.
pub async fn list_room_participant_subscribed_track(
    configuration: &configuration::Configuration,
    params: ListRoomParticipantSubscribedTrackParams,
) -> Result<
    ResponseContent<ListRoomParticipantSubscribedTrackSuccess>,
    Error<ListRoomParticipantSubscribedTrackError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let participant_sid = params.participant_sid;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribedTracks",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid),
        ParticipantSid = crate::apis::urlencode(participant_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRoomParticipantSubscribedTrackSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRoomParticipantSubscribedTrackError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_room_recording(
    configuration: &configuration::Configuration,
    params: ListRoomRecordingParams,
) -> Result<ResponseContent<ListRoomRecordingSuccess>, Error<ListRoomRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let status = params.status;
    let source_sid = params.source_sid;
    let date_created_after = params.date_created_after;
    let date_created_before = params.date_created_before;
    let page_size = params.page_size;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Recordings",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source_sid {
        local_var_req_builder =
            local_var_req_builder.query(&[("SourceSid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_after {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_created_before {
        local_var_req_builder =
            local_var_req_builder.query(&[("DateCreatedBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRoomRecordingSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRoomRecordingError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_composition_hook(
    configuration: &configuration::Configuration,
    params: UpdateCompositionHookParams,
) -> Result<ResponseContent<UpdateCompositionHookSuccess>, Error<UpdateCompositionHookError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let friendly_name = params.friendly_name;
    let audio_sources = params.audio_sources;
    let audio_sources_excluded = params.audio_sources_excluded;
    let enabled = params.enabled;
    let format = params.format;
    let resolution = params.resolution;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let trim = params.trim;
    let video_layout = params.video_layout;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/CompositionHooks/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = audio_sources {
        local_var_form_params.insert(
            "AudioSources",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = audio_sources_excluded {
        local_var_form_params.insert(
            "AudioSourcesExcluded",
            local_var_param_value
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        );
    }
    if let Some(local_var_param_value) = enabled {
        local_var_form_params.insert("Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = format {
        local_var_form_params.insert("Format", local_var_param_value.to_string());
    }
    local_var_form_params.insert("FriendlyName", friendly_name.to_string());
    if let Some(local_var_param_value) = resolution {
        local_var_form_params.insert("Resolution", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trim {
        local_var_form_params.insert("Trim", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = video_layout {
        local_var_form_params.insert("VideoLayout", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateCompositionHookSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateCompositionHookError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_room(
    configuration: &configuration::Configuration,
    params: UpdateRoomParams,
) -> Result<ResponseContent<UpdateRoomSuccess>, Error<UpdateRoomError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let status = params.status;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{Sid}",
        local_var_configuration.base_path,
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("Status", status.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRoomSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRoomError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_room_participant(
    configuration: &configuration::Configuration,
    params: UpdateRoomParticipantParams,
) -> Result<ResponseContent<UpdateRoomParticipantSuccess>, Error<UpdateRoomParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let sid = params.sid;
    let status = params.status;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Participants/{Sid}",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid),
        Sid = crate::apis::urlencode(sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRoomParticipantSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRoomParticipantError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the Subscribe Rules for the Participant
pub async fn update_room_participant_subscribe_rule(
    configuration: &configuration::Configuration,
    params: UpdateRoomParticipantSubscribeRuleParams,
) -> Result<
    ResponseContent<UpdateRoomParticipantSubscribeRuleSuccess>,
    Error<UpdateRoomParticipantSubscribeRuleError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let participant_sid = params.participant_sid;
    let rules = params.rules;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribeRules",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid),
        ParticipantSid = crate::apis::urlencode(participant_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = rules {
        local_var_form_params.insert("Rules", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRoomParticipantSubscribeRuleSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRoomParticipantSubscribeRuleError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the Recording Rules for the Room
pub async fn update_room_recording_rule(
    configuration: &configuration::Configuration,
    params: UpdateRoomRecordingRuleParams,
) -> Result<ResponseContent<UpdateRoomRecordingRuleSuccess>, Error<UpdateRoomRecordingRuleError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let room_sid = params.room_sid;
    let rules = params.rules;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/Rooms/{RoomSid}/RecordingRules",
        local_var_configuration.base_path,
        RoomSid = crate::apis::urlencode(room_sid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = rules {
        local_var_form_params.insert("Rules", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRoomRecordingRuleSuccess> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRoomRecordingRuleError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
