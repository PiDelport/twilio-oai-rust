/*
 * Twilio - Voice
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_byoc_trunk`
#[derive(Clone, Debug, Default)]
pub struct CreateByocTrunkParams {
    /// Whether Caller ID Name (CNAM) lookup is enabled for the trunk. If enabled, all inbound calls to the BYOC Trunk from the United States and Canada automatically perform a CNAM Lookup and display Caller ID data on your phone. See [CNAM Lookups](https://www.twilio.com/docs/sip-trunking#CNAM) for more information.
    pub cnam_lookup_enabled: Option<bool>,
    /// The SID of the Connection Policy that Twilio will use when routing traffic to your communications infrastructure.
    pub connection_policy_sid: Option<String>,
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>,
    /// The SID of the SIP Domain that should be used in the `From` header of originating calls sent to your SIP infrastructure. If your SIP infrastructure allows users to \\\"call back\\\" an incoming call, configure this with a [SIP Domain](https://www.twilio.com/docs/voice/api/sending-sip) to ensure proper routing. If not configured, the from domain will default to \\\"sip.twilio.com\\\".
    pub from_domain_sid: Option<String>,
    /// The HTTP method we should use to call `status_callback_url`. Can be: `GET` or `POST`.
    pub status_callback_method: Option<String>,
    /// The URL that we should call to pass status parameters (such as call ended) to your application.
    pub status_callback_url: Option<String>,
    /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while retrieving or executing the TwiML from `voice_url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method we should use to call `voice_url`. Can be: `GET` or `POST`.
    pub voice_method: Option<String>,
    /// The URL we should call when the BYOC Trunk receives a call.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `create_connection_policy`
#[derive(Clone, Debug, Default)]
pub struct CreateConnectionPolicyParams {
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `create_connection_policy_target`
#[derive(Clone, Debug, Default)]
pub struct CreateConnectionPolicyTargetParams {
    /// The SID of the Connection Policy that owns the Target.
    pub connection_policy_sid: String,
    /// The SIP address you want Twilio to route your calls to. This must be a `sip:` schema. `sips` is NOT supported.
    pub target: String,
    /// Whether the Target is enabled. The default is `true`.
    pub enabled: Option<bool>,
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>,
    /// The relative importance of the target. Can be an integer from 0 to 65535, inclusive, and the default is 10. The lowest number represents the most important target.
    pub priority: Option<i32>,
    /// The value that determines the relative share of the load the Target should receive compared to other Targets with the same priority. Can be an integer from 1 to 65535, inclusive, and the default is 10. Targets with higher values receive more load than those with lower ones with the same priority.
    pub weight: Option<i32>
}

/// struct for passing parameters to the method `create_dialing_permissions_country_bulk_update`
#[derive(Clone, Debug, Default)]
pub struct CreateDialingPermissionsCountryBulkUpdateParams {
    /// URL encoded JSON array of update objects. example : `[ { \\\"iso_code\\\": \\\"GB\\\", \\\"low_risk_numbers_enabled\\\": \\\"true\\\", \\\"high_risk_special_numbers_enabled\\\":\\\"true\\\", \\\"high_risk_tollfraud_numbers_enabled\\\": \\\"false\\\" } ]`
    pub update_request: String
}

/// struct for passing parameters to the method `create_ip_record`
#[derive(Clone, Debug, Default)]
pub struct CreateIpRecordParams {
    /// An IP address in dotted decimal notation, IPv4 only.
    pub ip_address: String,
    /// An integer representing the length of the [CIDR](https://tools.ietf.org/html/rfc4632) prefix to use with this IP address. By default the entire IP address is used, which for IPv4 is value 32.
    pub cidr_prefix_length: Option<i32>,
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `create_source_ip_mapping`
#[derive(Clone, Debug, Default)]
pub struct CreateSourceIpMappingParams {
    /// The Twilio-provided string that uniquely identifies the IP Record resource to map from.
    pub ip_record_sid: String,
    /// The SID of the SIP Domain that the IP Record should be mapped to.
    pub sip_domain_sid: String
}

/// struct for passing parameters to the method `delete_byoc_trunk`
#[derive(Clone, Debug, Default)]
pub struct DeleteByocTrunkParams {
    /// The Twilio-provided string that uniquely identifies the BYOC Trunk resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_connection_policy`
#[derive(Clone, Debug, Default)]
pub struct DeleteConnectionPolicyParams {
    /// The unique string that we created to identify the Connection Policy resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_connection_policy_target`
#[derive(Clone, Debug, Default)]
pub struct DeleteConnectionPolicyTargetParams {
    /// The SID of the Connection Policy that owns the Target.
    pub connection_policy_sid: String,
    /// The unique string that we created to identify the Target resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_ip_record`
#[derive(Clone, Debug, Default)]
pub struct DeleteIpRecordParams {
    /// The Twilio-provided string that uniquely identifies the IP Record resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_source_ip_mapping`
#[derive(Clone, Debug, Default)]
pub struct DeleteSourceIpMappingParams {
    /// The Twilio-provided string that uniquely identifies the IP Record resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_byoc_trunk`
#[derive(Clone, Debug, Default)]
pub struct FetchByocTrunkParams {
    /// The Twilio-provided string that uniquely identifies the BYOC Trunk resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_connection_policy`
#[derive(Clone, Debug, Default)]
pub struct FetchConnectionPolicyParams {
    /// The unique string that we created to identify the Connection Policy resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_connection_policy_target`
#[derive(Clone, Debug, Default)]
pub struct FetchConnectionPolicyTargetParams {
    /// The SID of the Connection Policy that owns the Target.
    pub connection_policy_sid: String,
    /// The unique string that we created to identify the Target resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_dialing_permissions_country`
#[derive(Clone, Debug, Default)]
pub struct FetchDialingPermissionsCountryParams {
    /// The [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the DialingPermissions Country resource to fetch
    pub iso_code: String
}

/// struct for passing parameters to the method `fetch_ip_record`
#[derive(Clone, Debug, Default)]
pub struct FetchIpRecordParams {
    /// The Twilio-provided string that uniquely identifies the IP Record resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_source_ip_mapping`
#[derive(Clone, Debug, Default)]
pub struct FetchSourceIpMappingParams {
    /// The Twilio-provided string that uniquely identifies the IP Record resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `list_byoc_trunk`
#[derive(Clone, Debug, Default)]
pub struct ListByocTrunkParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_connection_policy`
#[derive(Clone, Debug, Default)]
pub struct ListConnectionPolicyParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_connection_policy_target`
#[derive(Clone, Debug, Default)]
pub struct ListConnectionPolicyTargetParams {
    /// The SID of the Connection Policy from which to read the Targets.
    pub connection_policy_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_dialing_permissions_country`
#[derive(Clone, Debug, Default)]
pub struct ListDialingPermissionsCountryParams {
    /// Filter to retrieve the country permissions by specifying the [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
    pub iso_code: Option<String>,
    /// Filter to retrieve the country permissions by specifying the continent
    pub continent: Option<String>,
    /// Filter the results by specified [country codes](https://www.itu.int/itudoc/itu-t/ob-lists/icc/e164_763.html)
    pub country_code: Option<String>,
    /// Filter to retrieve the country permissions with dialing to low-risk numbers enabled. Can be: `true` or `false`.
    pub low_risk_numbers_enabled: Option<bool>,
    /// Filter to retrieve the country permissions with dialing to high-risk special service numbers enabled. Can be: `true` or `false`
    pub high_risk_special_numbers_enabled: Option<bool>,
    /// Filter to retrieve the country permissions with dialing to high-risk [toll fraud](https://www.twilio.com/learn/voice-and-video/toll-fraud) numbers enabled. Can be: `true` or `false`.
    pub high_risk_tollfraud_numbers_enabled: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_dialing_permissions_hrs_prefixes`
#[derive(Clone, Debug, Default)]
pub struct ListDialingPermissionsHrsPrefixesParams {
    /// The [ISO 3166-1 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to identify the country permissions from which high-risk special service number prefixes are fetched
    pub iso_code: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_ip_record`
#[derive(Clone, Debug, Default)]
pub struct ListIpRecordParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_source_ip_mapping`
#[derive(Clone, Debug, Default)]
pub struct ListSourceIpMappingParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_byoc_trunk`
#[derive(Clone, Debug, Default)]
pub struct UpdateByocTrunkParams {
    /// The Twilio-provided string that uniquely identifies the BYOC Trunk resource to update.
    pub sid: String,
    /// Whether Caller ID Name (CNAM) lookup is enabled for the trunk. If enabled, all inbound calls to the BYOC Trunk from the United States and Canada automatically perform a CNAM Lookup and display Caller ID data on your phone. See [CNAM Lookups](https://www.twilio.com/docs/sip-trunking#CNAM) for more information.
    pub cnam_lookup_enabled: Option<bool>,
    /// The SID of the Connection Policy that Twilio will use when routing traffic to your communications infrastructure.
    pub connection_policy_sid: Option<String>,
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>,
    /// The SID of the SIP Domain that should be used in the `From` header of originating calls sent to your SIP infrastructure. If your SIP infrastructure allows users to \\\"call back\\\" an incoming call, configure this with a [SIP Domain](https://www.twilio.com/docs/voice/api/sending-sip) to ensure proper routing. If not configured, the from domain will default to \\\"sip.twilio.com\\\".
    pub from_domain_sid: Option<String>,
    /// The HTTP method we should use to call `status_callback_url`. Can be: `GET` or `POST`.
    pub status_callback_method: Option<String>,
    /// The URL that we should call to pass status parameters (such as call ended) to your application.
    pub status_callback_url: Option<String>,
    /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL that we should call when an error occurs while retrieving or executing the TwiML requested by `voice_url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method we should use to call `voice_url`
    pub voice_method: Option<String>,
    /// The URL we should call when the BYOC Trunk receives a call.
    pub voice_url: Option<String>
}

/// struct for passing parameters to the method `update_connection_policy`
#[derive(Clone, Debug, Default)]
pub struct UpdateConnectionPolicyParams {
    /// The unique string that we created to identify the Connection Policy resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `update_connection_policy_target`
#[derive(Clone, Debug, Default)]
pub struct UpdateConnectionPolicyTargetParams {
    /// The SID of the Connection Policy that owns the Target.
    pub connection_policy_sid: String,
    /// The unique string that we created to identify the Target resource to update.
    pub sid: String,
    /// Whether the Target is enabled.
    pub enabled: Option<bool>,
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>,
    /// The relative importance of the target. Can be an integer from 0 to 65535, inclusive. The lowest number represents the most important target.
    pub priority: Option<i32>,
    /// The SIP address you want Twilio to route your calls to. This must be a `sip:` schema. `sips` is NOT supported.
    pub target: Option<String>,
    /// The value that determines the relative share of the load the Target should receive compared to other Targets with the same priority. Can be an integer from 1 to 65535, inclusive. Targets with higher values receive more load than those with lower ones with the same priority.
    pub weight: Option<i32>
}

/// struct for passing parameters to the method `update_dialing_permissions_settings`
#[derive(Clone, Debug, Default)]
pub struct UpdateDialingPermissionsSettingsParams {
    /// `true` for the sub-account to inherit voice dialing permissions from the Master Project; otherwise `false`.
    pub dialing_permissions_inheritance: Option<bool>
}

/// struct for passing parameters to the method `update_ip_record`
#[derive(Clone, Debug, Default)]
pub struct UpdateIpRecordParams {
    /// The Twilio-provided string that uniquely identifies the IP Record resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the resource. It is not unique and can be up to 255 characters long.
    pub friendly_name: Option<String>
}

/// struct for passing parameters to the method `update_source_ip_mapping`
#[derive(Clone, Debug, Default)]
pub struct UpdateSourceIpMappingParams {
    /// The Twilio-provided string that uniquely identifies the IP Record resource to update.
    pub sid: String,
    /// The SID of the SIP Domain that the IP Record should be mapped to.
    pub sip_domain_sid: String
}


/// struct for typed successes of method `create_byoc_trunk`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateByocTrunkSuccess {
    Status201(crate::models::VoiceV1ByocTrunk),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_connection_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConnectionPolicySuccess {
    Status201(crate::models::VoiceV1ConnectionPolicy),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_connection_policy_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConnectionPolicyTargetSuccess {
    Status201(crate::models::VoiceV1ConnectionPolicyConnectionPolicyTarget),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_dialing_permissions_country_bulk_update`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDialingPermissionsCountryBulkUpdateSuccess {
    Status201(crate::models::VoiceV1DialingPermissionsDialingPermissionsCountryBulkUpdate),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_ip_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIpRecordSuccess {
    Status201(crate::models::VoiceV1IpRecord),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_source_ip_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSourceIpMappingSuccess {
    Status201(crate::models::VoiceV1SourceIpMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_byoc_trunk`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteByocTrunkSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_connection_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConnectionPolicySuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_connection_policy_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConnectionPolicyTargetSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_ip_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIpRecordSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_source_ip_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSourceIpMappingSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_byoc_trunk`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchByocTrunkSuccess {
    Status200(crate::models::VoiceV1ByocTrunk),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_connection_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConnectionPolicySuccess {
    Status200(crate::models::VoiceV1ConnectionPolicy),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_connection_policy_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConnectionPolicyTargetSuccess {
    Status200(crate::models::VoiceV1ConnectionPolicyConnectionPolicyTarget),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_dialing_permissions_country`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDialingPermissionsCountrySuccess {
    Status200(crate::models::VoiceV1DialingPermissionsDialingPermissionsCountryInstance),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_dialing_permissions_settings`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDialingPermissionsSettingsSuccess {
    Status200(crate::models::VoiceV1DialingPermissionsDialingPermissionsSettings),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_ip_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchIpRecordSuccess {
    Status200(crate::models::VoiceV1IpRecord),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_source_ip_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSourceIpMappingSuccess {
    Status200(crate::models::VoiceV1SourceIpMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_byoc_trunk`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListByocTrunkSuccess {
    Status200(crate::models::ListByocTrunkResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_connection_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConnectionPolicySuccess {
    Status200(crate::models::ListConnectionPolicyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_connection_policy_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConnectionPolicyTargetSuccess {
    Status200(crate::models::ListConnectionPolicyTargetResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_dialing_permissions_country`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDialingPermissionsCountrySuccess {
    Status200(crate::models::ListDialingPermissionsCountryResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_dialing_permissions_hrs_prefixes`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDialingPermissionsHrsPrefixesSuccess {
    Status200(crate::models::ListDialingPermissionsHrsPrefixesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_ip_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIpRecordSuccess {
    Status200(crate::models::ListIpRecordResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_source_ip_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSourceIpMappingSuccess {
    Status200(crate::models::ListSourceIpMappingResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_byoc_trunk`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateByocTrunkSuccess {
    Status200(crate::models::VoiceV1ByocTrunk),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_connection_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConnectionPolicySuccess {
    Status200(crate::models::VoiceV1ConnectionPolicy),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_connection_policy_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConnectionPolicyTargetSuccess {
    Status200(crate::models::VoiceV1ConnectionPolicyConnectionPolicyTarget),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_dialing_permissions_settings`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDialingPermissionsSettingsSuccess {
    Status202(crate::models::VoiceV1DialingPermissionsDialingPermissionsSettings),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_ip_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateIpRecordSuccess {
    Status200(crate::models::VoiceV1IpRecord),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_source_ip_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSourceIpMappingSuccess {
    Status200(crate::models::VoiceV1SourceIpMapping),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_byoc_trunk`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateByocTrunkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_connection_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConnectionPolicyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_connection_policy_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateConnectionPolicyTargetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_dialing_permissions_country_bulk_update`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDialingPermissionsCountryBulkUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_ip_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIpRecordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_source_ip_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSourceIpMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_byoc_trunk`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteByocTrunkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_connection_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConnectionPolicyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_connection_policy_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteConnectionPolicyTargetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_ip_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIpRecordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_source_ip_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSourceIpMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_byoc_trunk`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchByocTrunkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_connection_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConnectionPolicyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_connection_policy_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchConnectionPolicyTargetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_dialing_permissions_country`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDialingPermissionsCountryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_dialing_permissions_settings`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchDialingPermissionsSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_ip_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchIpRecordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_source_ip_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSourceIpMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_byoc_trunk`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListByocTrunkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_connection_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConnectionPolicyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_connection_policy_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListConnectionPolicyTargetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_dialing_permissions_country`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDialingPermissionsCountryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_dialing_permissions_hrs_prefixes`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDialingPermissionsHrsPrefixesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_ip_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListIpRecordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_source_ip_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSourceIpMappingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_byoc_trunk`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateByocTrunkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_connection_policy`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConnectionPolicyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_connection_policy_target`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateConnectionPolicyTargetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_dialing_permissions_settings`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDialingPermissionsSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_ip_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateIpRecordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_source_ip_mapping`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSourceIpMappingError {
    UnknownValue(serde_json::Value),
}


pub async fn create_byoc_trunk(configuration: &configuration::Configuration, params: CreateByocTrunkParams) -> Result<ResponseContent<CreateByocTrunkSuccess>, Error<CreateByocTrunkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let cnam_lookup_enabled = params.cnam_lookup_enabled;
    let connection_policy_sid = params.connection_policy_sid;
    let friendly_name = params.friendly_name;
    let from_domain_sid = params.from_domain_sid;
    let status_callback_method = params.status_callback_method;
    let status_callback_url = params.status_callback_url;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ByocTrunks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = cnam_lookup_enabled {
        local_var_form_params.insert("CnamLookupEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = connection_policy_sid {
        local_var_form_params.insert("ConnectionPolicySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = from_domain_sid {
        local_var_form_params.insert("FromDomainSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_url {
        local_var_form_params.insert("StatusCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateByocTrunkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateByocTrunkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_connection_policy(configuration: &configuration::Configuration, params: CreateConnectionPolicyParams) -> Result<ResponseContent<CreateConnectionPolicySuccess>, Error<CreateConnectionPolicyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ConnectionPolicies", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateConnectionPolicySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateConnectionPolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_connection_policy_target(configuration: &configuration::Configuration, params: CreateConnectionPolicyTargetParams) -> Result<ResponseContent<CreateConnectionPolicyTargetSuccess>, Error<CreateConnectionPolicyTargetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let connection_policy_sid = params.connection_policy_sid;
    let target = params.target;
    let enabled = params.enabled;
    let friendly_name = params.friendly_name;
    let priority = params.priority;
    let weight = params.weight;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ConnectionPolicies/{ConnectionPolicySid}/Targets", local_var_configuration.base_path, ConnectionPolicySid=crate::apis::urlencode(connection_policy_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = enabled {
        local_var_form_params.insert("Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = priority {
        local_var_form_params.insert("Priority", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Target", target.to_string());
    if let Some(local_var_param_value) = weight {
        local_var_form_params.insert("Weight", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateConnectionPolicyTargetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateConnectionPolicyTargetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a bulk update request to change voice dialing country permissions of one or more countries identified by the corresponding [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
pub async fn create_dialing_permissions_country_bulk_update(configuration: &configuration::Configuration, params: CreateDialingPermissionsCountryBulkUpdateParams) -> Result<ResponseContent<CreateDialingPermissionsCountryBulkUpdateSuccess>, Error<CreateDialingPermissionsCountryBulkUpdateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let update_request = params.update_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/DialingPermissions/BulkCountryUpdates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("UpdateRequest", update_request.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateDialingPermissionsCountryBulkUpdateSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateDialingPermissionsCountryBulkUpdateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_ip_record(configuration: &configuration::Configuration, params: CreateIpRecordParams) -> Result<ResponseContent<CreateIpRecordSuccess>, Error<CreateIpRecordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ip_address = params.ip_address;
    let cidr_prefix_length = params.cidr_prefix_length;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/IpRecords", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = cidr_prefix_length {
        local_var_form_params.insert("CidrPrefixLength", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_form_params.insert("IpAddress", ip_address.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateIpRecordSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateIpRecordError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_source_ip_mapping(configuration: &configuration::Configuration, params: CreateSourceIpMappingParams) -> Result<ResponseContent<CreateSourceIpMappingSuccess>, Error<CreateSourceIpMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let ip_record_sid = params.ip_record_sid;
    let sip_domain_sid = params.sip_domain_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/SourceIpMappings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("IpRecordSid", ip_record_sid.to_string());
    local_var_form_params.insert("SipDomainSid", sip_domain_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateSourceIpMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateSourceIpMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_byoc_trunk(configuration: &configuration::Configuration, params: DeleteByocTrunkParams) -> Result<ResponseContent<DeleteByocTrunkSuccess>, Error<DeleteByocTrunkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ByocTrunks/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteByocTrunkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteByocTrunkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_connection_policy(configuration: &configuration::Configuration, params: DeleteConnectionPolicyParams) -> Result<ResponseContent<DeleteConnectionPolicySuccess>, Error<DeleteConnectionPolicyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ConnectionPolicies/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteConnectionPolicySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteConnectionPolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_connection_policy_target(configuration: &configuration::Configuration, params: DeleteConnectionPolicyTargetParams) -> Result<ResponseContent<DeleteConnectionPolicyTargetSuccess>, Error<DeleteConnectionPolicyTargetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let connection_policy_sid = params.connection_policy_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}", local_var_configuration.base_path, ConnectionPolicySid=crate::apis::urlencode(connection_policy_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteConnectionPolicyTargetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteConnectionPolicyTargetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_ip_record(configuration: &configuration::Configuration, params: DeleteIpRecordParams) -> Result<ResponseContent<DeleteIpRecordSuccess>, Error<DeleteIpRecordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/IpRecords/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteIpRecordSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteIpRecordError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_source_ip_mapping(configuration: &configuration::Configuration, params: DeleteSourceIpMappingParams) -> Result<ResponseContent<DeleteSourceIpMappingSuccess>, Error<DeleteSourceIpMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/SourceIpMappings/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSourceIpMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSourceIpMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_byoc_trunk(configuration: &configuration::Configuration, params: FetchByocTrunkParams) -> Result<ResponseContent<FetchByocTrunkSuccess>, Error<FetchByocTrunkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ByocTrunks/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchByocTrunkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchByocTrunkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_connection_policy(configuration: &configuration::Configuration, params: FetchConnectionPolicyParams) -> Result<ResponseContent<FetchConnectionPolicySuccess>, Error<FetchConnectionPolicyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ConnectionPolicies/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConnectionPolicySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConnectionPolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_connection_policy_target(configuration: &configuration::Configuration, params: FetchConnectionPolicyTargetParams) -> Result<ResponseContent<FetchConnectionPolicyTargetSuccess>, Error<FetchConnectionPolicyTargetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let connection_policy_sid = params.connection_policy_sid;
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}", local_var_configuration.base_path, ConnectionPolicySid=crate::apis::urlencode(connection_policy_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchConnectionPolicyTargetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchConnectionPolicyTargetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve voice dialing country permissions identified by the given ISO country code
pub async fn fetch_dialing_permissions_country(configuration: &configuration::Configuration, params: FetchDialingPermissionsCountryParams) -> Result<ResponseContent<FetchDialingPermissionsCountrySuccess>, Error<FetchDialingPermissionsCountryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let iso_code = params.iso_code;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/DialingPermissions/Countries/{IsoCode}", local_var_configuration.base_path, IsoCode=crate::apis::urlencode(iso_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchDialingPermissionsCountrySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchDialingPermissionsCountryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve voice dialing permissions inheritance for the sub-account
pub async fn fetch_dialing_permissions_settings(configuration: &configuration::Configuration) -> Result<ResponseContent<FetchDialingPermissionsSettingsSuccess>, Error<FetchDialingPermissionsSettingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Settings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchDialingPermissionsSettingsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchDialingPermissionsSettingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_ip_record(configuration: &configuration::Configuration, params: FetchIpRecordParams) -> Result<ResponseContent<FetchIpRecordSuccess>, Error<FetchIpRecordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/IpRecords/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchIpRecordSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchIpRecordError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_source_ip_mapping(configuration: &configuration::Configuration, params: FetchSourceIpMappingParams) -> Result<ResponseContent<FetchSourceIpMappingSuccess>, Error<FetchSourceIpMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/SourceIpMappings/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSourceIpMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSourceIpMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_byoc_trunk(configuration: &configuration::Configuration, params: ListByocTrunkParams) -> Result<ResponseContent<ListByocTrunkSuccess>, Error<ListByocTrunkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ByocTrunks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListByocTrunkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListByocTrunkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_connection_policy(configuration: &configuration::Configuration, params: ListConnectionPolicyParams) -> Result<ResponseContent<ListConnectionPolicySuccess>, Error<ListConnectionPolicyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ConnectionPolicies", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListConnectionPolicySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListConnectionPolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_connection_policy_target(configuration: &configuration::Configuration, params: ListConnectionPolicyTargetParams) -> Result<ResponseContent<ListConnectionPolicyTargetSuccess>, Error<ListConnectionPolicyTargetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let connection_policy_sid = params.connection_policy_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ConnectionPolicies/{ConnectionPolicySid}/Targets", local_var_configuration.base_path, ConnectionPolicySid=crate::apis::urlencode(connection_policy_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListConnectionPolicyTargetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListConnectionPolicyTargetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve all voice dialing country permissions for this account
pub async fn list_dialing_permissions_country(configuration: &configuration::Configuration, params: ListDialingPermissionsCountryParams) -> Result<ResponseContent<ListDialingPermissionsCountrySuccess>, Error<ListDialingPermissionsCountryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let iso_code = params.iso_code;
    let continent = params.continent;
    let country_code = params.country_code;
    let low_risk_numbers_enabled = params.low_risk_numbers_enabled;
    let high_risk_special_numbers_enabled = params.high_risk_special_numbers_enabled;
    let high_risk_tollfraud_numbers_enabled = params.high_risk_tollfraud_numbers_enabled;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/DialingPermissions/Countries", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = iso_code {
        local_var_req_builder = local_var_req_builder.query(&[("IsoCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = continent {
        local_var_req_builder = local_var_req_builder.query(&[("Continent", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = country_code {
        local_var_req_builder = local_var_req_builder.query(&[("CountryCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = low_risk_numbers_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("LowRiskNumbersEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = high_risk_special_numbers_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("HighRiskSpecialNumbersEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = high_risk_tollfraud_numbers_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("HighRiskTollfraudNumbersEnabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListDialingPermissionsCountrySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListDialingPermissionsCountryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the high-risk special services prefixes from the country resource corresponding to the [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
pub async fn list_dialing_permissions_hrs_prefixes(configuration: &configuration::Configuration, params: ListDialingPermissionsHrsPrefixesParams) -> Result<ResponseContent<ListDialingPermissionsHrsPrefixesSuccess>, Error<ListDialingPermissionsHrsPrefixesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let iso_code = params.iso_code;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/DialingPermissions/Countries/{IsoCode}/HighRiskSpecialPrefixes", local_var_configuration.base_path, IsoCode=crate::apis::urlencode(iso_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListDialingPermissionsHrsPrefixesSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListDialingPermissionsHrsPrefixesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_ip_record(configuration: &configuration::Configuration, params: ListIpRecordParams) -> Result<ResponseContent<ListIpRecordSuccess>, Error<ListIpRecordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/IpRecords", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListIpRecordSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListIpRecordError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_source_ip_mapping(configuration: &configuration::Configuration, params: ListSourceIpMappingParams) -> Result<ResponseContent<ListSourceIpMappingSuccess>, Error<ListSourceIpMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/SourceIpMappings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSourceIpMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSourceIpMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_byoc_trunk(configuration: &configuration::Configuration, params: UpdateByocTrunkParams) -> Result<ResponseContent<UpdateByocTrunkSuccess>, Error<UpdateByocTrunkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let cnam_lookup_enabled = params.cnam_lookup_enabled;
    let connection_policy_sid = params.connection_policy_sid;
    let friendly_name = params.friendly_name;
    let from_domain_sid = params.from_domain_sid;
    let status_callback_method = params.status_callback_method;
    let status_callback_url = params.status_callback_url;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ByocTrunks/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = cnam_lookup_enabled {
        local_var_form_params.insert("CnamLookupEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = connection_policy_sid {
        local_var_form_params.insert("ConnectionPolicySid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = from_domain_sid {
        local_var_form_params.insert("FromDomainSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_url {
        local_var_form_params.insert("StatusCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateByocTrunkSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateByocTrunkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_connection_policy(configuration: &configuration::Configuration, params: UpdateConnectionPolicyParams) -> Result<ResponseContent<UpdateConnectionPolicySuccess>, Error<UpdateConnectionPolicyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ConnectionPolicies/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConnectionPolicySuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConnectionPolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_connection_policy_target(configuration: &configuration::Configuration, params: UpdateConnectionPolicyTargetParams) -> Result<ResponseContent<UpdateConnectionPolicyTargetSuccess>, Error<UpdateConnectionPolicyTargetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let connection_policy_sid = params.connection_policy_sid;
    let sid = params.sid;
    let enabled = params.enabled;
    let friendly_name = params.friendly_name;
    let priority = params.priority;
    let target = params.target;
    let weight = params.weight;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}", local_var_configuration.base_path, ConnectionPolicySid=crate::apis::urlencode(connection_policy_sid), Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = enabled {
        local_var_form_params.insert("Enabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = priority {
        local_var_form_params.insert("Priority", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = target {
        local_var_form_params.insert("Target", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = weight {
        local_var_form_params.insert("Weight", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateConnectionPolicyTargetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateConnectionPolicyTargetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update voice dialing permissions inheritance for the sub-account
pub async fn update_dialing_permissions_settings(configuration: &configuration::Configuration, params: UpdateDialingPermissionsSettingsParams) -> Result<ResponseContent<UpdateDialingPermissionsSettingsSuccess>, Error<UpdateDialingPermissionsSettingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let dialing_permissions_inheritance = params.dialing_permissions_inheritance;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Settings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = dialing_permissions_inheritance {
        local_var_form_params.insert("DialingPermissionsInheritance", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateDialingPermissionsSettingsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateDialingPermissionsSettingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_ip_record(configuration: &configuration::Configuration, params: UpdateIpRecordParams) -> Result<ResponseContent<UpdateIpRecordSuccess>, Error<UpdateIpRecordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let friendly_name = params.friendly_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/IpRecords/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateIpRecordSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateIpRecordError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_source_ip_mapping(configuration: &configuration::Configuration, params: UpdateSourceIpMappingParams) -> Result<ResponseContent<UpdateSourceIpMappingSuccess>, Error<UpdateSourceIpMappingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let sip_domain_sid = params.sip_domain_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/SourceIpMappings/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("SipDomainSid", sip_domain_sid.to_string());
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSourceIpMappingSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSourceIpMappingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

