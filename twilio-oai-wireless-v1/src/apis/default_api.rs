/*
 * Twilio - Wireless
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.20.3
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method `create_command`
#[derive(Clone, Debug, Default)]
pub struct CreateCommandParams {
    /// The message body of the Command. Can be plain text in text mode or a Base64 encoded byte string in binary mode.
    pub command: String,
    /// The HTTP method we use to call `callback_url`. Can be: `POST` or `GET`, and the default is `POST`.
    pub callback_method: Option<String>,
    /// The URL we call using the `callback_url` when the Command has finished sending, whether the command was delivered or it failed.
    pub callback_url: Option<String>,
    /// The mode to use when sending the SMS message. Can be: `text` or `binary`. The default SMS mode is `text`.
    pub command_mode: Option<String>,
    /// Whether to request delivery receipt from the recipient. For Commands that request delivery receipt, the Command state transitions to 'delivered' once the server has received a delivery receipt from the device. The default value is `true`.
    pub delivery_receipt_requested: Option<bool>,
    /// Whether to include the SID of the command in the message body. Can be: `none`, `start`, or `end`, and the default behavior is `none`. When sending a Command to a SIM in text mode, we can automatically include the SID of the Command in the message body, which could be used to ensure that the device does not process the same Command more than once.  A value of `start` will prepend the message with the Command SID, and `end` will append it to the end, separating the Command SID from the message body with a space. The length of the Command SID is included in the 160 character limit so the SMS body must be 128 characters or less before the Command SID is included.
    pub include_sid: Option<String>,
    /// The `sid` or `unique_name` of the [SIM](https://www.twilio.com/docs/wireless/api/sim-resource) to send the Command to.
    pub sim: Option<String>
}

/// struct for passing parameters to the method `create_rate_plan`
#[derive(Clone, Debug, Default)]
pub struct CreateRatePlanParams {
    /// Whether SIMs can use GPRS/3G/4G/LTE data connectivity.
    pub data_enabled: Option<bool>,
    /// The total data usage (download and upload combined) in Megabytes that the Network allows during one month on the home network (T-Mobile USA). The metering period begins the day of activation and ends on the same day in the following month. Can be up to 2TB and the default value is `1000`.
    pub data_limit: Option<i32>,
    /// The model used to meter data usage. Can be: `payg` and `quota-1`, `quota-10`, and `quota-50`. Learn more about the available [data metering models](https://www.twilio.com/docs/wireless/api/rateplan-resource#payg-vs-quota-data-plans).
    pub data_metering: Option<String>,
    /// A descriptive string that you create to describe the resource. It does not have to be unique.
    pub friendly_name: Option<String>,
    /// The list of services that SIMs capable of using GPRS/3G/4G/LTE data connectivity can use outside of the United States. Can be: `data`, `voice`, and `messaging`.
    pub international_roaming: Option<Vec<String>>,
    /// The total data usage (download and upload combined) in Megabytes that the Network allows during one month when roaming outside the United States. Can be up to 2TB.
    pub international_roaming_data_limit: Option<i32>,
    /// Whether SIMs can make, send, and receive SMS using [Commands](https://www.twilio.com/docs/wireless/api/command-resource).
    pub messaging_enabled: Option<bool>,
    /// The total data usage (download and upload combined) in Megabytes that the Network allows during one month on non-home networks in the United States. The metering period begins the day of activation and ends on the same day in the following month. Can be up to 2TB. See [national roaming](https://www.twilio.com/docs/wireless/api/rateplan-resource#national-roaming) for more info.
    pub national_roaming_data_limit: Option<i32>,
    /// Whether SIMs can roam on networks other than the home network (T-Mobile USA) in the United States. See [national roaming](https://www.twilio.com/docs/wireless/api/rateplan-resource#national-roaming).
    pub national_roaming_enabled: Option<bool>,
    /// An application-defined string that uniquely identifies the resource. It can be used in place of the resource's `sid` in the URL to address the resource.
    pub unique_name: Option<String>,
    /// Whether SIMs can make and receive voice calls.
    pub voice_enabled: Option<bool>
}

/// struct for passing parameters to the method `delete_command`
#[derive(Clone, Debug, Default)]
pub struct DeleteCommandParams {
    /// The SID of the Command resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_rate_plan`
#[derive(Clone, Debug, Default)]
pub struct DeleteRatePlanParams {
    /// The SID of the RatePlan resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `delete_sim`
#[derive(Clone, Debug, Default)]
pub struct DeleteSimParams {
    /// The SID or the `unique_name` of the Sim resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_command`
#[derive(Clone, Debug, Default)]
pub struct FetchCommandParams {
    /// The SID of the Command resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_rate_plan`
#[derive(Clone, Debug, Default)]
pub struct FetchRatePlanParams {
    /// The SID of the RatePlan resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `fetch_sim`
#[derive(Clone, Debug, Default)]
pub struct FetchSimParams {
    /// The SID or the `unique_name` of the Sim resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method `list_account_usage_record`
#[derive(Clone, Debug, Default)]
pub struct ListAccountUsageRecordParams {
    /// Only include usage that has occurred on or before this date. Format is [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html).
    pub end: Option<String>,
    /// Only include usage that has occurred on or after this date. Format is [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html).
    pub start: Option<String>,
    /// How to summarize the usage by time. Can be: `daily`, `hourly`, or `all`. A value of `all` returns one Usage Record that describes the usage for the entire period.
    pub granularity: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_command`
#[derive(Clone, Debug, Default)]
pub struct ListCommandParams {
    /// The `sid` or `unique_name` of the [Sim resources](https://www.twilio.com/docs/wireless/api/sim-resource) to read.
    pub sim: Option<String>,
    /// The status of the resources to read. Can be: `queued`, `sent`, `delivered`, `received`, or `failed`.
    pub status: Option<String>,
    /// Only return Commands with this direction value.
    pub direction: Option<String>,
    /// Only return Commands with this transport value. Can be: `sms` or `ip`.
    pub transport: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_data_session`
#[derive(Clone, Debug, Default)]
pub struct ListDataSessionParams {
    /// The SID of the [Sim resource](https://www.twilio.com/docs/wireless/api/sim-resource) with the Data Sessions to read.
    pub sim_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_rate_plan`
#[derive(Clone, Debug, Default)]
pub struct ListRatePlanParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_sim`
#[derive(Clone, Debug, Default)]
pub struct ListSimParams {
    /// Only return Sim resources with this status.
    pub status: Option<String>,
    /// Only return Sim resources with this ICCID. This will return a list with a maximum size of 1.
    pub iccid: Option<String>,
    /// The SID or unique name of a [RatePlan resource](https://www.twilio.com/docs/wireless/api/rateplan-resource). Only return Sim resources assigned to this RatePlan resource.
    pub rate_plan: Option<String>,
    /// Deprecated.
    pub eid: Option<String>,
    /// Only return Sim resources with this registration code. This will return a list with a maximum size of 1.
    pub sim_registration_code: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `list_usage_record`
#[derive(Clone, Debug, Default)]
pub struct ListUsageRecordParams {
    /// The SID of the [Sim resource](https://www.twilio.com/docs/wireless/api/sim-resource)  to read the usage from.
    pub sim_sid: String,
    /// Only include usage that occurred on or before this date, specified in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html). The default is the current time.
    pub end: Option<String>,
    /// Only include usage that has occurred on or after this date, specified in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html). The default is one month before the `end` parameter value.
    pub start: Option<String>,
    /// How to summarize the usage by time. Can be: `daily`, `hourly`, or `all`. The default is `all`. A value of `all` returns one Usage Record that describes the usage for the entire period.
    pub granularity: Option<String>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method `update_rate_plan`
#[derive(Clone, Debug, Default)]
pub struct UpdateRatePlanParams {
    /// The SID of the RatePlan resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the resource. It does not have to be unique.
    pub friendly_name: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used in place of the resource's `sid` in the URL to address the resource.
    pub unique_name: Option<String>
}

/// struct for passing parameters to the method `update_sim`
#[derive(Clone, Debug, Default)]
pub struct UpdateSimParams {
    /// The SID or the `unique_name` of the Sim resource to update.
    pub sid: String,
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) to which the Sim resource should belong. The Account SID can only be that of the requesting Account or that of a [Subaccount](https://www.twilio.com/docs/iam/api/subaccounts) of the requesting Account. Only valid when the Sim resource's status is `new`. For more information, see the [Move SIMs between Subaccounts documentation](https://www.twilio.com/docs/wireless/api/sim-resource#move-sims-between-subaccounts).
    pub account_sid: Option<String>,
    /// The HTTP method we should use to call `callback_url`. Can be: `POST` or `GET`. The default is `POST`.
    pub callback_method: Option<String>,
    /// The URL we should call using the `callback_url` when the SIM has finished updating. When the SIM transitions from `new` to `ready` or from any status to `deactivated`, we call this URL when the status changes to an intermediate status (`ready` or `deactivated`) and again when the status changes to its final status (`active` or `canceled`).
    pub callback_url: Option<String>,
    /// The HTTP method we should use to call `commands_callback_url`. Can be: `POST` or `GET`. The default is `POST`.
    pub commands_callback_method: Option<String>,
    /// The URL we should call using the `commands_callback_method` when the SIM sends a [Command](https://www.twilio.com/docs/wireless/api/command-resource). Your server should respond with an HTTP status code in the 200 range; any response body is ignored.
    pub commands_callback_url: Option<String>,
    /// A descriptive string that you create to describe the Sim resource. It does not need to be unique.
    pub friendly_name: Option<String>,
    /// The SID or unique name of the [RatePlan resource](https://www.twilio.com/docs/wireless/api/rateplan-resource) to which the Sim resource should be assigned.
    pub rate_plan: Option<String>,
    /// Initiate a connectivity reset on the SIM. Set to `resetting` to initiate a connectivity reset on the SIM. No other value is valid.
    pub reset_status: Option<String>,
    /// The HTTP method we should use to call `sms_fallback_url`. Can be: `GET` or `POST`. Default is `POST`.
    pub sms_fallback_method: Option<String>,
    /// The URL we should call using the `sms_fallback_method` when an error occurs while retrieving or executing the TwiML requested from `sms_url`.
    pub sms_fallback_url: Option<String>,
    /// The HTTP method we should use to call `sms_url`. Can be: `GET` or `POST`. Default is `POST`.
    pub sms_method: Option<String>,
    /// The URL we should call using the `sms_method` when the SIM-connected device sends an SMS message that is not a [Command](https://www.twilio.com/docs/wireless/api/command-resource).
    pub sms_url: Option<String>,
    /// The new status of the Sim resource. Can be: `ready`, `active`, `suspended`, or `deactivated`.
    pub status: Option<String>,
    /// An application-defined string that uniquely identifies the resource. It can be used in place of the `sid` in the URL path to address the resource.
    pub unique_name: Option<String>,
    /// The HTTP method we should use to call `voice_fallback_url`. Can be: `GET` or `POST`.
    pub voice_fallback_method: Option<String>,
    /// The URL we should call using the `voice_fallback_method` when an error occurs while retrieving or executing the TwiML requested from `voice_url`.
    pub voice_fallback_url: Option<String>,
    /// The HTTP method we should use when we call `voice_url`. Can be: `GET` or `POST`.
    pub voice_method: Option<String>,
    /// The URL we should call using the `voice_method` when the SIM-connected device makes a voice call.
    pub voice_url: Option<String>
}


/// struct for typed successes of method `create_command`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCommandSuccess {
    Status201(crate::models::WirelessV1Command),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `create_rate_plan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRatePlanSuccess {
    Status201(crate::models::WirelessV1RatePlan),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_command`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCommandSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_rate_plan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRatePlanSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `delete_sim`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSimSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_command`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCommandSuccess {
    Status200(crate::models::WirelessV1Command),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_rate_plan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRatePlanSuccess {
    Status200(crate::models::WirelessV1RatePlan),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `fetch_sim`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSimSuccess {
    Status200(crate::models::WirelessV1Sim),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_account_usage_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAccountUsageRecordSuccess {
    Status200(crate::models::ListAccountUsageRecordResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_command`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCommandSuccess {
    Status200(crate::models::ListCommandResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_data_session`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDataSessionSuccess {
    Status200(crate::models::ListDataSessionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_rate_plan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRatePlanSuccess {
    Status200(crate::models::ListRatePlanResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_sim`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSimSuccess {
    Status200(crate::models::ListSimResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `list_usage_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordSuccess {
    Status200(crate::models::ListUsageRecordResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_rate_plan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRatePlanSuccess {
    Status200(crate::models::WirelessV1RatePlan),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method `update_sim`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSimSuccess {
    Status200(crate::models::WirelessV1Sim),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_command`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_rate_plan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRatePlanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_command`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_rate_plan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRatePlanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `delete_sim`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSimError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_command`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_rate_plan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRatePlanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `fetch_sim`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSimError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_account_usage_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAccountUsageRecordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_command`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_data_session`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDataSessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_rate_plan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRatePlanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_sim`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSimError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `list_usage_record`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListUsageRecordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_rate_plan`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRatePlanError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_sim`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSimError {
    UnknownValue(serde_json::Value),
}


/// Send a Command to a Sim.
pub async fn create_command(configuration: &configuration::Configuration, params: CreateCommandParams) -> Result<ResponseContent<CreateCommandSuccess>, Error<CreateCommandError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let command = params.command;
    let callback_method = params.callback_method;
    let callback_url = params.callback_url;
    let command_mode = params.command_mode;
    let delivery_receipt_requested = params.delivery_receipt_requested;
    let include_sid = params.include_sid;
    let sim = params.sim;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Commands", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = callback_method {
        local_var_form_params.insert("CallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = callback_url {
        local_var_form_params.insert("CallbackUrl", local_var_param_value.to_string());
    }
    local_var_form_params.insert("Command", command.to_string());
    if let Some(local_var_param_value) = command_mode {
        local_var_form_params.insert("CommandMode", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = delivery_receipt_requested {
        local_var_form_params.insert("DeliveryReceiptRequested", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = include_sid {
        local_var_form_params.insert("IncludeSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sim {
        local_var_form_params.insert("Sim", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateCommandSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateCommandError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_rate_plan(configuration: &configuration::Configuration, params: CreateRatePlanParams) -> Result<ResponseContent<CreateRatePlanSuccess>, Error<CreateRatePlanError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let data_enabled = params.data_enabled;
    let data_limit = params.data_limit;
    let data_metering = params.data_metering;
    let friendly_name = params.friendly_name;
    let international_roaming = params.international_roaming;
    let international_roaming_data_limit = params.international_roaming_data_limit;
    let messaging_enabled = params.messaging_enabled;
    let national_roaming_data_limit = params.national_roaming_data_limit;
    let national_roaming_enabled = params.national_roaming_enabled;
    let unique_name = params.unique_name;
    let voice_enabled = params.voice_enabled;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/RatePlans", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = data_enabled {
        local_var_form_params.insert("DataEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = data_limit {
        local_var_form_params.insert("DataLimit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = data_metering {
        local_var_form_params.insert("DataMetering", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = international_roaming {
        local_var_form_params.insert("InternationalRoaming", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = international_roaming_data_limit {
        local_var_form_params.insert("InternationalRoamingDataLimit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = messaging_enabled {
        local_var_form_params.insert("MessagingEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = national_roaming_data_limit {
        local_var_form_params.insert("NationalRoamingDataLimit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = national_roaming_enabled {
        local_var_form_params.insert("NationalRoamingEnabled", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_enabled {
        local_var_form_params.insert("VoiceEnabled", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateRatePlanSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateRatePlanError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a Command instance from your account.
pub async fn delete_command(configuration: &configuration::Configuration, params: DeleteCommandParams) -> Result<ResponseContent<DeleteCommandSuccess>, Error<DeleteCommandError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Commands/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteCommandSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteCommandError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_rate_plan(configuration: &configuration::Configuration, params: DeleteRatePlanParams) -> Result<ResponseContent<DeleteRatePlanSuccess>, Error<DeleteRatePlanError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/RatePlans/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteRatePlanSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteRatePlanError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a Sim resource on your Account.
pub async fn delete_sim(configuration: &configuration::Configuration, params: DeleteSimParams) -> Result<ResponseContent<DeleteSimSuccess>, Error<DeleteSimError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteSimSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteSimError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a Command instance from your account.
pub async fn fetch_command(configuration: &configuration::Configuration, params: FetchCommandParams) -> Result<ResponseContent<FetchCommandSuccess>, Error<FetchCommandError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Commands/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchCommandSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchCommandError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_rate_plan(configuration: &configuration::Configuration, params: FetchRatePlanParams) -> Result<ResponseContent<FetchRatePlanSuccess>, Error<FetchRatePlanError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/RatePlans/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchRatePlanSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchRatePlanError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch a Sim resource on your Account.
pub async fn fetch_sim(configuration: &configuration::Configuration, params: FetchSimParams) -> Result<ResponseContent<FetchSimSuccess>, Error<FetchSimError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<FetchSimSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<FetchSimError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_account_usage_record(configuration: &configuration::Configuration, params: ListAccountUsageRecordParams) -> Result<ResponseContent<ListAccountUsageRecordSuccess>, Error<ListAccountUsageRecordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let end = params.end;
    let start = params.start;
    let granularity = params.granularity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/UsageRecords", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end {
        local_var_req_builder = local_var_req_builder.query(&[("End", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder = local_var_req_builder.query(&[("Start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = granularity {
        local_var_req_builder = local_var_req_builder.query(&[("Granularity", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListAccountUsageRecordSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListAccountUsageRecordError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Commands from your account.
pub async fn list_command(configuration: &configuration::Configuration, params: ListCommandParams) -> Result<ResponseContent<ListCommandSuccess>, Error<ListCommandError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sim = params.sim;
    let status = params.status;
    let direction = params.direction;
    let transport = params.transport;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Commands", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sim {
        local_var_req_builder = local_var_req_builder.query(&[("Sim", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = direction {
        local_var_req_builder = local_var_req_builder.query(&[("Direction", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = transport {
        local_var_req_builder = local_var_req_builder.query(&[("Transport", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListCommandSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListCommandError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_data_session(configuration: &configuration::Configuration, params: ListDataSessionParams) -> Result<ResponseContent<ListDataSessionSuccess>, Error<ListDataSessionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sim_sid = params.sim_sid;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims/{SimSid}/DataSessions", local_var_configuration.base_path, SimSid=crate::apis::urlencode(sim_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListDataSessionSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListDataSessionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_rate_plan(configuration: &configuration::Configuration, params: ListRatePlanParams) -> Result<ResponseContent<ListRatePlanSuccess>, Error<ListRatePlanError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/RatePlans", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListRatePlanSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListRatePlanError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of Sim resources on your Account.
pub async fn list_sim(configuration: &configuration::Configuration, params: ListSimParams) -> Result<ResponseContent<ListSimSuccess>, Error<ListSimError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let status = params.status;
    let iccid = params.iccid;
    let rate_plan = params.rate_plan;
    let eid = params.eid;
    let sim_registration_code = params.sim_registration_code;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("Status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = iccid {
        local_var_req_builder = local_var_req_builder.query(&[("Iccid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = rate_plan {
        local_var_req_builder = local_var_req_builder.query(&[("RatePlan", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = eid {
        local_var_req_builder = local_var_req_builder.query(&[("EId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sim_registration_code {
        local_var_req_builder = local_var_req_builder.query(&[("SimRegistrationCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListSimSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListSimError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn list_usage_record(configuration: &configuration::Configuration, params: ListUsageRecordParams) -> Result<ResponseContent<ListUsageRecordSuccess>, Error<ListUsageRecordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sim_sid = params.sim_sid;
    let end = params.end;
    let start = params.start;
    let granularity = params.granularity;
    let page_size = params.page_size;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims/{SimSid}/UsageRecords", local_var_configuration.base_path, SimSid=crate::apis::urlencode(sim_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end {
        local_var_req_builder = local_var_req_builder.query(&[("End", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder = local_var_req_builder.query(&[("Start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = granularity {
        local_var_req_builder = local_var_req_builder.query(&[("Granularity", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<ListUsageRecordSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<ListUsageRecordError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_rate_plan(configuration: &configuration::Configuration, params: UpdateRatePlanParams) -> Result<ResponseContent<UpdateRatePlanSuccess>, Error<UpdateRatePlanError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let friendly_name = params.friendly_name;
    let unique_name = params.unique_name;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/RatePlans/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateRatePlanSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateRatePlanError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the given properties of a Sim resource on your Account.
pub async fn update_sim(configuration: &configuration::Configuration, params: UpdateSimParams) -> Result<ResponseContent<UpdateSimSuccess>, Error<UpdateSimError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sid = params.sid;
    let account_sid = params.account_sid;
    let callback_method = params.callback_method;
    let callback_url = params.callback_url;
    let commands_callback_method = params.commands_callback_method;
    let commands_callback_url = params.commands_callback_url;
    let friendly_name = params.friendly_name;
    let rate_plan = params.rate_plan;
    let reset_status = params.reset_status;
    let sms_fallback_method = params.sms_fallback_method;
    let sms_fallback_url = params.sms_fallback_url;
    let sms_method = params.sms_method;
    let sms_url = params.sms_url;
    let status = params.status;
    let unique_name = params.unique_name;
    let voice_fallback_method = params.voice_fallback_method;
    let voice_fallback_url = params.voice_fallback_url;
    let voice_method = params.voice_method;
    let voice_url = params.voice_url;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/Sims/{Sid}", local_var_configuration.base_path, Sid=crate::apis::urlencode(sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = account_sid {
        local_var_form_params.insert("AccountSid", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = callback_method {
        local_var_form_params.insert("CallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = callback_url {
        local_var_form_params.insert("CallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = commands_callback_method {
        local_var_form_params.insert("CommandsCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = commands_callback_url {
        local_var_form_params.insert("CommandsCallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = friendly_name {
        local_var_form_params.insert("FriendlyName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = rate_plan {
        local_var_form_params.insert("RatePlan", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = reset_status {
        local_var_form_params.insert("ResetStatus", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_method {
        local_var_form_params.insert("SmsFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_fallback_url {
        local_var_form_params.insert("SmsFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_method {
        local_var_form_params.insert("SmsMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sms_url {
        local_var_form_params.insert("SmsUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status {
        local_var_form_params.insert("Status", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = unique_name {
        local_var_form_params.insert("UniqueName", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_method {
        local_var_form_params.insert("VoiceFallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_fallback_url {
        local_var_form_params.insert("VoiceFallbackUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_method {
        local_var_form_params.insert("VoiceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = voice_url {
        local_var_form_params.insert("VoiceUrl", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateSimSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateSimError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

